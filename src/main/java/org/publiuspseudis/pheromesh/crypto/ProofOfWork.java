/*
 * Copyright (C) 2024 Publius Pseudis
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.publiuspseudis.pheromesh.crypto;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.BitSet;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Implements the Cuckoo Cycle proof-of-work algorithm with an epidemic-style
 * difficulty adjustment mechanism. This class is responsible for generating
 * and verifying proofs of work, as well as dynamically adjusting the difficulty
 * based on both local solve times and peer-reported difficulties.
 * <p>
 * The Cuckoo Cycle is a graph-based proof-of-work system designed to be memory-efficient
 * and resistant to ASIC optimization, making it suitable for decentralized networks.
 * </p>
 * 
 * <p>
 * Difficulty adjustment ensures that the time to find a valid proof remains
 * approximately constant by adapting to changes in network conditions and
 * computational power.
 * </p>
 * 
 * <p>
 * Example usage:
 * </p>
 * <pre>{@code
 * byte[] nodeId = ...; // Initialize node identifier
 * ProofOfWork pow = new ProofOfWork(nodeId);
 * if (pow.solve()) {
 *     byte[] proof = pow.getCurrentProof();
 *     // Broadcast or use the proof as needed
 * }
 * }</pre>
 * 
 * @author
 * Publius Pseudis
 * @version 1.0
 * @since 2024-01-01
 */
public class ProofOfWork {
    /**
     * Logger instance for logging events and errors.
     */
    private static final Logger log = LoggerFactory.getLogger(ProofOfWork.class);
    
    // Cuckoo Cycle parameters

    /**
     * Current difficulty level represented by the number of edge bits.
     * Volatile to ensure visibility across threads.
     */
    private volatile int edgeBits;  // Current difficulty (default 16)

    /**
     * Number of nodes in the Cuckoo graph, calculated as 2^edgeBits.
     * Volatile to ensure visibility across threads.
     */
    private volatile int numNodes;  // 2^edgeBits

    /**
     * Number of edges in the Cuckoo graph, equal to the number of nodes.
     * Volatile to ensure visibility across threads.
     */
    private volatile int numEdges;  // Same as numNodes

    /**
     * Minimum allowed value for edgeBits to prevent the graph from being too small.
     */
    private static final int MIN_EDGE_BITS = 6;

    /**
     * Maximum allowed value for edgeBits to prevent the graph from being too large.
     */
    private static final int MAX_EDGE_BITS = 12;

    /**
     * Desired length of the cycle to be found in the Cuckoo graph.
     */
    private static final int CYCLE_LENGTH = 8;

    /**
     * Maximum number of solutions to store or consider.
     */
    private static final int MAX_SOLUTIONS = 4;
    
    // Difficulty adjustment parameters

    /**
     * Tolerance factor for difficulty adjustment, representing 20% difference.
     */
    private static final double DIFFICULTY_TOLERANCE = 0.2; // 20% difference tolerance

    /**
     * Concurrent map storing peer identifiers and their reported difficulties.
     */
    private final Map<byte[], Integer> peerDifficulties = new ConcurrentHashMap<>();

    /**
     * Queue storing timestamps of recent successful proof solves.
     */
    private final Queue<Long> solveTimestamps = new ConcurrentLinkedQueue<>();

    /**
     * Target time (in milliseconds) expected to solve a proof of work.
     */
    private static final int TARGET_SOLVE_TIME_MS = 5000; // 5 seconds

    /**
     * Number of recent solve timestamps to keep for calculating average solve time.
     */
    private static final int SOLVE_HISTORY_SIZE = 10;

    /**
     * Minimum number of peer difficulty samples required before considering peer data.
     */
    private static final int MIN_PEER_SAMPLES = 3;
    
    // Node identity

    /**
     * Unique identifier for the node, used in proof generation.
     */
    private final byte[] nodeId;

    /**
     * Current proof of work generated by this node.
     * Volatile to ensure visibility across threads.
     */
    private volatile byte[] currentProof;

    /**
     * Timestamp indicating when the current proof was generated.
     * Volatile to ensure visibility across threads.
     */
    private volatile long timestamp;
    
    /**
     * Represents an edge in the Cuckoo graph, connecting two nodes.
     */
    private static class Edge {
        /**
         * The first node in the edge.
         */
        int u, v;

        /**
         * Constructs an Edge connecting nodes u and v.
         * 
         * @param u the first node
         * @param v the second node
         */
        Edge(int u, int v) {
            this.u = u;
            this.v = v;
        }
    }

    /**
     * Constructs a ProofOfWork instance with the specified node identifier.
     * Initializes difficulty parameters and timestamps.
     * 
     * @param nodeId the unique identifier for this node
     * @throws IllegalArgumentException if nodeId is null
     */
    public ProofOfWork(byte[] nodeId) {
        if (nodeId == null) {
            throw new IllegalArgumentException("nodeId cannot be null");
        }
        this.nodeId = nodeId;
        this.timestamp = System.currentTimeMillis();

        // Start with minimum difficulty
        this.edgeBits = MIN_EDGE_BITS;  // Start with minimum difficulty (8)
        this.numNodes = 1 << edgeBits;  // 256 nodes
        this.numEdges = numNodes;

        log.debug("Initialized ProofOfWork with edgeBits={}, numNodes={}", edgeBits, numNodes);
    }


    /**
     * Records the difficulty level reported by a peer and adjusts local difficulty accordingly.
     * 
     * @param peerId the unique identifier of the peer
     * @param peerEdgeBits the difficulty level reported by the peer
     */
    public void recordPeerDifficulty(byte[] peerId, int peerEdgeBits) {
        if (peerEdgeBits >= MIN_EDGE_BITS && peerEdgeBits <= MAX_EDGE_BITS) {
            peerDifficulties.put(peerId, peerEdgeBits);
            adjustLocalDifficulty();
        }
    }

    /**
     * Records the current time as a successful proof solve timestamp.
     * Maintains a fixed-size history of recent solve times.
     */
    private void recordSolveTime() {
        solveTimestamps.offer(System.currentTimeMillis());
        while (solveTimestamps.size() > SOLVE_HISTORY_SIZE) {
            solveTimestamps.poll();
        }
    }

    /**
     * Adjusts the local difficulty based on recent solve times and peer-reported difficulties.
     * Ensures that the proof of work difficulty remains balanced with network conditions.
     */
    private void adjustLocalDifficulty() {
        // First check if we have enough local timing data
        if (solveTimestamps.size() >= 2) {
            Long[] timestamps = solveTimestamps.toArray(Long[]::new);
            double avgSolveTime = 0;
            for (int i = 1; i < timestamps.length; i++) {
                avgSolveTime += timestamps[i] - timestamps[i-1];
            }
            avgSolveTime /= (timestamps.length - 1);

            // Adjust based on our solve time vs target
            if (avgSolveTime < TARGET_SOLVE_TIME_MS * (1 - DIFFICULTY_TOLERANCE)) {
                // Too easy, increase difficulty if below peer average
                if (edgeBits < getAveragePeerDifficulty()) {
                    updateDifficulty(edgeBits + 1);
                }
            } else if (avgSolveTime > TARGET_SOLVE_TIME_MS * (1 + DIFFICULTY_TOLERANCE)) {
                // Too hard, decrease difficulty if above peer minimum
                if (edgeBits > getMinPeerDifficulty()) {
                    updateDifficulty(edgeBits - 1);
                }
            }
        }

        // Consider peer difficulties if we have enough samples
        if (peerDifficulties.size() >= MIN_PEER_SAMPLES) {
            int avgPeerDifficulty = getAveragePeerDifficulty();
            
            // Gradually move towards peer average if significantly different
            if (Math.abs(edgeBits - avgPeerDifficulty) > 2) {
                updateDifficulty(edgeBits + (avgPeerDifficulty > edgeBits ? 1 : -1));
            }
        }
    }

    /**
     * Updates the difficulty level to a new value, ensuring it stays within defined bounds.
     * Recalculates dependent parameters such as number of nodes and edges.
     * 
     * @param newEdgeBits the new difficulty level
     */
    private void updateDifficulty(int newEdgeBits) {
        edgeBits = Math.max(MIN_EDGE_BITS, Math.min(MAX_EDGE_BITS, newEdgeBits));
        numNodes = 1 << edgeBits;
        numEdges = numNodes;
        log.debug("Adjusted difficulty to edgeBits={} (peer avg={})", 
                 edgeBits, getAveragePeerDifficulty());
    }

    /**
     * Calculates the average difficulty reported by peers.
     * 
     * @return the average peer difficulty, or the current edgeBits if no peers are reported
     */
    private int getAveragePeerDifficulty() {
        return (int) peerDifficulties.values().stream()
            .mapToInt(Integer::intValue)
            .average()
            .orElse(edgeBits);
    }

    /**
     * Retrieves the minimum difficulty reported by any peer.
     * 
     * @return the minimum peer difficulty, or MIN_EDGE_BITS if no peers are reported
     */
    private int getMinPeerDifficulty() {
        return peerDifficulties.values().stream()
            .mapToInt(Integer::intValue)
            .min()
            .orElse(MIN_EDGE_BITS);
    }

    /**
     * Attempts to solve the proof of work by finding a valid cycle in the generated graph.
     * Upon successful solution, updates the current proof and records the solve time.
     * Adjusts difficulty based on the outcome.
     * 
     * @return {@code true} if a valid proof was found, {@code false} otherwise
     */
    public boolean solve() {
        long startTime = System.currentTimeMillis();
        int maxAttempts = 5;
        int currentDifficulty = MIN_EDGE_BITS;

        while (currentDifficulty <= MAX_EDGE_BITS) {
            // Set current difficulty
            this.edgeBits = currentDifficulty;
            this.numNodes = 1 << edgeBits;
            this.numEdges = numNodes;

            for (int attempt = 1; attempt <= maxAttempts; attempt++) {
                try {
                    log.debug("Starting proof of work solve attempt {}/{} with edgeBits={}, numNodes={}", 
                             attempt, maxAttempts, edgeBits, numNodes);

                    byte[] nonce = new byte[32];
                    new SecureRandom().nextBytes(nonce);
                    timestamp = System.currentTimeMillis();

                    Edge[] edges = new Edge[numEdges];
                    log.debug("Populating edges...");
                    populateEdges(edges, nonce);

                    log.debug("Finding cycle...");
                    int[] cycle = findCycle(edges);

                    if (cycle != null) {
                        log.debug("Found cycle at difficulty {} on attempt {}", currentDifficulty, attempt);
                        ByteBuffer proofBuffer = ByteBuffer.allocate(nonce.length + 4 + cycle.length * 4);
                        proofBuffer.put(nonce);
                        proofBuffer.putInt(edgeBits);
                        for (int edge : cycle) {
                            proofBuffer.putInt(edge);
                        }
                        currentProof = proofBuffer.array();
                        return true;
                    }

                    log.debug("Failed to find cycle on attempt {} at difficulty {}", 
                        attempt, currentDifficulty);

                    if (attempt < maxAttempts) {
                        Thread.sleep(100); // Brief pause between attempts
                    }
                } catch (Exception e) {
                    log.error("Error solving proof of work: {} - {}", 
                        e.getClass().getName(), e.getMessage());
                    break;
                }
            }

            // Increase difficulty if all attempts failed
            currentDifficulty++;
        }

        long duration = System.currentTimeMillis() - startTime;
        log.debug("All solve attempts failed after {}ms", duration);
        return false;
    }

    /**
     * Populates the edges array by hashing the node identifier and nonce,
     * then mapping hashes to node indices in the Cuckoo graph.
     * 
     * @param edges the array to populate with edges
     * @param nonce the nonce used in hashing
     * @throws NoSuchAlgorithmException if SHA-256 algorithm is not available
     */
    private void populateEdges(Edge[] edges, byte[] nonce) throws NoSuchAlgorithmException {
        MessageDigest digest = MessageDigest.getInstance("SHA-256");
        
        ByteBuffer data = ByteBuffer.allocate(nodeId.length + nonce.length);
        data.put(nodeId).put(nonce).flip();
        
        for (int i = 0; i < numEdges; i++) {
            digest.update(data.array());
            digest.update(ByteBuffer.allocate(4).putInt(i).array());
            byte[] hash = digest.digest();
            
            int u = Math.abs(ByteBuffer.wrap(hash, 0, 4).getInt()) % numNodes;
            int v = Math.abs(ByteBuffer.wrap(hash, 4, 4).getInt()) % numNodes;
            
            edges[i] = new Edge(u, v);
        }
    }

    /**
     * Attempts to find a cycle of a specified length within the given edges of the Cuckoo graph.
     * Uses depth-first search to locate a valid cycle.
     * 
     * @param edges the array of edges representing the Cuckoo graph
     * @return an array of node indices representing the cycle, or {@code null} if no cycle is found
     */
    private int[] findCycle(Edge[] edges) {
        // Pre-allocate fixed-size arrays instead of using dynamic lists
        int[] visited = new int[numNodes];  // 0=unvisited, 1=visiting, 2=visited
        int[] parent = new int[numNodes];
        int[] edgeToParent = new int[numNodes];
        int[] stack = new int[numNodes];  // Stack for DFS
        int stackSize = 0;

        // Try to find cycle starting from each vertex
        for (int start = 0; start < numNodes; start++) {
            if (visited[start] != 0) continue;

            // Initialize DFS from this vertex
            Arrays.fill(visited, 0);
            Arrays.fill(parent, -1);
            Arrays.fill(edgeToParent, -1);
            stackSize = 0;

            // Start DFS
            stack[stackSize++] = start;
            visited[start] = 1;  // Mark as being visited

            while (stackSize > 0) {
                int current = stack[stackSize - 1];  // Peek at top of stack

                // Find unvisited neighbor
                boolean foundNeighbor = false;
                for (int edgeIdx = 0; edgeIdx < edges.length; edgeIdx++) {
                    Edge edge = edges[edgeIdx];
                    int neighbor = -1;

                    if (edge.u == current) {
                        neighbor = edge.v;
                    } else if (edge.v == current) {
                        neighbor = edge.u;
                    }

                    if (neighbor != -1) {
                        if (visited[neighbor] == 0) {
                            // Found unvisited neighbor
                            parent[neighbor] = current;
                            edgeToParent[neighbor] = edgeIdx;
                            visited[neighbor] = 1;
                            stack[stackSize++] = neighbor;
                            foundNeighbor = true;
                            break;
                        } else if (visited[neighbor] == 1 && neighbor != parent[current]) {
                            // Found cycle - reconstruct it
                            int cycleLength = 0;
                            int[] cycle = new int[CYCLE_LENGTH - 1];

                            // Back from current to neighbor
                            int v = current;
                            while (v != neighbor && cycleLength < CYCLE_LENGTH - 1) {
                                if (edgeToParent[v] != -1) {
                                    cycle[cycleLength++] = edgeToParent[v];
                                }
                                v = parent[v];
                            }

                            if (cycleLength == CYCLE_LENGTH - 1) {
                                return cycle;
                            }
                        }
                    }
                }

                if (!foundNeighbor) {
                    // No more neighbors, backtrack
                    visited[current] = 2;  // Mark as fully visited
                    stackSize--;
                }
            }
        }
        return null;
    }
    


    /**
     * Verifies the validity of a provided proof of work.
     * Ensures that the proof contains a valid cycle within the Cuckoo graph
     * generated using the included nonce and difficulty parameters.
     * 
     * @param proofData the byte array representing the proof to verify
     * @param proofTimestamp the timestamp when the proof was generated
     * @return {@code true} if the proof is valid, {@code false} otherwise
     */
    public boolean verify(byte[] proofData, long proofTimestamp) {
           try {
               if (proofData == null || proofData.length < 36) {
                   log.debug("Invalid proof data: null or too short");
                   return false;
               }

               ByteBuffer buffer = ByteBuffer.wrap(proofData);

               // Read node ID (32 bytes)
               byte[] nodeId = new byte[32];
               buffer.get(nodeId);

               // Read edge bits value (4 bytes) - network byte order
               buffer.order(ByteOrder.BIG_ENDIAN);
               int peerDifficulty = buffer.getInt();

               // Early stage - accept if within ±1 of our difficulty
               double lowerBound = edgeBits - 1;
               double upperBound = edgeBits + 1;

               // Check if peer's difficulty is within acceptable range
               if (peerDifficulty < Math.max(MIN_EDGE_BITS, lowerBound) || 
                   peerDifficulty > Math.min(MAX_EDGE_BITS, upperBound)) {
                   log.debug("Peer difficulty {} outside acceptable range [{}, {}]", 
                       peerDifficulty, lowerBound, upperBound);
                   return false;
               }

               // Verify the cycle edges
               int numEdges_ = (1 << peerDifficulty);  // 2^difficulty
               int cycleLength = CYCLE_LENGTH - 1;

               // Each edge index is a 4-byte integer
               while (buffer.remaining() >= 4 && cycleLength > 0) {
                   int edge = buffer.getInt();
                   if (edge >= numEdges_) {
                       log.debug("Invalid edge index: {} >= {}", edge, numEdges_);
                       return false;
                   }
                   cycleLength--;
               }

               if (cycleLength != 0) {
                   log.debug("Invalid cycle length");
                   return false;
               }

               // Record peer difficulty for future adjustments
               recordPeerDifficulty(nodeId, peerDifficulty);
               log.debug("Proof verification successful at difficulty {}", peerDifficulty);
               return true;

           } catch (Exception e) {
               log.error("Error verifying proof of work: {}", e.getMessage());
               return false;
           }
       }

 

    /**
     * Retrieves the current proof of work generated by this node.
     * 
     * @return a byte array representing the current proof, or {@code null} if no proof has been generated
     */
    public byte[] getCurrentProof() {
        return currentProof;
    }

    /**
     * Retrieves the timestamp indicating when the current proof was generated.
     * 
     * @return the timestamp in milliseconds since the epoch
     */
    public long getTimestamp() {
        return timestamp;
    }

    /**
     * Retrieves the current difficulty level represented by edgeBits.
     * 
     * @return the current difficulty level
     */
    public int getCurrentDifficulty() {
        return edgeBits;
    }
}
