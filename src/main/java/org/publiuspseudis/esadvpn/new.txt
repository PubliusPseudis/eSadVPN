
=============================================

/*
 * Copyright (C) 2024 Publius Pseudis
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.publiuspseudis.esadvpn.app;

import org.publiuspseudis.esadvpn.proxy.SocksProxy;
import org.publiuspseudis.esadvpn.network.P2PNetwork;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * <p>
 * The {@code Main} class serves as the entry point for the Publius Pseudis Everyday Swarm 
 * Assisted Decentralized VPN (ESADVPN) application. It initializes and manages the lifecycle of 
 * VPN nodes within a peer-to-peer (P2P) network and sets up a SOCKS proxy to facilitate 
 * secure internet access through the VPN.
 * </p>
 * 
 * <p>
 * <strong>Program Description:</strong>
 * The ESADVPN application allows users to create and join a decentralized VPN network. 
 * Users can operate in two primary modes:
 * </p>
 * 
 * <ul>
 *   <li><strong>P2P Mode:</strong> Initializes the first node (initiator) in the VPN network, 
 *       listening on a specified port and setting up a SOCKS proxy on the subsequent port.</li>
 *   <li><strong>Connect Mode:</strong> Joins an existing VPN network by connecting to a specified 
 *       peer address and port, and sets up a SOCKS proxy on the subsequent port.</li>
 * </ul>
 * 
 * <p>
 * The application ensures secure communication between peers using underlying P2P network 
 * protocols and provides a SOCKS proxy to route internet traffic securely through the VPN.
 * </p>
 * 
 * <p>
 * <strong>Example Usage:</strong>
 * </p>
 * <pre>{@code
 * // Start the first VPN node (initiator) on port 8942
 * java -jar esadvpn.jar p2p 8942
 * // This will start the VPN service on port 8942 and the SOCKS proxy on port 8943
 * 
 * // Connect a second VPN node to the existing network via localhost on port 8942
 * java -jar esadvpn.jar connect 8944 localhost 8942
 * // This will start the VPN service on port 8944 and the SOCKS proxy on port 8945
 * }</pre>
 * 
 * <p>
 * <strong>Thread Safety:</strong>
 * </p>
 * <p>
 * The {@code Main} class is designed to be thread-safe. It utilizes concurrent data structures 
 * and atomic variables to manage network connections and ensure consistent behavior across 
 * multiple threads.
 * </p>
 * 
 * <p>
 * <strong>Dependencies:</strong>
 * </p>
 * <ul>
 *   <li>{@link P2PNetwork}: Manages peer-to-peer network communications and VPN connections.</li>
 *   <li>{@link SocksProxy}: Implements a SOCKS proxy server to route internet traffic through the VPN.</li>
 *   <li>SLF4J Logging Framework: Used for logging informational, debug, and error messages.</li>
 * </ul>
 * 
 * @author 
 * Publius Pseudis
 */
public class Main {
    
    /**
     * Logger instance from SLF4J for logging informational, debug, and error messages.
     * Utilized throughout the class to trace execution flow and record significant events.
     */
    private static final Logger log = LoggerFactory.getLogger(Main.class);
    /**
     * DISALLOWED. STATIC ONLY.
     *
     * <p>
     * Prevents instantiation of the {@code Main} class.
     * </p>
     */
    private Main() {
        throw new UnsupportedOperationException("Main class cannot be instantiated.");
    }

    /**
     * The entry point of the ESADVPN application.
     * 
     * <p>
     * Parses command-line arguments to determine the operating mode (p2p or connect), 
     * initializes the P2P network, and sets up the SOCKS proxy accordingly.
     * </p>
     * 
     * <p>
     * <strong>Modes:</strong></p>
     * <ul>
     *   <li><strong>p2p:</strong> Starts the first node (initiator) in the VPN network.</li>
     *   <li><strong>connect:</strong> Connects to an existing VPN network by joining a specified peer.</li>
     * </ul>
     * 
     * 
     * @param args Command-line arguments specifying the mode and associated parameters.
     *             <ul>
     *               <li>For <strong>p2p</strong> mode: <code>p2p [port]</code></li>
     *               <li>For <strong>connect</strong> mode: <code>connect [local-port] [peer-host] [peer-port]</code></li>
     *             </ul>
     */
        public static void main(String[] args) {
        try {
            if (args.length < 2) {
                printUsage();
                return;
            }

            String mode = args[0].toLowerCase();
            int port = Integer.parseInt(args[1]);

            switch (mode) {
                case "p2p" -> {
                    log.info("Starting P2P VPN node on port {}", port);
                    P2PNetwork network = new P2PNetwork(port, true, null);  // true = initiator, don't need peer address since we would be the initator.
                    network.start();
                }
                case "connect" -> {
                    if (args.length < 4) {
                        System.out.println("Error: peer address and port required for connect mode");
                        System.out.println("Usage: java -jar esadvpn.jar connect [local-port] [peer-host] [peer-port]");
                        System.exit(1);
                    }
                    String peerHost = args[2];
                    int peerPort = Integer.parseInt(args[3]);
                    log.info("Connecting to P2P network via {}:{}", peerHost, peerPort);
                    String peerAddress = peerHost + ":" + peerPort;
                    P2PNetwork network = new P2PNetwork(port, false, peerAddress);  // Pass peer address
                    
                    // Start the network and ensure SOCKS proxy is started
                    try {
                        network.start();
                        log.info("P2P network and SOCKS proxy started successfully");
                    } catch (Exception e) {
                        log.error("Failed to start network or SOCKS proxy: {}", e.getMessage());
                        throw e;
                    }
                }
                default -> {
                    System.out.println("Invalid mode. Use 'p2p' or 'connect'");
                    System.exit(1);
                }
            }

            // Keep main thread alive
            Thread.currentThread().join();

        } catch (Exception e) {
            log.error("Fatal error", e);
            System.exit(1);
        }
    }


    /**
     * Prints the usage instructions for the ESADVPN application.
     * 
     * <p>
     * Provides guidance on how to execute the program in different modes, along with examples.
     * </p>
     */
    private static void printUsage() {
        System.out.println("Usage: java -jar esadvpn.jar [mode] [options]");
        System.out.println("Modes:");
        System.out.println("  p2p [port]");
        System.out.println("    Start first node (initiator)");
        System.out.println("    - VPN service will listen on [port]");
        System.out.println("    - SOCKS proxy will start on [port+1]");
        System.out.println();
        System.out.println("  connect [local-port] [peer-host] [peer-port]");
        System.out.println("    Connect to existing network");
        System.out.println("    - VPN service will listen on [local-port]");
        System.out.println("    - SOCKS proxy will start on [local-port+1]");
        System.out.println();
        System.out.println("Examples:");
        System.out.println("  # Start first node:");
        System.out.println("  java -jar esadvpn.jar p2p 8942");
        System.out.println("  # VPN on 8942, SOCKS proxy on 8943");
        System.out.println();
        System.out.println("  # Connect second node:");
        System.out.println("  java -jar esadvpn.jar connect 8944 localhost 8942");
        System.out.println("  # VPN on 8944, SOCKS proxy on 8945");
    }
}

=============================================

package org.publiuspseudis.esadvpn.protocol;


import org.publiuspseudis.esadvpn.protocol.GossipMessage;

/*
 * Copyright (C) 2024 Publius Pseudis
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */


/**
 * <p>
 * The {@code MessageHandler} interface defines a generic handler for asynchronous message processing
 * within the VPN framework. Implementations of this interface are responsible for handling various
 * types of messages, including gossip messages, proofs of work, and peer information updates.
 * </p>
 *
 * <p>
 * This interface facilitates the decoupling of message reception from message processing,
 * allowing for flexible and scalable handling of network communication events. By implementing
 * this interface, developers can define custom behaviors for different message types, enhancing
 * the responsiveness and adaptability of the VPN application.
 * </p>
 *
 * <p>
 * <strong>Example Implementation:</strong>
 * </p>
 * <pre>{@code
 * public class MyMessageHandler implements MessageHandler {
 *     
 *     @Override
 *     public void handleGossip(GossipMessage message) {
 *         // Process the received gossip message
 *         System.out.println("Received gossip message: " + message);
 *         // Additional processing logic...
 *     }
 * 
 *     @Override
 *     public void handleProof(byte[] proof, long timestamp) {
 *         // Validate and process the proof of work
 *         System.out.println("Received proof of work at timestamp: " + timestamp);
 *         // Additional validation and processing logic...
 *     }
 * 
 *     @Override
 *     public void handlePeerInfo(byte[] nodeId) {
 *         // Update peer information based on the received node ID
 *         System.out.println("Received peer info for node ID: " + Arrays.toString(nodeId));
 *         // Additional update logic...
 *     }
 * }
 * }</pre>
 * 
 * <p>
 * <strong>Usage:</strong>
 * </p>
 * <pre>{@code
 * // Instantiate the message handler
 * MessageHandler handler = new MyMessageHandler();
 * 
 * // Create a gossip message (assuming GossipMessage is properly defined)
 * GossipMessage gossip = new GossipMessage(/* parameters *);
 * 
 * // Handle the gossip message
 * handler.handleGossip(gossip);
 * 
 * // Handle a proof of work
 * byte[] proof = {/* proof data *};
 * long timestamp = System.currentTimeMillis();
 * handler.handleProof(proof, timestamp);
 * 
 * // Handle peer information
 * byte[] nodeId = {/* node ID data *};
 * handler.handlePeerInfo(nodeId);
 * }</pre>
 * 
 * @author
 * Publius Pseudis
 * 
 * @version 1.0
 * @since 2024-01-01
 */
public interface MessageHandler {
    
    /**
     * Handles a received gossip message, processing peer and routing information.
     *
     * @param message The {@link GossipMessage} instance containing gossip data.
     */
    void handleGossip(GossipMessage message);
    
    /**
     * Handles a received proof of work, validating the authenticity of a node.
     *
     * @param proof     A byte array representing the proof of work.
     * @param timestamp The timestamp indicating when the proof was generated.
     */
    void handleProof(byte[] proof, long timestamp);
    
    /**
     * Handles received peer information, updating the network state with the new peer.
     *
     * @param nodeId A byte array representing the unique identifier of the peer.
     */
    void handlePeerInfo(byte[] nodeId);
}

=============================================

package org.publiuspseudis.esadvpn.protocol;

/*
 * Copyright (C) 2024 Publius Pseudis
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */


import java.io.IOException;
import org.publiuspseudis.esadvpn.core.ConnectionPhase;

/**
 * <p>
 * The {@code NetworkProtocolHandler} interface defines a contract for handling network protocol messages
 * within the VPN framework. Implementations of this interface are responsible for processing incoming
 * messages, sending outgoing messages, and managing the current connection phase.
 * </p>
 *
 * <p>
 * This interface facilitates asynchronous and synchronous communication between different components
 * of the VPN application, ensuring that messages are correctly interpreted and dispatched based on their
 * type and content. By implementing this interface, developers can define custom behaviors for various
 * network protocols, enhancing the flexibility and scalability of the VPN system.
 * </p>
 *
 * <p>
 * <strong>Example Implementation:</strong>
 * </p>
 * <pre>{@code
 * public class MyNetworkProtocolHandler implements NetworkProtocolHandler {
 *     
 *     private ConnectionPhase currentPhase;
 *     
 *     @Override
 *     public void handleMessage(byte type, byte[] data) throws IOException {
 *         switch (type) {
 *             case MESSAGE_TYPE_GOSSIP:
 *                 // Process gossip message
 *                 GossipMessage gossip = GossipMessage.deserialize(data);
 *                 processGossip(gossip);
 *                 break;
 *             
 *             case MESSAGE_TYPE_PROOF:
 *                 // Process proof of work
 *                 byte[] proof = extractProof(data);
 *                 long timestamp = extractTimestamp(data);
 *                 verifyProof(proof, timestamp);
 *                 break;
 *             
 *             case MESSAGE_TYPE_PEER_INFO:
 *                 // Process peer information
 *                 byte[] nodeId = extractNodeId(data);
 *                 updatePeerInfo(nodeId);
 *                 break;
 *             
 *             default:
 *                 // Handle unknown message type
 *                 log.warn("Received unknown message type: {}", type);
 *         }
 *     }
 *     
 *     @Override
 *     public void sendMessage(byte type, byte[] data) throws IOException {
 *         // Serialize and send the message over the network
 *         byte[] serializedMessage = serializeMessage(type, data);
 *         networkConnection.send(serializedMessage);
 *     }
 *     
 *     @Override
 *     public ConnectionPhase getPhase() {
 *         return currentPhase;
 *     }
 *     
 *     // Additional helper methods...
 * }
 * }</pre>
 * 
 * <p>
 * <strong>Usage:</strong>
 * </p>
 * <pre>{@code
 * // Instantiate the network protocol handler
 * NetworkProtocolHandler protocolHandler = new MyNetworkProtocolHandler();
 * 
 * // Handling an incoming message
 * byte incomingType = receivedData[0];
 * byte[] incomingData = Arrays.copyOfRange(receivedData, 1, receivedData.length);
 * protocolHandler.handleMessage(incomingType, incomingData);
 * 
 * // Sending a message
 * byte messageType = NetworkProtocolHandler.MESSAGE_TYPE_GOSSIP;
 * byte[] messageData = GossipMessage.createGossipData();
 * protocolHandler.sendMessage(messageType, messageData);
 * 
 * // Retrieving the current connection phase
 * ConnectionPhase phase = protocolHandler.getPhase();
 * }</pre>
 * 
 * @author
 * Publius Pseudis
 * 
 * @version 1.0
 * @since 2024-01-01
 */
public interface NetworkProtocolHandler {
    
    /**
     * Handles an incoming network protocol message based on its type and data.
     *
     * <p>
     * This method is invoked when a new message is received from the network. Implementations should
     * parse the message based on its type and perform the necessary actions, such as updating internal
     * state, responding to requests, or triggering other processes within the VPN framework.
     * </p>
     *
     * @param type The type identifier of the incoming message. This could correspond to different
     *             protocols or message categories within the VPN system.
     * @param data The raw data payload of the message as a byte array. The structure of this data
     *             depends on the message type and should be parsed accordingly.
     * @throws IOException If an I/O error occurs during message processing, such as issues with
     *                     deserialization or network communication.
     *
     * @see #sendMessage(byte, byte[])
     */
    void handleMessage(byte type, byte[] data) throws IOException;
    
    /**
     * Sends a network protocol message with the specified type and data.
     *
     * <p>
     * This method is used to transmit messages to other peers or components within the VPN framework.
     * Implementations should serialize the data appropriately and ensure that it is sent over the
     * correct communication channel or protocol.
     * </p>
     *
     * @param type The type identifier of the message to be sent. This could correspond to different
     *             protocols or message categories within the VPN system.
     * @param data The raw data payload of the message as a byte array. The structure of this data
     *             depends on the message type and should be serialized accordingly.
     * @throws IOException If an I/O error occurs during message transmission, such as issues with
     *                     serialization or network communication.
     *
     * @see #handleMessage(byte, byte[])
     */
    void sendMessage(byte type, byte[] data) throws IOException;
    
    /**
     * Retrieves the current phase of the network connection.
     *
     * <p>
     * The connection phase indicates the current state of the network protocol handler, such as
     * whether the connection is initializing, established, or terminating. This information can be
     * used to make decisions about sending or processing messages based on the connection state.
     * </p>
     *
     * @return The current {@link ConnectionPhase} of the network connection.
     *
     * @see ConnectionPhase
     */
    ConnectionPhase getPhase();
}

=============================================

package org.publiuspseudis.esadvpn.protocol;

/*
 * Copyright (C) 2024 Publius Pseudis
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */


import org.publiuspseudis.esadvpn.routing.RouteInfo;
import org.publiuspseudis.esadvpn.core.VPNConnection;
import java.io.*;
import java.nio.ByteBuffer;
import java.util.*;
import org.publiuspseudis.esadvpn.network.Peer;

/**
 * <p>
 * The {@code GossipMessage} class represents a message used within a gossip protocol
 * for peer discovery and network state synchronization with swarm intelligence-based
 * routing capabilities.
 * </p>
 *
 * <p>
 * This class encapsulates various components essential for maintaining an updated and
 * synchronized view of the network, including the node's identity, proof of work,
 * known peers, and routing information. It supports serialization and deserialization
 * for network transmission and provides mechanisms for handling different types of
 * gossip messages through a handler interface.
 * </p>
 *
 * <p>
 * <strong>Message Types:</strong></p>
 * <ul>
 *   <li>{@link #GOSSIP_TYPE_FULL}: Full peer list update</li>
 *   <li>{@link #GOSSIP_TYPE_DELTA}: Only changes since last gossip</li>
 *   <li>{@link #GOSSIP_TYPE_PING}: Keepalive with minimal info</li>
 * </ul>
 * 
 * 
 * <p>
 * <strong>Example Usage:</strong>
 * </p>
 * <pre>{@code
 * // Creating a list of peers
 * List<Peer> peers = Arrays.asList(
 *     new Peer("192.168.1.2", 8080, nodeId1),
 *     new Peer("192.168.1.3", 8080, nodeId2)
 * );
 * 
 * // Creating a map of routes
 * Map<String, RouteInfo> routes = new HashMap<>();
 * routes.put("192.168.1.4", new RouteInfo("192.168.1.4", "192.168.1.2", 2));
 * 
 * // Creating a GossipMessage instance
 * GossipMessage message = new GossipMessage(
 *     myNodeId,
 *     myProofOfWork,
 *     System.currentTimeMillis(),
 *     peers,
 *     routes
 * );
 * 
 * // Serializing the message for transmission
 * byte[] serializedData = message.serialize();
 * 
 * // Deserializing the message upon reception
 * GossipMessage receivedMessage = GossipMessage.deserialize(serializedData);
 * 
 * // Handling the received message
 * receivedMessage.setHandler(new GossipMessage.GossipHandler() {
 *     @Override
 *     public void handleGossip(GossipMessage message) {
 *         // Process the received gossip message
 *     }
 * 
 *     @Override
 *     public void handleProof(byte[] proof, long timestamp) {
 *         // Handle proof of work
 *     }
 * 
 *     @Override
 *     public void handlePeerInfo(byte[] nodeId) {
 *         // Handle peer information
 *     }
 * });
 * 
 * // Processing the message based on its type
 * receivedMessage.processMessage(messageType, data);
 * }</pre>
 * 
 * @author
 * Publius Pseudis
 * 
 * @version 1.0
 * @since 2024-01-01
 */
public class GossipMessage {
    /**
     * Unique identifier for the node sending the gossip message.
     * Represented as a byte array.
     */
    private final byte[] nodeId;

    /**
     * Proof of work associated with the node, used for validating the node's authenticity.
     * Represented as a byte array.
     */
    private final byte[] proofOfWork;

    /**
     * Timestamp indicating when the proof of work was generated.
     * Represented in milliseconds since the epoch.
     */
    private final long proofTimestamp;

    /**
     * List of known peers in the network.
     * Each peer is represented by a {@link PeerInfo} record.
     */
    private final List<PeerInfo> knownPeers;

    /**
     * Routing information mapping destinations to their respective route details.
     * The key is the destination's identifier (e.g., IP address), and the value is a {@link RouteInfo} object.
     */
    private final Map<String, RouteInfo> routes;

    /**
     * Message type indicating a full peer list update.
     */
    public static final byte GOSSIP_TYPE_FULL = 1;    // Full peer list update

    /**
     * Message type indicating only changes since the last gossip.
     */
    public static final byte GOSSIP_TYPE_DELTA = 2;   // Only changes since last gossip

    /**
     * Message type indicating a keepalive message with minimal information.
     */
    public static final byte GOSSIP_TYPE_PING = 3;    // Keepalive with minimal info

    /**
     * Interface for handling different types of gossip messages.
     */
    public interface GossipHandler {
        /**
         * Handles a full gossip message containing complete peer and routing information.
         *
         * @param message The {@link GossipMessage} instance containing the gossip data.
         */
        void handleGossip(GossipMessage message);

        /**
         * Handles a proof of work along with its associated timestamp.
         *
         * @param proof     The proof of work as a byte array.
         * @param timestamp The timestamp indicating when the proof was generated.
         */
        void handleProof(byte[] proof, long timestamp);

        /**
         * Handles information about a specific peer identified by its node ID.
         *
         * @param nodeId The unique identifier of the peer as a byte array.
         */
        void handlePeerInfo(byte[] nodeId);
    }

    /**
     * The handler responsible for processing incoming gossip messages.
     */
    private GossipHandler handler;

    /**
     * Sets the handler responsible for processing gossip messages.
     *
     * @param handler An implementation of the {@link GossipHandler} interface.
     */
    public void setHandler(GossipHandler handler) {
        this.handler = handler;
    }

    /**
     * Default constructor for creating an empty gossip message.
     * Primarily used for message handling and deserialization purposes.
     */
    public GossipMessage() {
        this.nodeId = new byte[0];
        this.proofOfWork = new byte[0];
        this.proofTimestamp = 0;
        this.knownPeers = new ArrayList<>();
        this.routes = new HashMap<>();
    }

    /**
     * Determines whether this {@code GossipMessage} is equal to another object.
     * Two gossip messages are considered equal if their node IDs, proofs of work,
     * and proof timestamps are identical.
     *
     * @param o The object to compare with.
     * @return {@code true} if the objects are equal; {@code false} otherwise.
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        GossipMessage that = (GossipMessage) o;
        return proofTimestamp == that.proofTimestamp &&
               Arrays.equals(nodeId, that.nodeId) &&
               Arrays.equals(proofOfWork, that.proofOfWork);
    }

    /**
     * Computes the hash code for this {@code GossipMessage}.
     * The hash code is based on the node ID, proof of work, and proof timestamp.
     *
     * @return The hash code value.
     */
    @Override
    public int hashCode() {
        int result = Arrays.hashCode(nodeId);
        result = 31 * result + Arrays.hashCode(proofOfWork);
        result = 31 * result + Long.hashCode(proofTimestamp);
        return result;
    }

    /**
     * Processes an incoming message based on its type.
     * Delegates handling to the appropriate method in the {@link GossipHandler}.
     *
     * @param msgType The type of the message, corresponding to one of the GOSSIP_TYPE_* constants.
     * @param data    The raw data of the message as a byte array.
     */
    public void processMessage(byte msgType, byte[] data) {
        if (handler == null) return;

        switch (msgType) {
            case VPNConnection.MSG_TYPE_GOSSIP -> {
                try {
                    GossipMessage gossip = GossipMessage.deserialize(data);
                    handler.handleGossip(gossip);
                } catch (IOException e) {
                    // Log error
                }
            }
            case VPNConnection.MSG_TYPE_PROOF -> {
                ByteBuffer buf = ByteBuffer.wrap(data);
                byte[] proof = new byte[data.length - 8];
                buf.get(proof);
                long timestamp = buf.getLong();
                handler.handleProof(proof, timestamp);
            }
            case VPNConnection.MSG_TYPE_PEER_INFO -> handler.handlePeerInfo(data);
            // You can add more cases here if new message types are introduced
        }
    }

    /**
     * Creates a new gossip message with peer and routing information.
     *
     * @param nodeId         The unique identifier of the node sending the message.
     * @param proofOfWork    The proof of work associated with the node.
     * @param proofTimestamp The timestamp indicating when the proof of work was generated.
     * @param peers          A list of {@link Peer} instances representing known peers.
     * @param routes         A map of routing information mapping destinations to {@link RouteInfo}.
     */
    public GossipMessage(byte[] nodeId, byte[] proofOfWork, long proofTimestamp, 
                        List<Peer> peers, Map<String, RouteInfo> routes) {
        this.nodeId = nodeId;
        this.proofOfWork = proofOfWork;
        this.proofTimestamp = proofTimestamp;
        this.knownPeers = new ArrayList<>();
        this.routes = new HashMap<>(routes);
        
        // Convert Peer objects to lightweight PeerInfo for transmission
        for (Peer peer : peers) {
            this.knownPeers.add(new PeerInfo(
                peer.getNodeId(),
                peer.getAddress(),
                peer.getPort(),
                peer.getProofOfWork(),
                peer.getLastProofTimestamp(),
                peer.getRouteScore()
            ));
        }
    }

    /**
     * Represents a peer's information for network transmission.
     *
     * <p>
     * This record holds essential details about a peer, including its node ID, address, port,
     * proof of work, proof timestamp, and route score. It is used to transmit lightweight peer
     * information within gossip messages.
     * </p>
    *
    * @param nodeId         The unique identifier of the peer node.
    * @param address        The IP address of the peer node.
    * @param port           The port number on which the peer node is listening.
    * @param proofOfWork    The proof of work data used for validating the peer.
    * @param proofTimestamp The timestamp when the proof of work was generated.
    * @param routeScore     The score indicating the quality of the route to this peer.
    */
    public record PeerInfo(
        byte[] nodeId,
        String address,
        int port,
        byte[] proofOfWork,
        long proofTimestamp,
        double routeScore
    ) {}

    /**
     * Serializes the gossip message for network transmission.
     *
     * @return A byte array representing the serialized gossip message.
     * @throws IOException If an I/O error occurs during serialization.
     */
    public byte[] serialize() throws IOException {
        try (ByteArrayOutputStream baos = new ByteArrayOutputStream();
             DataOutputStream dos = new DataOutputStream(baos)) {
            
            // Write message type and basic info
            dos.writeByte(GOSSIP_TYPE_FULL);
            dos.writeInt(nodeId.length);
            dos.write(nodeId);
            dos.writeInt(proofOfWork.length);
            dos.write(proofOfWork);
            dos.writeLong(proofTimestamp);
            
            // Write peer list
            dos.writeInt(knownPeers.size());
            for (PeerInfo peer : knownPeers) {
                dos.writeInt(peer.nodeId().length);
                dos.write(peer.nodeId());
                byte[] addressBytes = peer.address().getBytes();
                dos.writeInt(addressBytes.length);
                dos.write(addressBytes);
                dos.writeInt(peer.port());
                dos.writeInt(peer.proofOfWork().length);
                dos.write(peer.proofOfWork());
                dos.writeLong(peer.proofTimestamp());
                dos.writeDouble(peer.routeScore());
            }
            
            // Write routes information
            dos.writeInt(routes.size());
            for (Map.Entry<String, RouteInfo> entry : routes.entrySet()) {
                RouteInfo route = entry.getValue();
                dos.writeUTF(entry.getKey());          // Destination
                dos.writeUTF(route.getNextHop());           // Next hop
                dos.writeInt(route.getHopCount());          // Hop count
                dos.writeDouble(route.getPheromoneLevel()); // Pheromone level
                dos.writeDouble(route.getLatency());        // Latency
                dos.writeLong(route.getBandwidth());        // Bandwidth
            }
            
            return baos.toByteArray();
        }
    }

    /**
     * Deserializes a gossip message from network data.
     *
     * @param data The byte array containing the serialized gossip message.
     * @return A {@link GossipMessage} instance reconstructed from the provided data.
     * @throws IOException If an I/O error occurs during deserialization or if the message type is unsupported.
     */
    public static GossipMessage deserialize(byte[] data) throws IOException {
        try (ByteArrayInputStream bais = new ByteArrayInputStream(data);
             DataInputStream dis = new DataInputStream(bais)) {
            
            byte messageType = dis.readByte();
            if (messageType != GOSSIP_TYPE_FULL) {
                throw new IOException("Unsupported message type: " + messageType);
            }
            
            // Read basic info
            byte[] nodeId = new byte[dis.readInt()];
            dis.readFully(nodeId);
            byte[] proofOfWork = new byte[dis.readInt()];
            dis.readFully(proofOfWork);
            long proofTimestamp = dis.readLong();
            
            // Read peer list
            int peerCount = dis.readInt();
            List<Peer> peers = new ArrayList<>(peerCount);
            
            for (int i = 0; i < peerCount; i++) {
                byte[] peerNodeId = new byte[dis.readInt()];
                dis.readFully(peerNodeId);
                byte[] addressBytes = new byte[dis.readInt()];
                dis.readFully(addressBytes);
                String address = new String(addressBytes);
                int port = dis.readInt();
                byte[] peerProof = new byte[dis.readInt()];
                dis.readFully(peerProof);
                long peerProofTimestamp = dis.readLong();
                double routeScore = dis.readDouble();
                
                Peer peer = new Peer(address, port, peerNodeId);
                peer.setProofOfWork(peerProof);
                peer.setLastProofTimestamp(peerProofTimestamp);
                peer.setRouteScore(routeScore);
                peers.add(peer);
            }
            
            // Read routes
            int routeCount = dis.readInt();
            Map<String, RouteInfo> routes = new HashMap<>(routeCount);
            
            for (int i = 0; i < routeCount; i++) {
                String destination = dis.readUTF();
                String nextHop = dis.readUTF();
                int hopCount = dis.readInt();
                RouteInfo route = new RouteInfo(destination, nextHop, hopCount);
                route.setPheramoneLevel(dis.readDouble());
                route.setLatency(dis.readDouble());
                route.setBandwidth(dis.readLong());
                routes.put(destination, route);
            }
            
            return new GossipMessage(nodeId, proofOfWork, proofTimestamp, peers, routes);
        }
    }

    /**
     * Validates the gossip message format and basic constraints.
     *
     * @return {@code true} if the message is valid; {@code false} otherwise.
     */
    public boolean isValid() {
        if (nodeId == null || nodeId.length == 0 || 
            proofOfWork == null || proofOfWork.length == 0) {
            return false;
        }

        // Check timestamp is not in the future
        if (proofTimestamp > System.currentTimeMillis()) {
            return false;
        }

        // Validate each peer info
        for (PeerInfo peer : knownPeers) {
            if (peer.nodeId() == null || peer.nodeId().length == 0 ||
                peer.address() == null || peer.address().isEmpty() ||
                peer.port() <= 0 || peer.port() > 65535 ||
                peer.proofOfWork() == null || peer.proofOfWork().length == 0 ||
                peer.proofTimestamp() > System.currentTimeMillis()) {
                return false;
            }
        }

        // Validate routes
        for (RouteInfo route : routes.values()) {
            if (route.getDestination() == null || route.getDestination().isEmpty() ||
                route.getNextHop() == null || route.getNextHop().isEmpty() ||
                route.getHopCount() < 1 || route.getHopCount() > 255 ||
                route.getPheromoneLevel() < RouteInfo.getMIN_PHEROMONE() ||
                route.getLatency() < 0 || route.getBandwidth() < 0) {
                return false;
            }
        }

        return true;
    }

    /**
     * Retrieves the node ID of the sender.
     *
     * @return A byte array representing the node ID.
     */
    public byte[] getNodeId() { return nodeId; }

    /**
     * Retrieves the proof of work associated with the sender.
     *
     * @return A byte array representing the proof of work.
     */
    public byte[] getProofOfWork() { return proofOfWork; }

    /**
     * Retrieves the timestamp of when the proof of work was generated.
     *
     * @return The proof timestamp in milliseconds since the epoch.
     */
    public long getProofTimestamp() { return proofTimestamp; }

    /**
     * Retrieves the list of known peers.
     *
     * @return A list of {@link PeerInfo} records representing known peers.
     */
    public List<PeerInfo> getKnownPeers() { return knownPeers; }

    /**
     * Retrieves the routing information.
     *
     * @return A map mapping destinations to their respective {@link RouteInfo}.
     */
    public Map<String, RouteInfo> getRoutes() { return routes; }
}

=============================================

/*
 * Copyright (C) 2024 Publius Pseudis
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.publiuspseudis.esadvpn.core;

import java.io.IOException;
import java.net.DatagramSocket;
import java.net.DatagramPacket;
import java.net.InetAddress;
import java.net.SocketException;
import java.nio.ByteBuffer;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Queue;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import org.publiuspseudis.esadvpn.network.IPPacket;
import org.publiuspseudis.esadvpn.routing.SwarmRouter;
import org.publiuspseudis.esadvpn.network.UDPHandler;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * <p>
 * The {@code NetworkStack} class coordinates the userspace network stack components within the VPN framework.
 * It manages the flow of network packets between the virtual network interface and the underlying network protocols,
 * handling tasks such as packet processing, NAT translation, routing, and protocol-specific operations.
 * </p>
 *
 * <p>
 * This class integrates various components like {@link VirtualInterface}, {@link UDPHandler}, and {@link SwarmRouter}
 * to facilitate seamless communication within the VPN. It employs multi-threading to handle inbound and outbound
 * packet processing concurrently, ensuring efficient network traffic management.
 * </p>
 *
 * <p>
 * <strong>Key Functionalities:</strong></p>
 * <ul>
 *   <li>Reading packets from the virtual network interface.</li>
 *   <li>Handling inbound and outbound network traffic.</li>
 *   <li>Managing NAT translations for VPN traffic.</li>
 *   <li>Processing protocol-specific packets such as UDP and ICMP.</li>
 *   <li>Routing packets using the {@link SwarmRouter} component.</li>
 *   <li>Sending and receiving ping (ICMP) responses.</li>
 *   <li>Providing NAT and routing statistics.</li>
 * </ul>
 * 
 * 
 * <p>
 * <strong>Example Usage:</strong>
 * </p>
 * <pre>{@code
 * // Initialize SwarmRouter (assuming it's properly defined)
 * SwarmRouter router = new SwarmRouter();
 * 
 * // Initialize NetworkStack with address and router
 * NetworkStack networkStack = new NetworkStack("10.0.0.1", router);
 * 
 * // Sending a UDP packet
 * ByteBuffer payload = ByteBuffer.wrap("Hello, World!".getBytes());
 * networkStack.sendPacket(IPPacket.PROTO_UDP, InetAddress.getByName("8.8.8.8").hashCode(), payload);
 * 
 * // Injecting a received packet into the network stack
 * ByteBuffer receivedPacket = ByteBuffer.wrap(receivedData);
 * networkStack.injectPacket(receivedPacket);
 * 
 * // Closing the network stack when done
 * networkStack.close();
 * }</pre>
 * 
 * <p>
 * <strong>Thread Safety:</strong>  
 * The {@code NetworkStack} class is designed to be thread-safe, utilizing concurrent data structures and
 * synchronized operations where necessary. It employs an {@code ExecutorService} to manage separate threads
 * for inbound and outbound packet processing, ensuring that network operations do not block each other.
 * </p>
 * 
 * <p>
 * <strong>Dependencies:</strong>
 * </p>
 * <ul>
 *   <li>{@link VirtualInterface}: Manages the virtual network interface for reading and writing packets.</li>
 *   <li>{@link UDPHandler}: Handles UDP-specific packet processing and communication.</li>
 *   <li>{@link SwarmRouter}: Manages routing of packets within the VPN network.</li>
 *   <li>SLF4J Logging Framework: Utilized for logging events and debugging.</li>
 * </ul>
 * 
 * @author
 * Publius Pseudis
 * 
 * @version 1.0
 * @since 2024-01-01
 */
public class NetworkStack implements AutoCloseable {
    private static final int DEFAULT_RATE_LIMIT = 1000; // packets per second

    /**
     * A map of IP addresses to their corresponding rate limiters.
     * Used to prevent abuse by limiting the rate of packet handling
     * for each source IP.
     */
    private final Map<String, RateLimiter> rateLimiters = new ConcurrentHashMap<>();

    private static final int MAX_PACKET_SIZE = 65536;
    private static final int DEFAULT_BUFFER_SIZE = 1500;  // Standard MTU
    private static final int MAX_BUFFERS = 8192;         // Much larger pool

    /**
     * Access control list for managing outbound connections.
     * Ensures that outgoing traffic complies with configured rules
     * such as port restrictions and per-host connection limits.
     */
    private final OutboundACL outboundACL = new OutboundACL();

    /**
     * Logger instance for logging information, warnings, and errors.
     */
    private static final Logger log = LoggerFactory.getLogger(NetworkStack.class);
    
    /**
     * The virtual network interface used for reading and writing packets.
     */
    private final VirtualInterface virtualInterface;
    
    /**
     * The UDP handler responsible for processing UDP packets.
     */
    private final UDPHandler udpHandler;
    
    /**
     * Executor service managing the threads for inbound and outbound packet processing.
     */
    private final ExecutorService executor;
    
    /**
     * The router responsible for determining the next hop for packet routing.
     */
    private final SwarmRouter router;
    
    /**
     * The address associated with this network stack instance.
     */
    private final String address;  
    
    /**
     * Flag indicating whether the network stack is currently running.
     */
    private volatile boolean running;

    /**
     * Handler for processing ICMP (Internet Control Message Protocol) packets,
     * including echo requests and replies (commonly used in "ping").
     */
    private final ICMPHandler icmpHandler = new ICMPHandler();
    
    /**
     * Pool of reusable {@link ByteBuffer} instances to optimize memory usage and reduce
     * garbage collection overhead.
     */
    private final BufferPool bufferPool;
    
    private static final int MIN_PACKET_SIZE = 20;    // Minimum valid IP header
    
    /**
     * Constructs a new {@code NetworkStack} instance with the specified address and router.
     *
     * <p>
     * Initializes the virtual network interface, UDP handler, and router. It also sets up
     * an executor service with a fixed thread pool to handle inbound and outbound packet
     * processing concurrently. The network stack starts in the running state, and the
     * provided address is stored for reference.
     * </p>
     *
     * @param address The IP address associated with this network stack instance.
     * @param router  The {@link SwarmRouter} instance used for routing packets.
     */
    public NetworkStack(String address, SwarmRouter router) {
        this.virtualInterface = new VirtualInterface(address, 1500);
        this.udpHandler = new UDPHandler(this);
        this.router = router;
        this.bufferPool = new BufferPool(MAX_BUFFERS, DEFAULT_BUFFER_SIZE);
        this.executor = Executors.newFixedThreadPool(2);
        this.running = true;
        this.address = address;
        // Start packet processors
        executor.submit(this::processInbound);
        executor.submit(this::processOutbound);
    }
    
    /**
     * Retrieves the {@link RateLimiter} instance associated with a given IP address,
     * creating a new one if it does not already exist.
     *
     * @param address The IP address as a {@code String}.
     * @return The {@link RateLimiter} instance for the specified IP.
     */
    private RateLimiter getRateLimiter(String address) {
        return rateLimiters.computeIfAbsent(address, 
            addr -> new RateLimiter(DEFAULT_RATE_LIMIT));
    }

    /**
     * Retrieves the address associated with this network stack instance.
     *
     * @return A {@code String} representing the IP address.
     */
    public String getAddress() {
        return address;
    }
    
    /**
     * Processes inbound packets from the virtual network interface.
     *
     * <p>
     * This method continuously reads packets from the virtual interface and delegates
     * them to the {@link #handlePacket(ByteBuffer)} method for further processing.
     * It runs on a separate thread managed by the executor service.
     * </p>
     */
    private void processInbound() {
        int emptyCount = 0;
        while (running) {
            ByteBuffer buffer = null;
            try {
                buffer = virtualInterface.read();
                if (buffer != null) {
                    ByteBuffer workBuffer = bufferPool.acquire();
                    workBuffer.put(buffer);
                    workBuffer.flip();
                    handlePacket(workBuffer);
                    emptyCount = 0;
                } else {
                    emptyCount++;
                    // Exponential backoff with max delay of 100ms
                    long sleepTime = Math.min(1L * emptyCount, 100L);
                    Thread.sleep(sleepTime);
                }
            } catch (InterruptedException e) {
                log.warn("Buffer acquisition interrupted");
                Thread.currentThread().interrupt();
                break;
            } catch (Exception e) {
                log.error("Error processing inbound packet: {}", e.getMessage());
            } finally {
                if (buffer != null) {
                    bufferPool.release(buffer);
                }
            }
        }
    }
    
    /**
     * Processes outbound packets by retrieving them from the router and writing
     * them to the virtual network interface.
     *
     * <p>
     * This method continuously fetches packets from the {@link SwarmRouter}'s queue and
     * writes them to the virtual interface for transmission. It runs on a separate thread
     * managed by the executor service.
     * </p>
     */
    private void processOutbound() {
        int emptyCount = 0;
        while (running) {
            ByteBuffer buffer = null;
            try {
                // Get next packet from router with timeout
                ByteBuffer packet = router.getNextPacket();
                if (packet != null) {
                    buffer = bufferPool.acquire();
                    buffer.put(packet);
                    buffer.flip();
                    virtualInterface.write(buffer);
                    emptyCount = 0;
                } else {
                    emptyCount++;
                    // Exponential backoff with max delay of 100ms
                    long sleepTime = Math.min(1L * emptyCount, 100L);
                    Thread.sleep(sleepTime);
                }
            } catch (InterruptedException e) {
                log.warn("Buffer acquisition interrupted");
                Thread.currentThread().interrupt();
                break;
            } catch (Exception e) {
                log.error("Error processing outbound packet: {}", e.getMessage());
            } finally {
                if (buffer != null) {
                    bufferPool.release(buffer);
                }
            }
        }
    }
    
    /**
     * Handles an incoming IP packet by verifying its checksum, determining its protocol,
     * and processing it accordingly.
     *
     * <p>
     * Depending on the protocol of the IP packet (e.g., UDP, ICMP), this method delegates
     * the packet to the appropriate handler. If the network stack is acting as an exit node,
     * it handles internet-bound traffic; otherwise, it routes VPN-bound traffic using the
     * {@link SwarmRouter}.
     * </p>
     *
     * @param buffer The {@link ByteBuffer} containing the raw IP packet data.
     */
    private void handlePacket(ByteBuffer buffer) {
        ByteBuffer workBuffer = null;
        try {
            // Basic sanity checks
            if (buffer == null || !buffer.hasRemaining()) {
                return;
            }

            // Size validation for IPv4
            int packetSize = buffer.remaining();
            if (packetSize < MIN_PACKET_SIZE || packetSize > MAX_PACKET_SIZE) {
                log.warn("Invalid packet size: {}", packetSize);
                return;
            }

            // Make safe copy using buffer pool
            workBuffer = bufferPool.acquire();
            workBuffer.put(buffer.duplicate());
            workBuffer.flip();

            IPPacket packet = new IPPacket(workBuffer);

            
            // Verify IP header
            if (!packet.verifyChecksum()) {
                log.warn("Invalid IP checksum from {}", 
                    IPPacket.formatIP(packet.getSourceIP()));
                return;
            }

            // Apply rate limiting per source IP
            String sourceAddr = IPPacket.formatIP(packet.getSourceIP());
            RateLimiter limiter = getRateLimiter(sourceAddr);
            
            if (!limiter.tryAcquire()) {
                log.warn("Rate limit exceeded for {}", sourceAddr);
                return;
            }

            // Handle based on protocol
            switch (packet.getProtocol()) {
                case IPPacket.PROTO_UDP -> {
                    ByteBuffer payload = packet.getPayload();
                    if (payload == null || payload.remaining() < 8) {
                        log.warn("Invalid UDP packet from {}", sourceAddr);
                        return;
                    }
                    udpHandler.handlePacket(packet);
                }
                    
                case IPPacket.PROTO_ICMP -> {
                    ByteBuffer icmp = packet.getPayload();
                    if (icmp == null || icmp.remaining() < 8) {
                        log.warn("Invalid ICMP packet from {}", sourceAddr);
                        return;
                    }
                    handleICMP(packet);
                }
                    
                default -> {
                    if (log.isDebugEnabled()) {
                        log.debug("Unsupported protocol: {} from {}", 
                            packet.getProtocol(), sourceAddr);
                    }
                }
            }

            // Clean up old rate limiters periodically
            if (Math.random() < 0.001) { // 0.1% chance per packet
                cleanupRateLimiters();
            }

        } catch (InterruptedException e) {
            log.warn("Buffer acquisition interrupted");
            Thread.currentThread().interrupt();
        } catch (Exception e) {
            log.error("Error handling packet: {}", e.getMessage());
        } finally {
            if (workBuffer != null) {
                bufferPool.release(workBuffer);
            }
        }
    }
 
    /**
    * Cleans up rate limiters for IP addresses that have not sent traffic
    * in a predefined interval (5 minutes by default). Helps to conserve
    * memory by removing unused rate limiter entries.
    */
    private void cleanupRateLimiters() {
        // Remove rate limiters for addresses we haven't seen in a while
        long now = System.currentTimeMillis();
        rateLimiters.entrySet().removeIf(entry -> 
            now - entry.getValue().getLastUsedTime() > TimeUnit.MINUTES.toMillis(5));
    }

    /**
     * Handles outbound internet-bound traffic by sending UDP packets to external destinations.
     *
     * <p>
     * This method is invoked when the network stack is acting as an exit node and needs to forward
     * VPN traffic to the internet. It extracts the source and destination ports from the payload,
     * sends the data using a {@link DatagramSocket}, waits for a response, and then routes the response
     * back through the VPN.
     * </p>
     *
     * @param packet The {@link IPPacket} representing the outbound internet-bound traffic.
     */
    private void handleOutboundTraffic(IPPacket packet) {
        if (packet.getProtocol() != IPPacket.PROTO_UDP) {
            log.debug("Only UDP is currently supported for internet traffic");
            return;
        }

        ByteBuffer buffer = null;
        DatagramSocket internetSocket = null;
        String destAddr = null;

        try {
            ByteBuffer payload = packet.getPayload();
            destAddr = IPPacket.formatIP(packet.getDestinationIP());

            // Get socket info from payload
            int originalSrcPort = payload.getShort(0) & 0xFFFF;
            int destPort = payload.getShort(2) & 0xFFFF;

            // Check ACL before creating socket
            if (!outboundACL.isAllowed(destAddr, destPort)) {
                log.warn("Outbound connection to {}:{} blocked by ACL", destAddr, destPort);
                return;
            }

            // Get actual data with position handling
            payload.position(4);
            ByteBuffer data = payload.slice();

            // Create controlled socket
            internetSocket = createManagedSocket();

            // Send the data
            byte[] sendData = new byte[data.remaining()];
            data.get(sendData);

            // Validate destination address
            InetAddress inetAddr = InetAddress.getByName(destAddr);
            if (inetAddr.isLoopbackAddress() || inetAddr.isLinkLocalAddress() || 
                inetAddr.isSiteLocalAddress() || inetAddr.isMulticastAddress()) {
                log.warn("Rejected connection attempt to restricted address: {}", destAddr);
                return;
            }

            DatagramPacket sendPacket = new DatagramPacket(
                sendData, 
                sendData.length, 
                inetAddr, 
                destPort
            );
            internetSocket.send(sendPacket);

            // Wait for response with timeout
            byte[] receiveData = new byte[MAX_PACKET_SIZE];
            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);
            internetSocket.setSoTimeout(5000);  // 5 second timeout
            internetSocket.receive(receivePacket);

            // Process response
            ByteBuffer responseBuffer = bufferPool.acquire();
            try {
                responseBuffer.putShort((short)originalSrcPort);
                responseBuffer.putShort((short)destPort);
                responseBuffer.put(receiveData, 0, receivePacket.getLength());
                responseBuffer.flip();

                // Route response
                String sourceAddr = IPPacket.formatIP(packet.getSourceIP());
                String nextHop = router.getNextHop(sourceAddr);
                if (nextHop != null) {
                    IPPacket response = IPPacket.create(
                        IPPacket.PROTO_UDP,
                        parseIP(destAddr),
                        parseIP(sourceAddr),
                        responseBuffer
                    );
                    router.routePacket(response.getPacket(), nextHop);
                }
            } finally {
                bufferPool.release(responseBuffer);
            }

        } catch (IOException | InterruptedException e) {
            log.error("Error handling outbound traffic to {}: {}", destAddr, e.getMessage());
        } finally {
            if (internetSocket != null) {
                internetSocket.close();
                if (destAddr != null) {
                    outboundACL.releaseSocket(destAddr);
                }
            }
        }
    }
    
    /**
     * Creates a managed {@link DatagramSocket} with specific configurations to enhance security and performance.
     *
     * <p>
     * The socket is configured to allow address reuse, set with a timeout, and assigned appropriate
     * buffer sizes to handle standard network traffic efficiently.
     * </p>
     *
     * @return A configured {@link DatagramSocket} instance.
     * @throws SocketException If the socket could not be opened, or the socket could not bind to the specified local port.
     */
    private DatagramSocket createManagedSocket() throws SocketException {
        DatagramSocket socket = new DatagramSocket();
        socket.setReuseAddress(true);
        socket.setSoTimeout(5000);  // 5 second timeout

        // Set socket options for security
        socket.setTrafficClass(0x04);  // IPTOS_RELIABILITY

        // Set reasonable send/receive buffer sizes
        socket.setSendBufferSize(DEFAULT_BUFFER_SIZE);
        socket.setReceiveBufferSize(DEFAULT_BUFFER_SIZE);

        return socket;
    }

    /**
     * Handles ICMP messages such as ping (echo requests).
     *
     * <p>
     * This method processes incoming ICMP packets. If an ICMP echo request (ping) is detected,
     * it generates and sends an appropriate echo reply.
     * </p>
     *
     * @param packet The {@link IPPacket} representing the incoming ICMP message.
     */
    private void handleICMP(IPPacket packet) {
        icmpHandler.handleICMP(packet, router);
    }
 
    /**
     * Sends an IP packet with the specified protocol, destination IP, and payload.
     *
     * <p>
     * This method constructs an {@link IPPacket} with the given parameters and routes it using the
     * {@link SwarmRouter}. If the network stack is acting as an exit node, it handles the packet as
     * outbound internet-bound traffic.
     * </p>
     *
     * @param protocol The protocol number (e.g., {@link IPPacket#PROTO_TCP}, {@link IPPacket#PROTO_UDP}).
     * @param destIP   The destination IP address as an integer.
     * @param payload  The payload data as a {@link ByteBuffer}.
     */
    public void sendPacket(int protocol, int destIP, ByteBuffer payload) {
        try {
            // Parse destination address
            String destAddr = IPPacket.formatIP(destIP);
            
            // Check if we're the exit node (10.0.0.1)
            if (address.equals("10.0.0.1")) {
                // We're the exit node, handle internet traffic
                handleOutboundTraffic(protocol, destAddr, destIP, payload);
                return;
            }
            
            // Get next hop from router
            String nextHop = router.getNextHop(destAddr);
            if (nextHop == null) {
                log.debug("No route to {}", destAddr);
                return;
            }
            
            // Create IP packet
            byte[] sourceIP = parseIP(address);
            byte[] destIPBytes = parseIP(destAddr);
            
            IPPacket packet = IPPacket.create(protocol, sourceIP, destIPBytes, payload);
            
            // Send to router
            router.routePacket(packet.getPacket(), nextHop);
            
        } catch (Exception e) {
            log.error("Error sending packet: {}", e.getMessage());
        }
    }
    
    /**
     * Parses an IP address string into a byte array.
     *
     * <p>
     * Converts a dotted-decimal IP address string (e.g., "192.168.1.1") into a byte array
     * suitable for use in network packets.
     * </p>
     *
     * @param address The IP address as a {@code String}.
     * @return A byte array representing the IP address.
     */
    private byte[] parseIP(String address) {
        String[] parts = address.split("\\.");
        byte[] bytes = new byte[4];
        for (int i = 0; i < 4; i++) {
            bytes[i] = (byte) Integer.parseInt(parts[i]);
        }
        return bytes;
    }
    
    /**
     * Retrieves the UDP handler associated with this network stack.
     *
     * @return The {@link UDPHandler} instance.
     */
    public UDPHandler getUDPHandler() {
        return udpHandler;
    }
    
    /**
     * Closes the network stack, terminating all ongoing processes and releasing resources.
     *
     * <p>
     * This method stops the inbound and outbound packet processing threads, closes the virtual
     * network interface, and shuts down the executor service. It ensures that all resources are
     * properly released to prevent resource leaks.
     * </p>
     */
    @Override
    public void close() {
        running = false;
        rateLimiters.clear();
        try {
            // Let current operations finish
            try (virtualInterface) {
                // Let current operations finish
                Thread.sleep(100);
                // Log final stats
                log.info("Buffer pool stats at shutdown: {}", bufferPool.getStats());
            }
        } catch (Exception e) {
            log.error("Error closing network stack: {}", e.getMessage());
        } finally {
            executor.shutdownNow();
        }
    }
    
    /**
     * Processes an incoming packet by delegating it to the {@link #handlePacket(ByteBuffer)} method.
     *
     * <p>
     * This method can be used to inject packets directly into the network stack for processing,
     * bypassing the virtual network interface. It ensures that only valid packets with remaining
     * data are processed.
     * </p>
     *
     * @param packet The {@link ByteBuffer} containing the raw packet data.
     */
    public void processIncoming(ByteBuffer packet) {
        if (packet == null || !packet.hasRemaining()) {
            return;
        }
        ByteBuffer buffer = null;
        try {
            buffer = bufferPool.acquire();
            buffer.put(packet.duplicate());
            buffer.flip();
            handlePacket(buffer);
        } catch (InterruptedException e) {
            log.warn("Buffer acquisition interrupted");
            Thread.currentThread().interrupt();
        } catch (Exception e) {
            log.error("Error processing incoming packet: {}", e.getMessage());
        } finally {
            if (buffer != null) {
                bufferPool.release(buffer);
            }
        }
    }

    /**
     * Injects a packet into the virtual network interface for transmission.
     *
     * <p>
     * This method allows external components to send packets through the virtual network interface.
     * It ensures that the network stack is running and that the packet contains data before writing.
     * </p>
     *
     * @param packet The {@link ByteBuffer} containing the raw packet data to be injected.
     */
    public void injectPacket(ByteBuffer packet) {
        if (!running || packet == null || !packet.hasRemaining()) {
            return;
        }
        ByteBuffer buffer = null;
        try {
            buffer = bufferPool.acquire();
            buffer.put(packet.duplicate());
            buffer.flip();
            virtualInterface.write(buffer);
        } catch (InterruptedException e) {
            log.warn("Buffer acquisition interrupted");
            Thread.currentThread().interrupt();
        } catch (Exception e) {
            log.error("Error injecting packet: {}", e.getMessage());
        } finally {
            if (buffer != null) {
                bufferPool.release(buffer);
            }
        }
    }

    /**
     * Handles outbound internet-bound traffic by sending UDP packets to external destinations.
     *
     * <p>
     * This method is invoked when the network stack is acting as an exit node and needs to forward
     * VPN traffic to the internet. It extracts the source and destination ports from the payload,
     * sends the data using a {@link UDPHandler}, and handles the response.
     * </p>
     *
     * @param protocol   The protocol number (e.g., {@link IPPacket#PROTO_UDP}).
     * @param destAddr   The destination address as a {@code String} in dotted-decimal notation.
     * @param destIP     The destination IP address as an integer.
     * @param payload    The payload data as a {@link ByteBuffer}.
     */
    private void handleOutboundTraffic(int protocol, String destAddr, int destIP, ByteBuffer payload) {
        if (protocol != IPPacket.PROTO_UDP) {
            log.debug("Only UDP is currently supported for internet traffic");
            return;
        }

        ByteBuffer buffer = null;
        try {
            // Copy payload to working buffer
            buffer = bufferPool.acquire();
            buffer.put(payload.duplicate());
            buffer.flip();

            log.info("Handling outbound traffic to {}", destAddr);

            // Extract ports and data
            short sourcePort = buffer.getShort(0);
            short destPort = buffer.getShort(2);
            buffer.position(4);  // Move position past the ports
            ByteBuffer data = buffer.slice();  // Create slice from current position

            // Let UDPHandler deal with the actual UDP communication
            udpHandler.sendPacket(
                sourcePort & 0xFFFF,
                destIP,
                destPort & 0xFFFF,
                data
            );
        } catch (InterruptedException e) {
            log.warn("Buffer acquisition interrupted");
            Thread.currentThread().interrupt();
        } catch (Exception e) {
            log.error("Error handling outbound traffic: {}", e.getMessage());
        } finally {
            if (buffer != null) {
                bufferPool.release(buffer);
            }
        }
    }
    
    /**
     * Thread-safe pool of reusable {@link ByteBuffer} instances.
     * Implements backpressure to ensure that memory usage remains
     * within predefined limits while providing performance benefits
     * by reducing garbage collection overhead.
     *
     * <p>Maintains a pool of pre-allocated buffers and dynamically
     * grows/shrinks based on demand, up to a configurable maximum size.</p>
     *
     * <p><strong>Usage:</strong></p>
     * <pre>{@code
     * BufferPool pool = new BufferPool(100, 1500);
     * ByteBuffer buffer = pool.acquire();
     * try {
     *     // Use buffer
     * } finally {
     *     pool.release(buffer);
     * }
     * }</pre>
     */
    private static final class BufferPool {
           private final Queue<ByteBuffer> availableBuffers;
           private final Set<ByteBuffer> inUseBuffers;
           private final int maxBuffers;
           private final int bufferSize;
           private final AtomicInteger totalCreated = new AtomicInteger(0);
           private final AtomicInteger waitingThreads = new AtomicInteger(0);

           private static final long BUFFER_WAIT_TIMEOUT = TimeUnit.SECONDS.toNanos(5);

           /**
            * Constructs a new {@code BufferPool} with specified maximum buffers and buffer size.
            *
            * @param maxBuffers The maximum number of buffers that can be created.
            * @param bufferSize The size of each buffer in bytes.
            */
           public BufferPool(int maxBuffers, int bufferSize) {
               this.maxBuffers = maxBuffers;
               this.bufferSize = bufferSize;
               this.availableBuffers = new ConcurrentLinkedQueue<>();
               this.inUseBuffers = ConcurrentHashMap.newKeySet();

               // Pre-allocate initial buffers
               for (int i = 0; i < maxBuffers / 4; i++) {
                   availableBuffers.offer(ByteBuffer.allocateDirect(bufferSize));
                   totalCreated.incrementAndGet();
               }
           }

           /**
            * Acquires a {@link ByteBuffer} from the pool. If no buffers are available and the pool
            * has not reached its maximum size, a new buffer is created. Otherwise, the method waits
            * until a buffer becomes available or a timeout occurs.
            *
            * @return A {@link ByteBuffer} instance ready for use.
            * @throws InterruptedException If the thread is interrupted while waiting for a buffer.
            */
           public ByteBuffer acquire() throws InterruptedException {
               waitingThreads.incrementAndGet();
               try {
                   long deadline = System.nanoTime() + BUFFER_WAIT_TIMEOUT;

                   while (true) {
                       // Try to get an available buffer
                       ByteBuffer buffer = availableBuffers.poll();
                       if (buffer != null) {
                           inUseBuffers.add(buffer);
                           buffer.clear();
                           return buffer;
                       }

                       // If we can create a new buffer, do so
                       if (totalCreated.get() < maxBuffers) {
                           if (totalCreated.incrementAndGet() <= maxBuffers) {
                               buffer = ByteBuffer.allocateDirect(bufferSize);
                               inUseBuffers.add(buffer);
                               return buffer;
                           }
                           totalCreated.decrementAndGet();
                       }

                       // Wait for a buffer to become available
                       long timeLeft = deadline - System.nanoTime();
                       if (timeLeft <= 0) {
                           throw new InterruptedException("Buffer acquisition timeout");
                       }
                       // Exponential backoff
                       Thread.sleep(Math.min(100, Math.max(1, 1000_000 - timeLeft/1000_000)));
                   }
               } finally {
                   waitingThreads.decrementAndGet();
               }
           }

           /**
            * Releases a {@link ByteBuffer} back to the pool, making it available for reuse.
            *
            * @param buffer The {@link ByteBuffer} to be released.
            */
           public void release(ByteBuffer buffer) {
               if (buffer != null && inUseBuffers.remove(buffer)) {
                   buffer.clear();
                   availableBuffers.offer(buffer);
               }
           }

           /**
            * Cleans up excess buffers that are not frequently used.
            *
            * <p>
            * This method reduces the number of available buffers to a quarter of the maximum
            * size, ensuring that memory usage remains optimal.
            * </p>
            */
           public void cleanup() {
               // Only clean up if no threads are waiting
               if (waitingThreads.get() == 0) {
                   int excess = availableBuffers.size() - (maxBuffers / 4);
                   if (excess > 0) {
                       for (int i = 0; i < excess; i++) {
                           ByteBuffer buffer = availableBuffers.poll();
                           if (buffer == null) break;
                           totalCreated.decrementAndGet();
                       }
                   }
               }
           }

           /**
            * Retrieves statistics about the current state of the buffer pool.
            *
            * @return A {@link Map} containing statistics such as total buffers, available buffers,
            *         in-use buffers, and waiting threads.
            */
           public Map<String, Number> getStats() {
               Map<String, Number> stats = new HashMap<>();
               stats.put("totalBuffers", totalCreated.get());
               stats.put("availableBuffers", availableBuffers.size());
               stats.put("inUseBuffers", inUseBuffers.size());
               stats.put("waitingThreads", waitingThreads.get());
               return stats;
           }
       }
    
    /**
    * Outbound access control list for managing external connections.
    *
    * <p>Provides granular control over outbound traffic by enforcing
    * per-host and global socket limits, as well as port-based filtering.</p>
    *
    * <p><strong>Key Features:</strong></p>
    * <ul>
    *   <li>Restricts the number of concurrent connections per destination.</li>
    *   <li>Imposes a global limit on total open sockets to prevent resource exhaustion.</li>
    *   <li>Blocks connections to disallowed ports or addresses.</li>
    * </ul>
    */
    private static class OutboundACL {
        private static final int MAX_SOCKETS_PER_HOST = 8;
        private static final int MAX_TOTAL_SOCKETS = 256;
        private static final long SOCKET_CLEANUP_INTERVAL = TimeUnit.MINUTES.toMillis(1);

        // Default allowed ports - can be made configurable
        private static final Set<Integer> DEFAULT_ALLOWED_PORTS = Set.of(
            53,    // DNS
            80,    // HTTP
            443,   // HTTPS
            3478,  // STUN
            5349   // STUN/TLS
        );

        private final Set<Integer> allowedPorts;
        private final Map<String, AtomicInteger> socketCountsByHost;
        private final AtomicInteger totalSockets;
        private volatile long lastCleanup;
        private final Object cleanupLock = new Object();

        /**
         * Constructs a new {@code OutboundACL} instance with default allowed ports and initializes
         * internal tracking structures for socket management.
         */
        public OutboundACL() {
            this.allowedPorts = ConcurrentHashMap.newKeySet();
            this.allowedPorts.addAll(DEFAULT_ALLOWED_PORTS);
            this.socketCountsByHost = new ConcurrentHashMap<>();
            this.totalSockets = new AtomicInteger(0);
            this.lastCleanup = System.currentTimeMillis();
        }

        /**
         * Determines whether an outbound connection to a specified address and port is allowed
         * based on current ACL rules.
         *
         * <p>
         * The method checks if the destination port is allowed, ensures that the global socket
         * limit has not been exceeded, and verifies that the per-host socket limit is not breached.
         * If all checks pass, the method increments the relevant counters and permits the connection.
         * </p>
         *
         * @param destAddr The destination address as a {@code String}.
         * @param destPort The destination port as an {@code int}.
         * @return {@code true} if the connection is allowed; {@code false} otherwise.
         */
        public boolean isAllowed(String destAddr, int destPort) {
            // Check if port is allowed
            if (!allowedPorts.contains(destPort)) {
                return false;
            }

            // Check total socket limit
            if (totalSockets.get() >= MAX_TOTAL_SOCKETS) {
                cleanup(); // Try cleanup before rejecting
                if (totalSockets.get() >= MAX_TOTAL_SOCKETS) {
                    return false;
                }
            }

            // Check per-host socket limit
            AtomicInteger hostCount = socketCountsByHost.computeIfAbsent(destAddr, 
                k -> new AtomicInteger(0));

            if (hostCount.get() >= MAX_SOCKETS_PER_HOST) {
                cleanup(); // Try cleanup before rejecting
                if (hostCount.get() >= MAX_SOCKETS_PER_HOST) {
                    return false;
                }
            }

            // Track socket allocation
            hostCount.incrementAndGet();
            totalSockets.incrementAndGet();
            return true;
        }

        /**
         * Releases a previously allowed outbound connection, decrementing the relevant
         * socket counters for the specified destination address.
         *
         * @param destAddr The destination address as a {@code String}.
         */
        public void releaseSocket(String destAddr) {
            AtomicInteger hostCount = socketCountsByHost.get(destAddr);
            if (hostCount != null) {
                hostCount.decrementAndGet();
            }
            totalSockets.decrementAndGet();
        }

        /**
         * Cleans up outdated socket counts by removing entries for hosts that no longer have active connections.
         *
         * <p>
         * This method is invoked periodically to ensure that the internal tracking structures do not
         * retain stale information, thereby conserving memory and maintaining accurate connection counts.
         * </p>
         */
        private void cleanup() {
            long now = System.currentTimeMillis();
            if (now - lastCleanup < SOCKET_CLEANUP_INTERVAL) {
                return;
            }

            synchronized (cleanupLock) {
                if (now - lastCleanup < SOCKET_CLEANUP_INTERVAL) {
                    return;
                }

                socketCountsByHost.entrySet().removeIf(entry -> 
                    entry.getValue().get() <= 0);

                lastCleanup = now;
            }
        }
    }
    
    /**
    * Handles ICMP packet processing, including echo requests (ping).
    *
    * <p>Provides rate limiting to prevent abuse and mitigates replay/spoofing
    * attacks by tracking recent requests.</p>
    *
    * <p><strong>Responsibilities:</strong></p>
    * <ul>
    *   <li>Processes ICMP echo requests and generates appropriate replies.</li>
    *   <li>Implements rate limiting for incoming ICMP packets on a per-IP basis.</li>
    *   <li>Maintains a cache of recent requests to detect duplicates or replays.</li>
    * </ul>
    */
    private static class ICMPHandler {
        private static final int ICMP_ECHO_REQUEST = 8;
        private static final int ICMP_ECHO_REPLY = 0;

        // Rate limiting for ICMP
        private static final int ICMP_RATE_LIMIT = 100;  // packets per second
        private final Map<String, RateLimiter> icmpLimiters = new ConcurrentHashMap<>();

        // Track ICMP echo requests to prevent spoofing/replay
        private static final int MAX_TRACKED_REQUESTS = 1000;
        private final Map<ICMPIdentifier, Long> recentRequests = new ConcurrentHashMap<>();
        private volatile long lastCleanup = System.currentTimeMillis();
        private static final long CLEANUP_INTERVAL = TimeUnit.MINUTES.toMillis(1);

        /**
         * Inner class representing a unique identifier for ICMP echo requests.
         * Combines the source IP address, identifier, and sequence number.
         */
        private static class ICMPIdentifier {
            final String sourceIP;
            final int id;
            final int sequence;

            /**
             * Constructs a new {@code ICMPIdentifier} with the specified source IP, identifier, and sequence number.
             *
             * @param sourceIP The source IP address as a {@code String}.
             * @param id       The ICMP identifier.
             * @param sequence The ICMP sequence number.
             */
            ICMPIdentifier(String sourceIP, int id, int sequence) {
                this.sourceIP = sourceIP;
                this.id = id;
                this.sequence = sequence;
            }

            @Override
            public boolean equals(Object o) {
                if (this == o) return true;
                if (!(o instanceof ICMPIdentifier)) return false;
                ICMPIdentifier that = (ICMPIdentifier) o;
                return id == that.id && 
                       sequence == that.sequence && 
                       sourceIP.equals(that.sourceIP);
            }

            @Override
            public int hashCode() {
                return Objects.hash(sourceIP, id, sequence);
            }
        }

        /**
         * Handles an incoming ICMP packet by determining its type and processing it accordingly.
         *
         * <p>
         * For ICMP echo requests (type 8), this method generates and routes an echo reply.
         * It also implements rate limiting and request tracking to prevent abuse.
         * </p>
         *
         * @param packet The {@link IPPacket} representing the incoming ICMP message.
         * @param router The {@link SwarmRouter} used for routing the ICMP reply.
         */
        void handleICMP(IPPacket packet, SwarmRouter router) {
            ByteBuffer icmp = packet.getPayload();
            if (icmp == null || icmp.remaining() < 8) {
                return;
            }

            String sourceIP = IPPacket.formatIP(packet.getSourceIP());

            // Apply rate limiting
            RateLimiter limiter = icmpLimiters.computeIfAbsent(sourceIP,
                addr -> new RateLimiter(ICMP_RATE_LIMIT));

            if (!limiter.tryAcquire()) {
                log.warn("ICMP rate limit exceeded for {}", sourceIP);
                return;
            }

            // Clean up old tracked requests
            cleanupTracking();

            int type = icmp.get(0) & 0xFF;
            int code = icmp.get(1) & 0xFF;

            switch (type) {
                case ICMP_ECHO_REQUEST -> handleEchoRequest(packet, icmp, router);
                // Add other ICMP types as needed
                default -> log.debug("Unsupported ICMP type: {}", type);
            }
        }

        /**
         * Handles an ICMP echo request by generating and routing an echo reply.
         *
         * <p>
         * This method extracts the ICMP identifier and sequence number from the request,
         * checks for duplicate or replayed requests, and constructs an appropriate echo reply
         * if the request is valid and not a duplicate.
         * </p>
         *
         * @param packet   The {@link IPPacket} representing the incoming ICMP echo request.
         * @param icmp     The {@link ByteBuffer} containing the ICMP payload.
         * @param router   The {@link SwarmRouter} used for routing the ICMP reply.
         */
        private void handleEchoRequest(IPPacket packet, ByteBuffer icmp, SwarmRouter router) {
            // Extract ICMP header fields
            int id = icmp.getShort(4) & 0xFFFF;
            int sequence = icmp.getShort(6) & 0xFFFF;
            String sourceIP = IPPacket.formatIP(packet.getSourceIP());

            // Create identifier for this request
            ICMPIdentifier identifier = new ICMPIdentifier(sourceIP, id, sequence);

            // Check if we've seen this request recently
            Long lastSeen = recentRequests.get(identifier);
            if (lastSeen != null && 
                System.currentTimeMillis() - lastSeen < TimeUnit.SECONDS.toMillis(60)) {
                log.warn("Duplicate ICMP request from {} (ID: {}, Seq: {})", 
                    sourceIP, id, sequence);
                return;
            }

            // Track this request
            if (recentRequests.size() < MAX_TRACKED_REQUESTS) {
                recentRequests.put(identifier, System.currentTimeMillis());
            }

            // Create reply
            ByteBuffer reply = ByteBuffer.allocate(icmp.remaining());
            reply.put(icmp.duplicate());
            reply.flip();

            // Modify header for reply
            reply.put(0, (byte)ICMP_ECHO_REPLY);  // Change type to reply
            reply.put(1, (byte)0);                // Code 0
            reply.putShort(2, (short)0);          // Clear checksum

            // Calculate new checksum
            int checksum = calculateICMPChecksum(reply);
            reply.putShort(2, (short)checksum);

            // Send reply
            String destAddr = IPPacket.formatIP(packet.getSourceIP());
            String nextHop = router.getNextHop(destAddr);
            if (nextHop != null) {
                router.routePacket(reply, nextHop);
            }
        }

        /**
         * Cleans up tracked ICMP echo requests and rate limiters by removing entries that are older than the defined interval.
         *
         * <p>
         * This method helps in preventing the internal tracking structures from growing indefinitely,
         * thereby conserving memory and maintaining accurate tracking of recent requests.
         * </p>
         */
        private void cleanupTracking() {
            long now = System.currentTimeMillis();
            if (now - lastCleanup > CLEANUP_INTERVAL) {
                synchronized (this) {
                    if (now - lastCleanup > CLEANUP_INTERVAL) {
                        recentRequests.entrySet().removeIf(entry ->
                            now - entry.getValue() > TimeUnit.MINUTES.toMillis(5));
                        icmpLimiters.entrySet().removeIf(entry ->
                            now - entry.getValue().getLastUsedTime() > TimeUnit.MINUTES.toMillis(5));
                        lastCleanup = now;
                    }
                }
            }
        }

        /**
         * Calculates the ICMP checksum for the given data.
         *
         * <p>
         * The checksum is calculated by summing all 16-bit words in the ICMP message, adding any
         * carry-over bits, and then taking the one's complement of the total sum.
         * </p>
         *
         * @param data The {@link ByteBuffer} containing the ICMP message data.
         * @return The calculated checksum as an integer.
         */
        private static int calculateICMPChecksum(ByteBuffer data) {
            int sum = 0;
            int position = data.position();
            data.position(0);

            while (data.hasRemaining()) {
                if (data.remaining() >= 2) {
                    sum += data.getShort() & 0xFFFF;
                } else {
                    sum += (data.get() & 0xFF) << 8;
                }
            }

            data.position(position);

            sum = (sum >> 16) + (sum & 0xFFFF);
            sum += (sum >> 16);

            return ~sum & 0xFFFF;
        }
    }

}

=============================================

/*
 * Copyright (C) 2024 Publius Pseudis
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.publiuspseudis.esadvpn.core;

/**
 * <p>
 * The {@code ConnectionPhase} enum represents the various stages involved in establishing and maintaining
 * a Virtual Private Network (VPN) connection. Each phase corresponds to a specific step in the VPN connection
 * lifecycle, ensuring a structured and secure connection process.
 * </p>
 *
 * <p>
 * The typical sequence of connection phases is as follows:</p>
 * <ol>
 *   <li>{@link #INITIAL}: The starting phase before any connection attempts are made.</li>
 *   <li>{@link #UDP_VERIFIED}: Verification of UDP (User Datagram Protocol) connectivity.</li>
 *   <li>{@link #SECURE_CHANNEL_ESTABLISHED}: Establishment of a secure communication channel.</li>
 *   <li>{@link #NETWORK_HANDSHAKE_COMPLETE}: Completion of the network handshake, indicating a fully established VPN connection.</li>
 * </ol>
 * 
 *
 * <p>
 * This enumeration is essential for managing the state transitions within the VPN connection process,
 * allowing for appropriate handling and error management at each stage.
 * </p>
 * 
 * <p>
 * <strong>Example Usage:</strong>
 * </p>
 * <pre>{@code
 * ConnectionPhase currentPhase = ConnectionPhase.INITIAL;
 * 
 * // Attempt to verify UDP connectivity
 * if (verifyUDP()) {
 *     currentPhase = ConnectionPhase.UDP_VERIFIED;
 * }
 * 
 * // Establish a secure channel
 * if (establishSecureChannel()) {
 *     currentPhase = ConnectionPhase.SECURE_CHANNEL_ESTABLISHED;
 * }
 * 
 * // Complete the network handshake
 * if (completeNetworkHandshake()) {
 *     currentPhase = ConnectionPhase.NETWORK_HANDSHAKE_COMPLETE;
 * }
 * 
 * // Now the VPN connection is fully established
 * }</pre>
 * 
 * @author 
 * Publius Pseudis
 * 
 * @version 1.0
 * @since 2024-01-01
 */
public enum ConnectionPhase {
    
    /**
     * The initial phase of the VPN connection process.
     * <p>
     * In this phase, the VPN client is preparing to establish a connection.
     * No network communication has been attempted yet.
     * </p>
     */
    INITIAL,
    
    /**
     * The phase where UDP connectivity has been verified.
     * <p>
     * During this phase, the VPN client ensures that UDP packets can be sent and received,
     * which is essential for establishing a reliable communication channel.
     * Successful verification indicates that the underlying network supports UDP traffic,
     * which is commonly used for VPN data transmission.
     * </p>
     */
    UDP_VERIFIED,
    
    /**
     * The phase where a secure communication channel has been established.
     * <p>
     * In this phase, cryptographic protocols are used to create a secure tunnel between
     * the VPN client and server. This ensures that all data transmitted is encrypted and
     * protected from eavesdropping or tampering.
     * </p>
     */
    SECURE_CHANNEL_ESTABLISHED,
    
    /**
     * The phase where the network handshake is complete.
     * <p>
     * This final phase signifies that all necessary handshakes and negotiations between
     * the VPN client and server have been successfully completed. The VPN connection
     * is now fully established, allowing for secure and authenticated data exchange.
     * </p>
     */
    NETWORK_HANDSHAKE_COMPLETE;
}

=============================================

/*
 * Copyright (C) 2024 Publius Pseudis
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.publiuspseudis.esadvpn.core;

/**
 * <p>
 * The {@code RateLimiter} class implements a thread-safe token bucket algorithm
 * to control the rate of events, such as network packet processing. It ensures
 * that the number of permitted actions does not exceed a specified limit within
 * a given time frame.
 * </p>
 *
 * <p>
 * This implementation is suitable for scenarios where controlling the flow
 * of incoming or outgoing traffic is essential to prevent resource exhaustion
 * or to adhere to predefined usage policies. The rate limiter refills tokens
 * at a steady rate, allowing threads to acquire tokens before proceeding with
 * their operations.
 * </p>
 *
 * <p>
 * <strong>Key Features:</strong>
 * </p>
 * <ul>
 *   <li>Configurable rate limit based on tokens per second.</li>
 *   <li>Thread-safe operations using synchronization.</li>
 *   <li>Efficient token refill mechanism leveraging high-resolution time.</li>
 *   <li>Tracks the last usage time for potential cleanup or monitoring purposes.</li>
 * </ul>
 * 
 * <p>
 * <strong>Example Usage:</strong>
 * </p>
 * <pre>{@code
 * // Create a rate limiter allowing 1000 packets per second
 * RateLimiter rateLimiter = new RateLimiter(1000);
 * 
 * // Attempt to acquire a token before processing a packet
 * if (rateLimiter.tryAcquire()) {
 *     // Proceed with packet processing
 * } else {
 *     // Handle rate limit exceeded (e.g., drop packet, queue for later)
 * }
 * }</pre>
 * 
 * <p>
 * <strong>Thread Safety:</strong>  
 * All public methods of the {@code RateLimiter} class are thread-safe.
 * The class uses synchronization to ensure that token acquisition and
 * refilling operations are atomic and consistent across multiple threads.
 * </p>
 * 
 * @author
 * Publius Pseudis
 * 
 * @version 1.0
 */
public class RateLimiter {
    /**
     * The maximum number of tokens that can be accumulated in the bucket per second.
     * This value determines the rate at which tokens are refilled.
     */
    private final long tokensPerSec;

    /**
     * The number of nanoseconds required to accumulate a single token.
     * Calculated as 1,000,000,000 divided by {@code tokensPerSec}.
     */
    private final double nsPerToken;

    /**
     * The current number of available tokens in the bucket.
     * This value is decremented when a token is acquired and incremented
     * during the refill process.
     */
    private volatile double tokens;

    /**
     * The timestamp (in nanoseconds) of the last token refill operation.
     * Used to calculate the number of tokens to add based on elapsed time.
     */
    private volatile long lastRefillTime;

    /**
     * The timestamp (in milliseconds) of the last successful token acquisition.
     * Useful for monitoring and cleanup purposes.
     */
    private volatile long lastUsedTime; 

    /**
     * An object used for synchronizing access to token acquisition and refill operations.
     * Ensures thread-safe manipulation of shared resources.
     */
    private final Object lock = new Object();


    /**
     * Constructs a new {@code RateLimiter} with the specified token rate.
     *
     * <p>
     * Initializes the rate limiter with the given number of tokens per second.
     * The token bucket is initially filled to its maximum capacity.
     * </p>
     *
     * @param tokensPerSec The maximum number of tokens allowed per second.
     *                     Must be a positive integer.
     * @throws IllegalArgumentException If {@code tokensPerSec} is not positive.
     */
    public RateLimiter(long tokensPerSec) throws IllegalArgumentException {
        this.tokensPerSec = tokensPerSec;
        this.nsPerToken = 1_000_000_000.0 / tokensPerSec;
        this.tokens = tokensPerSec;
        long now = System.nanoTime();
        this.lastRefillTime = now;
        this.lastUsedTime = System.currentTimeMillis(); // Initialize lastUsedTime
    }

    /**
     * Attempts to acquire a single token from the rate limiter.
     *
     * <p>
     * If a token is available, it is consumed, and the method returns {@code true},
     * indicating that the action is permitted. If no tokens are available, the method
     * returns {@code false}, indicating that the rate limit has been exceeded.
     * </p>
     *
     * <p>
     * This method is thread-safe and can be called concurrently by multiple threads.
     * </p>
     *
     * @return {@code true} if a token was successfully acquired; {@code false} otherwise.
     */
    public boolean tryAcquire() {
        synchronized (lock) {
            refillTokens();
            
            if (tokens >= 1.0) {
                tokens--;
                lastUsedTime = System.currentTimeMillis(); // Update when successfully used
                return true;
            }
            return false;
        }
    }

    /**
     * Refills the token bucket based on the elapsed time since the last refill.
     *
     * <p>
     * Calculates the number of tokens to add by determining how much time has passed
     * since {@code lastRefillTime}. The bucket is refilled with tokens at the rate
     * defined by {@code tokensPerSec}, ensuring that the total number of tokens
     * does not exceed the maximum capacity.
     * </p>
     *
     * <p>
     * This method is intended to be called internally within a synchronized context.
     * </p>
     */
    private void refillTokens() {
        long now = System.nanoTime();
        double elapsed = (now - lastRefillTime);
        double newTokens = elapsed / nsPerToken;
        
        if (newTokens > 0) {
            tokens = Math.min(tokensPerSec, tokens + newTokens);
            lastRefillTime = now;
        }
    }
    /**
     * Retrieves the timestamp of the last successful token acquisition.
     *
     * <p>
     * This method can be used to determine when the rate limiter was last utilized,
     * which is helpful for monitoring usage patterns or performing cleanup of inactive
     * rate limiters.
     * </p>
     *
     * @return The timestamp (in milliseconds since epoch) of the last token acquisition.
     */
    public long getLastUsedTime() {
        return lastUsedTime;
    }
    /**
     * Retrieves the maximum number of tokens that can be accumulated in the bucket.
     *
     * <p>
     * This value defines the capacity of the token bucket and determines the burst
     * capacity of the rate limiter.
     * </p>
     *
     * @return The maximum number of tokens per second.
     */
    public long getTokensPerSec() {
        return tokensPerSec;
    }

    /**
     * Calculates the current refill rate in tokens per second.
     *
     * <p>
     * This method returns the configured rate at which tokens are replenished,
     * allowing for dynamic adjustment or monitoring of the rate limiter's behavior.
     * </p>
     *
     * @return The number of tokens added to the bucket each second.
     */
    public double getRefillRate() {
        return tokensPerSec;
    }

    /**
     * Resets the rate limiter to its initial state.
     *
     * <p>
     * This method clears any accumulated tokens and resets the refill timer.
     * After calling this method, the rate limiter will behave as if it was newly created.
     * </p>
     *
     * <p>
     * Use this method with caution, as it may disrupt ongoing rate-limited operations.
     * </p>
     */
    public void reset() {
        synchronized (lock) {
            this.tokens = tokensPerSec;
            this.lastRefillTime = System.nanoTime();
            this.lastUsedTime = System.currentTimeMillis();
        }
    }

    /**
     * Provides a string representation of the rate limiter's current state.
     *
     * <p>
     * The returned string includes the configured token rate, available tokens,
     * and the timestamp of the last token acquisition.
     * </p>
     *
     * @return A {@code String} detailing the rate limiter's state.
     */
    @Override
    public String toString() {
        synchronized (lock) {
            refillTokens();
            return String.format("RateLimiter[tokensPerSec=%d, availableTokens=%.2f, lastUsedTime=%d]",
                    tokensPerSec, tokens, lastUsedTime);
        }
    }
}


=============================================

/*
 * Copyright (C) 2024 Publius Pseudis
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.publiuspseudis.esadvpn.core;

import org.publiuspseudis.esadvpn.protocol.GossipMessage;
import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetSocketAddress;
import java.net.SocketException;
import java.net.SocketTimeoutException;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.security.SecureRandom;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicLong;
import org.publiuspseudis.esadvpn.crypto.ProofOfWork;
import org.publiuspseudis.esadvpn.network.P2PNetwork;
import org.publiuspseudis.esadvpn.crypto.SecureChannel;
import org.publiuspseudis.esadvpn.protocol.NetworkProtocolHandler;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * <p>
 * The {@code VPNConnection} class manages a secure Virtual Private Network (VPN) connection within
 * the peer-to-peer (P2P) network. It implements the {@link NetworkProtocolHandler} interface to handle
 * various network protocols and the {@link AutoCloseable} interface to ensure proper resource management.
 * </p>
 * 
 * <p>
 * <strong>Key Functionalities:</strong></p>
 * <ul>
 *   <li>Establishing and managing secure channels using cryptographic protocols.</li>
 *   <li>Handling different types of VPN messages, including data packets, gossip messages, proofs of work,
 *       peer information, and keepalive pings.</li>
 *   <li>Managing connection phases to track the state of the VPN connection.</li>
 *   <li>Performing handshakes and maintaining the integrity of the secure channel.</li>
 *   <li>Tracking connection statistics such as bytes sent, bytes received, latency, and bandwidth estimates.</li>
 *   <li>Integrating with swarm intelligence-based routing mechanisms.</li>
 *   <li>Ensuring thread-safe operations and proper shutdown procedures.</li>
 * </ul>
 * 
 * 
 * <p>
 * <strong>Example Usage:</strong>
 * </p>
 * <pre>{@code
 * // Initialize VPNConnection as a client
 * VPNConnection vpnConnection = new VPNConnection("peer.example.com", 51820, false);
 * 
 * // Set a connection handler
 * vpnConnection.setConnectionHandler(new P2PNetwork.ConnectionHandler() {
 *     @Override
 *     public void onNewConnection(String host, int port, VPNConnection connection) {
 *         System.out.println("Connected to " + host + ":" + port);
 *     }
 * });
 * 
 * // Send a data packet
 * byte[] data = "Hello, VPN!".getBytes(StandardCharsets.UTF_8);
 * vpnConnection.sendPacket(data);
 * 
 * // Receive a data packet
 * byte[] receivedData = vpnConnection.receivePacket();
 * if (receivedData != null) {
 *     String message = new String(receivedData, StandardCharsets.UTF_8);
 *     System.out.println("Received: " + message);
 * }
 * 
 * // Close the VPN connection
 * vpnConnection.close();
 * }</pre>
 * 
 * <p>
 * <strong>Thread Safety:</strong>
 * </p>
 * <p>
 * The {@code VPNConnection} class is designed to be thread-safe. It employs synchronization mechanisms
 * and uses thread-safe data structures such as {@code AtomicLong} for tracking statistics. Volatile fields
 * are used to ensure visibility of changes across threads. Additionally, network operations are handled
 * in separate threads to prevent blocking and ensure responsive behavior.
 * </p>
 * 
 * <p>
 * <strong>Dependencies:</strong>
 * </p>
 * <ul>
 *   <li>{@link SecureChannel}: Manages encryption and decryption of messages to ensure secure communication.</li>
 *   <li>{@link GossipMessage}: Handles gossip protocol messages for peer discovery and network information sharing.</li>
 *   <li>SLF4J Logging Framework: Used for logging informational, debug, and error messages.</li>
 * </ul>
 * 
 * @author 
 * Publius Pseudis
 */
public final class VPNConnection implements NetworkProtocolHandler, AutoCloseable {
    /**
     * Unique identifier for this VPN node.
     * Used to distinguish between different nodes within the P2P network.
     */
    private final byte[] nodeId; // Unique ID for the node

    /**
     * Instance of {@link ProofOfWork} used to validate network activities.
     * Ensures that peers perform computational work to prevent spam or malicious behavior.
     */
    private final ProofOfWork pow; // Proof of Work instance

    /**
     * Atomic flag indicating whether the listener thread is actively processing incoming packets.
     * Ensures thread-safe updates to the listener's active state.
     */
    private final AtomicBoolean listenerActive = new AtomicBoolean(false);

    /**
     * Latch used to signal when the listener thread is ready to receive packets.
     * Ensures that initialization processes wait until the listener is fully operational.
     */
    private final CountDownLatch listenerReady = new CountDownLatch(1);
    
    /**
     * Sets the connection handler responsible for managing new peer connections.
     *
     * @param handler The {@link P2PNetwork.ConnectionHandler} instance to handle new connections.
     */
    public void setConnectionHandler(P2PNetwork.ConnectionHandler handler) {
        this.connectionHandler = handler;
    }
    
    /**
     * Retrieves the current phase of the VPN connection.
     *
     * @return The current {@link ConnectionPhase} of the connection.
     */
    public ConnectionPhase getCurrentPhase() {
        return currentPhase;
    }
    /**
     * Checks whether the VPN connection is currently running.
     *
     * @return {@code true} if the connection is running; {@code false} otherwise.
     */
    public boolean isRunning() {
        return running;
    }

    /**
     * Sets the running state of the VPN connection.
     *
     * @param running {@code true} to mark the connection as running; {@code false} to stop it.
     */
    public void setRunning(boolean running) {
        this.running = running;
    }
    
    // =====================
    // Fields
    // =====================

    /**
     * Handles incoming peer connections by implementing the {@link P2PNetwork.ConnectionHandler} interface.
     * This handler manages the logic for establishing and maintaining connections with new peers.
     */
    private P2PNetwork.ConnectionHandler connectionHandler;
    
    /**
     * Represents the current phase of the VPN connection lifecycle.
     * Initialized to {@link ConnectionPhase#INITIAL}.
     */
    private volatile ConnectionPhase currentPhase = ConnectionPhase.INITIAL;
    
    /**
     * The thread responsible for listening to incoming VPN messages.
     * Runs concurrently to handle network communication without blocking the main thread.
     */    
    private volatile Thread listenerThread;
    
    /**
     * Logger instance from SLF4J for logging informational, debug, and error messages.
     * Utilized throughout the class to trace execution flow and record significant events.
     */
    private static final Logger log = LoggerFactory.getLogger(VPNConnection.class);
    
    // =====================
    // Message Types
    // =====================

     /**
     * Message type identifier for echo request messages.
     * Used during connectivity tests to verify UDP communication between peers.
     */
    public static final byte ECHO_REQUEST = 0x01;

    /**
     * Message type identifier for echo response messages.
     * Sent in reply to {@code ECHO_REQUEST} messages to confirm successful UDP communication.
     */
    public static final byte ECHO_RESPONSE = 0x2;

    
    
    /**
     * Message type identifier for data packets.
     * Used to distinguish data payloads from other message types in the VPN communication protocol.
     */
    public static final byte MSG_TYPE_DATA = 0x01;     // Data packet
    
    /**
     * Message type identifier for gossip messages.
     * Facilitates peer list updates and dissemination of network information among peers.
     */
    public static final byte MSG_TYPE_GOSSIP = 0x02;   // Peer list update
    
    /**
     * Message type identifier for proofs of work.
     * Used to validate network activities and prevent spam or malicious behavior.
     */
    public static final byte MSG_TYPE_PROOF = 0x03;    // Proof of work
    
    /**
     * Message type identifier for peer information.
     * Carries metadata about peers, such as public keys and connection details.
     */
    public static final byte MSG_TYPE_PEER_INFO = 0x04;// Peer information
    
    /**
     * Message type identifier for keepalive pings.
     * Ensures the connection remains active and detects stale or disconnected peers.
     */
    public static final byte MSG_TYPE_PING = 0x05;     // Keepalive ping
    
    /**
     * Special message type identifier for echo tests.
     * Utilized during connectivity tests to verify UDP communication between peers.
     */
    private static final byte MSG_TYPE_ECHO = 0x06;  // Special test message type
    public static final byte MSG_TYPE_VERIFY = 0x07;  // Verification request
    // =====================
    // Network Constants
    // =====================
    
    /**
     * Default VPN port number, aligning with WireGuard's standard port.
     * Serves as the primary port for establishing VPN connections.
     */    
    public static final int VPN_PORT = 51820;          // Default VPN port (same as WireGuard)
    
    /**
     * Duration in milliseconds before a socket operation times out.
     * Determines how long the socket waits for data before throwing a {@link SocketTimeoutException}.
     */
    private static final int SOCKET_TIMEOUT = 5000;    // 5 second socket timeout
    
    /**
     * Maximum allowable size for a UDP packet in bytes.
     * Ensures that packets do not exceed network transmission limits.
     */
    private static final int MAX_PACKET_SIZE = 65536;  // Maximum UDP packet size
    
    /**
     * Size of the buffer used for reading incoming UDP packets.
     * Balances memory usage and the ability to handle large packets.
     */
    private static final int BUFFER_SIZE = 16384;      // Read buffer size
    
    
    /**
     * Mapping of message type identifiers to their corresponding human-readable names.
     * Facilitates logging and debugging by providing meaningful names for message types.
     */
    private final Map<Byte, String> MESSAGE_TYPE_NAMES = new HashMap<>() {{
        put(MSG_TYPE_DATA, "DATA");
        put(MSG_TYPE_GOSSIP, "GOSSIP");
        put(MSG_TYPE_PROOF, "PROOF");
        put(MSG_TYPE_PEER_INFO, "PEER_INFO");
        put(MSG_TYPE_PING, "PING");
        put(MSG_TYPE_ECHO, "ECHO");
        put(MSG_TYPE_VERIFY, "VERIFY");
    }};


    
    
    // =====================
    // Connection Components
    // =====================
    
    /**
     * UDP socket used for sending and receiving VPN traffic.
     * Facilitates low-latency, connectionless communication between peers.
     */
    private  DatagramSocket socket = null;

    /**
     * Instance of {@link SecureChannel} managing encryption and decryption of messages.
     * Ensures that all transmitted data remains confidential and tamper-proof.
     */
    private final SecureChannel crypto;
    
    /**
     * Address of the connected peer, encapsulating both hostname/IP and port number.
     * Represents the remote endpoint for VPN communication.
     */
    private InetSocketAddress peerAddress;
    
    /**
     * Indicates whether the VPN connection is currently active and operational.
     * Controls the execution of listener threads and network operations.
     */
    private volatile boolean running;
    
    // =====================
    // Statistics
    // =====================
    
    /**
     * Atomic counter tracking the total number of bytes sent over the VPN connection.
     * Provides a thread-safe mechanism for accumulating sent data statistics.
     */    
    private final AtomicLong bytesSent;
    
    /**
     * Atomic counter tracking the total number of bytes received over the VPN connection.
     * Ensures accurate and thread-safe aggregation of incoming data statistics.
     */
    private final AtomicLong bytesReceived;
    
    /**
     * The most recent latency measurement of the VPN connection in milliseconds.
     * Reflects the time taken for data to travel between peers.
     */
    private volatile double lastLatency;

    /**
     * The latest estimated bandwidth of the VPN connection in bytes per second.
     * Calculated based on recent data transmission rates.
     */
    private volatile long lastBandwidthEstimate;

    /**
     * Timestamp marking the last reset of statistical counters.
     * Used to calculate bandwidth estimates over defined intervals.
     */
    private long lastStatsReset;
    
    /**
     * Instance of {@link GossipMessage} handling gossip protocol messages.
     * Manages peer discovery and dissemination of network state information.
     */
    private GossipMessage gossipHandler;

    // =====================
    // Connection State
    // =====================

    /**
     * Timestamp of the last received UDP packet in milliseconds.
     * Used to determine if the connection has become stale due to inactivity.
     */
    private volatile long lastReceivedTime;

    /**
     * Indicates whether the initial handshake with the peer has been successfully completed.
     * Determines if the secure channel is established and ready for data transmission.
     */
    private volatile boolean handshakeCompleted;

    /**
     * Threshold in milliseconds to consider a VPN connection as stale.
     * If the time since the last received packet exceeds this value, the connection is deemed inactive.
     */
    private static final long STALE_THRESHOLD = 30000; // 30 seconds

    /**
     * Flag indicating whether this {@code VPNConnection} instance is operating in server mode.
     * Controls behaviors specific to server-side operations, such as listening for incoming connections.
     */
    private final boolean isServer;

    /**
     * The last received UDP packet stored for processing.
     * Utilized during handshake and connection establishment phases.
     */
    private DatagramPacket lastReceivedPacket = null;

    // =====================
    // Constructors and Methods
    // =====================
        
    /**
     * Establishes a connection to a specified peer within the P2P VPN network.
     *
     * @param bindAddress
     * @param port  The port number on which the peer is listening.
     * @param isInitiator  Indicates whether the connection is being established as a server.
     * @param nodeId node id
     * @param pow instance of proof of work
     * @throws java.lang.Exception If an error occurs while attempting to connect to the peer.
     */
    public VPNConnection(String bindAddress, int port, boolean isInitiator, byte[] nodeId, ProofOfWork pow) throws Exception {
        if (nodeId == null) {
            throw new IllegalArgumentException("nodeId cannot be null");
        }
        this.nodeId = nodeId;
        this.pow = (pow != null) ? pow : new ProofOfWork(nodeId);
        this.isServer = isInitiator;
        setRunning(true);
        this.currentPhase = ConnectionPhase.INITIAL;

        // Initialize crypto and metrics first
        this.crypto = new SecureChannel();
        this.bytesSent = new AtomicLong(0);
        this.bytesReceived = new AtomicLong(0);
        this.lastLatency = Double.MAX_VALUE;
        this.lastBandwidthEstimate = 0;
        this.lastStatsReset = System.currentTimeMillis();
        this.lastReceivedTime = System.currentTimeMillis();

        try {
            // Create socket
            this.socket = new DatagramSocket(null);
            this.socket.setReuseAddress(true);
            this.socket.setSoTimeout(isServer ? SOCKET_TIMEOUT : 1000);

            // Set up socket options
            try {
                this.socket.setTrafficClass(0x2E);
                this.socket.setReceiveBufferSize(BUFFER_SIZE);
                this.socket.setSendBufferSize(BUFFER_SIZE);
            } catch (SocketException e) {
                log.warn("Could not set socket performance parameters: {}", e.getMessage());
            }

            // If we're a client connecting to a peer, use our own port for binding
            if (!isInitiator) {
                // Store peer address for later use
                this.peerAddress = new InetSocketAddress(bindAddress, port);

                // For the client, bind to any available port
                InetSocketAddress bindAddr = new InetSocketAddress(
                    "0.0.0.0",  // Bind to all interfaces
                    0  // Let the system assign an available port
                );

                log.info("Client binding to {}", bindAddr);
                this.socket.bind(bindAddr);
                log.info("Client assigned port: {}", socket.getLocalPort());

                // Perform connection steps
                testUDPSocket();
                echoTest();
                performHandshake();
            } else {
                // Server mode - bind to specified port
                InetSocketAddress bindAddr = new InetSocketAddress(
                    "0.0.0.0",  // Bind to all interfaces
                    port
                );

                log.info("Server binding to {}", bindAddr);
                this.socket.bind(bindAddr);

                testUDPSocket();
                startServerListener();
            }

            log.debug("Set socket buffer sizes: send={}, receive={}",
                socket.getSendBufferSize(), socket.getReceiveBufferSize());

        } catch (Exception e) {
            log.error("VPNConnection initialization failed: {}", e.getMessage(), e);
            setRunning(false);
            if (socket != null) {
                socket.close();
            }
            throw e;
        }
    }
    
    /**
    * Performs a basic test of the UDP socket by sending a test packet if acting as a client
    * and logs the socket's configuration details.
    *
    * <p>
    * This method is used during initialization to ensure that the socket is properly bound
    * and capable of sending packets. It sends a test packet to the peer if the connection
    * is not in server mode.
    * </p>
    */
    private void testUDPSocket() {
        try {
            String msg = isServer ? "Server socket test" : "Client socket test";
            log.info("{}: Local port={}, Bound={}, Connected={}, Address={}",  
                msg,
                socket.getLocalPort(),
                socket.isBound(),
                socket.isConnected(),
                socket.getLocalAddress());

            if (!isServer && peerAddress != null) {
                // Simple UDP test packet
                byte[] test = new byte[] {1,2,3,4};
                DatagramPacket packet = new DatagramPacket(test, test.length, peerAddress);
                socket.send(packet);
                log.info("Sent test packet to {}", peerAddress);
            }
        } catch (IOException e) {
            log.error("Socket test failed: {}", e.getMessage());
        }
    }
     /**
     * Sets the socket timeout duration.
     *
     * @param timeout The timeout duration in milliseconds.
     * @throws SocketException If an error occurs while setting the socket timeout.
     */
    public void setTimeout(int timeout) throws SocketException {
        if (socket != null) {
            socket.setSoTimeout(timeout);
        }
    }

    /**
     * Initializes and starts the server listener thread to handle incoming UDP packets.
     *
     * <p>
     * This method sets up a dedicated listener thread that continuously listens for incoming
     * UDP packets from peers. It processes different message types based on the current connection
     * phase and delegates handling to appropriate methods.
     * </p>
     *
     * @throws IOException If an error occurs while binding the socket or starting the listener.
     */
    private void startServerListener() throws IOException {
        if (!isServer) return;

        listenerThread = new Thread(() -> {
            log.debug("[UDP-Listener] Server listener starting on port {}", socket.getLocalPort());
            listenerActive.set(true);
            byte[] buffer = new byte[MAX_PACKET_SIZE];
            DatagramPacket packet = new DatagramPacket(buffer, buffer.length);

            try {
                // Signal that we're ready to receive
                listenerReady.countDown();

                while (running && listenerActive.get()) {
                    try {
                        socket.receive(packet);

                        if (packet.getLength() > 0) {
                            ByteBuffer msg = ByteBuffer.wrap(packet.getData(), 0, packet.getLength());
                            byte type = msg.get();

                            log.debug("[UDP-Listener] Received message type {} size {} from {}", 
                                type, packet.getLength(), packet.getSocketAddress());

                            // Handle verification request immediately
                            if (type == 0x01) {
                                handleFirstMessage(packet);
                                continue;
                            }

                            // Handle echo requests immediately regardless of state
                            if (type == MSG_TYPE_ECHO) {
                                handleEchoPacket(packet);
                                continue;
                            }

                            // Check for connection from new peer
                            if (!packet.getSocketAddress().equals(peerAddress)) {
                                log.debug("[UDP-Listener] New peer connection from: {}", packet.getSocketAddress());
                                currentPhase = ConnectionPhase.INITIAL;
                                peerAddress = null;  // Clear existing peer
                            }

                            handleBasedOnPhase(packet, msg, type);
                        }

                    } catch (SocketTimeoutException e) {
                        // Normal timeout, continue
                    } catch (IOException e) {
                        if (running && listenerActive.get()) {
                            log.error("[UDP-Listener] Error in server listener: {}", e.getMessage());
                        }
                    }
                }
            } finally {
                listenerActive.set(false);
            }
                log.debug("[UDP-Listener] Server listener stopped cleanly");
            }, "UDP-Listener");

        listenerThread.setDaemon(true);
        listenerThread.start();

        // Wait for listener to be ready
        try {
            if (!listenerReady.await(5, TimeUnit.SECONDS)) {
                throw new IOException("UDP listener failed to initialize");
            }
            log.info("Server listener started on port {}", socket.getLocalPort());
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException("Interrupted while waiting for listener to start", e);
        }
    }

    /**
     * Processes an incoming echo packet by sending an appropriate echo response.
     *
     * <p>
     * This method handles {@code ECHO_REQUEST} messages by extracting the random data payload
     * and sending back an {@code ECHO_RESPONSE} with the same data. It ensures that echo
     * tests confirm successful UDP communication between peers.
     * </p>
     *
     * @param packet The received {@link DatagramPacket} containing the echo request.
     * @throws IOException If an error occurs while sending the echo response.
     */
    private void handleEchoPacket(DatagramPacket packet) throws IOException {
        if (packet.getLength() < 2) {
            log.debug("Echo packet too short, ignoring");
            return;
        }

        log.debug("Handling echo packet from {}, length: {}", 
            packet.getSocketAddress(), packet.getLength());

        ByteBuffer msg = ByteBuffer.wrap(packet.getData(), 0, packet.getLength());
        byte type = msg.get();
        byte subtype = msg.get();

        log.debug("Echo packet type: {}, subtype: {}", type, subtype);

        if (type == MSG_TYPE_ECHO && subtype == ECHO_REQUEST) {
            // Copy just the random data portion
            byte[] randomData = new byte[msg.remaining()];
            msg.get(randomData);

            ByteBuffer response = ByteBuffer.allocate(randomData.length + 2);
            response.put(MSG_TYPE_ECHO);
            response.put(ECHO_RESPONSE);  // Make sure this is 0x02
            response.put(randomData);
            response.flip();

            log.debug("Sending echo response with {} bytes of random data to {}", 
                randomData.length, packet.getSocketAddress());

            DatagramPacket responsePacket = new DatagramPacket(
                response.array(),
                response.limit(),
                packet.getAddress(),
                packet.getPort()
            );
            socket.send(responsePacket);
        } else {
            log.debug("Ignoring non-request echo packet (type: {}, subtype: {})", 
                type, subtype);
        }
    }



     /**
     * Performs the server-side handshake by exchanging public keys and establishing a secure channel.
     *
     * @throws Exception If an error occurs during the handshake process.
     */
    public void performServerHandshake() throws Exception {
        log.debug("[UDP-Listener] Starting server handshake with peer: {}", peerAddress);

        try {
            // Get stored peer key from raw message
            ByteBuffer msg = ByteBuffer.wrap(lastReceivedPacket.getData(), 0, lastReceivedPacket.getLength());
            msg.get();  // Skip type byte
            byte[] peerKey = new byte[msg.remaining()];
            msg.get(peerKey);
            lastReceivedPacket = null;

            log.debug("[UDP-Listener] Using peer's public key, length: {}", peerKey.length);

            // Send our public key unencrypted
            byte[] publicKey = crypto.getPublicKey();
            log.debug("[UDP-Listener] Sending our public key, length: {}", publicKey.length);
            sendMessage(MSG_TYPE_PEER_INFO, publicKey);

            // Establish secure channel
            crypto.establishSecureChannel(peerKey);

            // Send acknowledgment
            log.debug("[UDP-Listener] Sending handshake acknowledgment");
            ByteBuffer ack = ByteBuffer.allocate(1);
            ack.put((byte)1);
            ack.flip();
            sendMessage(MSG_TYPE_PEER_INFO, ack.array());

            // Mark handshake as complete
            handshakeCompleted = crypto.isEstablished();

            currentPhase = ConnectionPhase.NETWORK_HANDSHAKE_COMPLETE;
            log.info("[UDP-Listener] Secure channel established with {}", peerAddress);

        } catch (IOException e) {
            handshakeCompleted = false;
            log.error("[UDP-Listener] Server handshake failed: {}", e.getMessage());
            throw e;
        }
    }
    
    /**
     * Performs an echo test to verify UDP connectivity by sending and receiving an echo packet.
     *
     * @throws IOException If the echo test fails due to no response or network issues.
     */
 
private void echoTest() throws IOException, InterruptedException {
    if (isServer || handshakeCompleted) return;

    // Create echo request with random data
    byte[] randomData = new byte[8];
    new SecureRandom().nextBytes(randomData);
    
    // Add echo message type byte and request subtype
    ByteBuffer message = ByteBuffer.allocate(10);
    message.put(MSG_TYPE_ECHO);
    message.put(ECHO_REQUEST);
    message.put(randomData);
    message.flip();

    byte[] requestPacket = message.array();
    DatagramPacket packet = new DatagramPacket(
        requestPacket, 
        requestPacket.length, 
        peerAddress
    );

    int maxAttempts = 3;
    int attemptDelay = 1000; // 1 second between attempts

    for (int attempt = 1; attempt <= maxAttempts; attempt++) {
        try {
            log.debug("Client sending echo test to {} (attempt {}/{})", 
                peerAddress, attempt, maxAttempts);
            
            socket.send(packet);

            // Create receive packet
            // Wait for response
            byte[] responseData = new byte[requestPacket.length];
            DatagramPacket responsePacket = new DatagramPacket(
                responseData, 
                responseData.length,
                peerAddress.getAddress(),
                peerAddress.getPort()
            );

            socket.setSoTimeout(1000);

            // Keep reading until we get a valid echo response or timeout
            long endTime = System.currentTimeMillis() + 1000;  // 1 second total time
            while (System.currentTimeMillis() < endTime) {
                socket.receive(responsePacket);
                
                // Skip if not an echo message
                if (responsePacket.getLength() < 2) {
                    continue;
                }

                if (responseData[0] != MSG_TYPE_ECHO) {
                    log.debug("Received non-echo message (type: {}), skipping", responseData[0]);
                    continue;
                }

                if (responseData[1] != ECHO_RESPONSE) {
                    log.debug("Received non-response echo message (subtype: {}), skipping", responseData[1]);
                    continue;
                }

                // Compare just the random data portion
                byte[] receivedRandomData = Arrays.copyOfRange(responseData, 2, responseData.length);
                byte[] sentRandomData = Arrays.copyOfRange(requestPacket, 2, requestPacket.length);
                
                if (Arrays.equals(receivedRandomData, sentRandomData)) {
                    log.debug("Received valid echo response from {}", 
                        responsePacket.getSocketAddress());
                    return; // Success
                } else {
                    log.debug("Received echo response with mismatched data");
                }
            }
            
            // If we get here, we timed out without finding a valid response
            if (attempt == maxAttempts) {
                throw new IOException("Echo response validation failed after exhausting retries");
            }
            log.debug("Echo test attempt {} timed out, retrying...", attempt);
            Thread.sleep(attemptDelay);
            
        } catch (SocketTimeoutException e) {
            if (attempt == maxAttempts) {
                throw new IOException("UDP connectivity test failed - server not responding after " + 
                    maxAttempts + " attempts");
            }
            log.debug("Echo test attempt {} failed, retrying...", attempt);
            Thread.sleep(attemptDelay);
        }
    }
}
    /**
     * Stores the received UDP packet for later processing.
     *
     * @param packet The received {@link DatagramPacket} to be stored.
    */
    private synchronized void storePacket(DatagramPacket packet) {
        // Make a copy of the packet data
        byte[] data = new byte[packet.getLength()];
        System.arraycopy(packet.getData(), packet.getOffset(), data, 0, packet.getLength());
        
        lastReceivedPacket = new DatagramPacket(data, data.length);
        lastReceivedPacket.setSocketAddress(packet.getSocketAddress());
        log.debug("Stored packet from {}", packet.getSocketAddress());
    }
    


    /**
     * Constructs a new {@code VPNConnection} instance with specified nodeId.
     *
     * @param peerHost The hostname or IP address of the peer to connect to.
     * @param peerPort The port number of the peer to connect to.
     * @param isServer A flag indicating whether this is a server instance.
     * @param nodeId The node ID to use for this connection.
     * @throws Exception If an error occurs during initialization.
     */
    public VPNConnection(String peerHost, int peerPort, boolean isServer, byte[] nodeId) throws Exception {
        this(peerHost, peerPort, isServer, nodeId, new ProofOfWork(nodeId));
    }

    /**
     * Sets the gossip handler responsible for processing gossip protocol messages.
     *
     * @param handler The {@link GossipMessage.GossipHandler} instance to handle gossip messages.
     */
    public synchronized void setGossipHandler(GossipMessage.GossipHandler handler) {
        if (this.gossipHandler == null) {
            this.gossipHandler = new GossipMessage();
        }
        this.gossipHandler.setHandler(handler);
    }
    
    /**
    * Handles incoming packets based on the current connection phase.
    *
    * <p>
    * Depending on the {@code currentPhase}, this method delegates packet processing to
    * appropriate handlers. It manages state transitions and ensures that messages are
    * processed according to the connection's lifecycle.
    * </p>
    *
    * @param packet The received {@link DatagramPacket}.
    * @param msg    The {@link ByteBuffer} containing the packet's data.
    * @param type   The type identifier of the received message.
    */
    private void handleBasedOnPhase(DatagramPacket packet, ByteBuffer msg, byte type) {
        try {
            switch (currentPhase) {
                case INITIAL, UDP_VERIFIED -> {
                    if (type == MSG_TYPE_PEER_INFO) {
                        peerAddress = (InetSocketAddress) packet.getSocketAddress();
                        log.debug("[UDP-Listener] Processing peer info from: {}", packet.getSocketAddress());
                        storePacket(packet);
                        performServerHandshake();
                        currentPhase = ConnectionPhase.SECURE_CHANNEL_ESTABLISHED;
                        if (connectionHandler != null) {
                            connectionHandler.onNewConnection(
                                peerAddress.getHostString(), 
                                peerAddress.getPort(), 
                                this
                            );
                        }
                    }
                }
                case SECURE_CHANNEL_ESTABLISHED, NETWORK_HANDSHAKE_COMPLETE -> {
                    if (crypto.isEstablished()) {
                        log.debug("[UDP-Listener] Processing established channel message type {} from {}", 
                            type, packet.getSocketAddress());
                        handleControlMessage(type, msg);
                    } else {
                        log.warn("[UDP-Listener] Received message type {} but channel not established", type);
                    }
                }
            }
        } catch (Exception e) {
            log.error("[UDP-Listener] Error in phase handler: {}", e.getMessage(), e);
        }
    }
    
    /**
     * Processes the first message received from a new peer to initiate the handshake process.
     *
     * <p>
     * This method extracts the requesting node's ID from the incoming message and responds
     * with a verification response containing the local node's ID and a timestamp. It also
     * updates the connection phase based on the reception of peer information.
     * </p>
     *
     * @param packet The received {@link DatagramPacket} containing the verification request.
     * @throws SocketException If an error occurs while handling the verification response.
     */
    private void handleFirstMessage(DatagramPacket packet) throws SocketException {
       try {
           ByteBuffer message = ByteBuffer.wrap(packet.getData(), 0, packet.getLength());
           byte type = message.get();

           log.debug("Received first message type: {}, size: {}, raw data: {}", 
               type, packet.getLength(), bytesToHex(Arrays.copyOf(packet.getData(), packet.getLength())));

           // Handle verification request
           if (type == 0x01) {
               // Check minimum message length (1 byte type + nodeId length)
               if (packet.getLength() < 1 + nodeId.length) {
                   log.warn("Message too short for verification request: {} bytes", packet.getLength());
                   return;
               }

               // Extract requesting node's ID
               byte[] requestNodeId = new byte[nodeId.length];
               if (message.remaining() < nodeId.length) {
                   log.warn("Incomplete node ID in verification request");
                   return;
               }
               message.get(requestNodeId);

               log.debug("Received verification request from {} with nodeId: {}", 
                   packet.getSocketAddress(), bytesToHex(requestNodeId));

               // Get our current proof and timestamp
               byte[] currentProof = pow.getCurrentProof();
               long timestamp = pow.getTimestamp();

               log.debug("Current proof: {}, timestamp: {}", 
                   bytesToHex(currentProof), timestamp);

               // Create verification response
               ByteBuffer response = ByteBuffer.allocate(nodeId.length + 8);
               response.put(nodeId);
               response.putLong(timestamp);
               response.flip();

               log.debug("Created verification response: nodeId {}, timestamp {}, total size {}",
                   bytesToHex(nodeId), timestamp, response.limit());

               // Send response
               DatagramPacket responsePacket = new DatagramPacket(
                   response.array(),
                   response.limit(),
                   packet.getAddress(),
                   packet.getPort()
               );

               // Log the exact bytes being sent
               log.debug("Sending response packet with raw data: {}", 
                   bytesToHex(Arrays.copyOf(response.array(), response.limit())));

               try {
                   socket.send(responsePacket);
                   log.debug("Successfully sent verification response");
               } catch (IOException e) {
                   log.error("Failed to send verification response: {}", e.getMessage(), e);
                   throw e;
               }
           }

           if (isServer && peerAddress == null) {
               peerAddress = (InetSocketAddress) packet.getSocketAddress();
               log.debug("Server connected to peer: {}", peerAddress);
           }
       } catch (IOException | IllegalStateException e) {
           log.error("Error handling first message: {}", e.getMessage(), e);
           throw new SocketException("Failed to handle first message: " + e.getMessage());
       }
   }

    /**
     * Converts an array of bytes into its corresponding hexadecimal string representation.
     *
     * <p>
     * This utility method is useful for logging binary data in a human-readable hexadecimal format,
     * aiding in debugging and monitoring network messages.
     * </p>
     *
     * @param bytes The array of bytes to convert.
     * @return A {@code String} representing the hexadecimal values of the input bytes.
     */
    private static String bytesToHex(byte[] bytes) {
        StringBuilder hex = new StringBuilder();
        for (byte b : bytes) {
            hex.append(String.format("%02x", b));
        }
        return hex.toString();
    }
    
    /**
     * Performs a secure handshake with the connected peer by exchanging public keys and establishing a secure channel.
     *
     * @throws Exception If an error occurs during the handshake process.
     */
    private void performHandshake() throws Exception {
        log.debug("Starting handshake with peer: {}", peerAddress);

        try {
            // Send our public key unencrypted
            byte[] publicKey = crypto.getPublicKey();
            log.debug("Sending public key, length: {}", publicKey.length);
            sendMessage(MSG_TYPE_PEER_INFO, publicKey);

            // Wait for peer's public key
            log.debug("Waiting for peer's public key...");
            byte[] peerKey = receivePeerInfo();
            if (peerKey == null) {
                throw new IOException("Failed to receive peer's public key");
            }
            log.debug("Received peer's public key, length: {}", peerKey.length);

            // Establish secure channel
            crypto.establishSecureChannel(peerKey);

            // Wait for server's acknowledgment
            log.debug("Waiting for handshake acknowledgment");
            byte[] ack = receiveMessage();
            if (ack == null || ack.length != 1 || ack[0] != 1) {
                throw new IOException("Invalid handshake acknowledgment");
            }

            // Mark handshake as complete
            handshakeCompleted = crypto.isEstablished();

            // Send our info after handshake
            ByteBuffer info = ByteBuffer.allocate(32);  // Use fixed size for peer info
            info.putInt(4); // Version
            info.putLong(System.currentTimeMillis());
            info.flip();
            sendMessage(MSG_TYPE_PEER_INFO, info.array());

            // Send our proof
            ByteBuffer proof = ByteBuffer.allocate(40);  // Use fixed size for proof
            proof.putInt(1); // Proof version
            proof.putLong(System.currentTimeMillis());
            proof.flip();
            sendMessage(MSG_TYPE_PROOF, proof.array());

            log.info("Secure channel established with {}", peerAddress);
            currentPhase = ConnectionPhase.NETWORK_HANDSHAKE_COMPLETE;

        } catch (IOException e) {
            handshakeCompleted = false;
            throw new IOException("Handshake failed: " + e.getMessage(), e);
        }
    }
    
    /**
     * Sends a VPN data packet to the connected peer.
     *
     * @param data The plaintext data to be sent.
     * @throws IOException If an error occurs during sending.
     */
    public void sendPacket(byte[] data) throws IOException {
       if (!running) {
           return;
       }

       try {
           log.debug("Sending VPN packet of size {}", data.length);

           // Create message with type header and encrypt
           byte[] encrypted = crypto.encryptMessage(data);
           ByteBuffer message = ByteBuffer.allocate(1 + encrypted.length);
           message.put(MSG_TYPE_DATA);
           message.put(encrypted);
           message.flip();

           // Send via UDP
           DatagramPacket packet = new DatagramPacket(
               message.array(), 
               message.position(), 
               message.limit(), 
               peerAddress
           );
           socket.send(packet);
           log.debug("Sent encrypted VPN packet size {}", packet.getLength());

       } catch (Exception e) {
           log.error("Failed to send VPN packet: {}", e.getMessage());
           throw new IOException("Failed to send packet", e);
       }
   }
    
    /**
     * Receives a VPN data packet from the connected peer.
     *
     * @return The decrypted plaintext data received, or {@code null} if no data is received.
     * @throws IOException If an error occurs during receiving or decryption.
     */
    public byte[] receivePacket() throws IOException {
        if (!running) {
            return null;
        }

        byte[] buffer = new byte[MAX_PACKET_SIZE];
        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);

        try {
            log.debug("Waiting for VPN packet");
            socket.receive(packet);
            lastReceivedTime = System.currentTimeMillis();

            ByteBuffer message = ByteBuffer.wrap(packet.getData(), 0, packet.getLength());
            byte type = message.get();

            switch (type) {
                case MSG_TYPE_DATA -> {
                    byte[] encrypted = new byte[message.remaining()];
                    message.get(encrypted);
                    byte[] decrypted = crypto.decryptMessage(encrypted);
                    log.debug("Received encrypted VPN packet size {}, decrypted size {}",
                            encrypted.length, decrypted.length);
                    return decrypted;
                }

                case MSG_TYPE_PING -> {
                    sendMessage(MSG_TYPE_PING, new byte[0]);
                    return null;
                }

                case MSG_TYPE_GOSSIP, MSG_TYPE_PROOF, MSG_TYPE_PEER_INFO -> {
                    handleControlMessage(type, message);
                    return null;
                }
                default -> {
                    log.warn("Unknown message type: {}", type);
                    return null;
                }
            }
        } catch (SocketTimeoutException e) {
            return null;
        } catch (Exception e) {
            throw new IOException("Failed to receive packet", e);
        }
    }

    /**
     * Processes control messages such as gossip, proof of work, and peer information.
     *
     * <p>
     * Depending on the message type, this method delegates processing to the appropriate
     * handlers. It ensures that control messages are handled securely and correctly,
     * maintaining the integrity of the VPN connection.
     * </p>
     *
     * @param type    The type identifier of the received control message.
     * @param message The {@link ByteBuffer} containing the message data.
     * @throws IOException If an error occurs during message processing.
     */
    private void handleControlMessage(byte type, ByteBuffer message) {    
        try {
            byte[] data = new byte[message.remaining()];
            message.get(data);

            switch (type) {
                case MSG_TYPE_PING -> {
                    // Never encrypt pings
                    log.debug("Received ping, sending response");
                    sendMessage(MSG_TYPE_PING, new byte[]{});
                }
                case MSG_TYPE_GOSSIP, MSG_TYPE_PROOF, MSG_TYPE_PEER_INFO -> {
                    // Only try to decrypt if both secure channel and handshake complete
                    if (crypto.isEstablished() && handshakeCompleted) {
                        try {
                            data = crypto.decryptMessage(data);
                        } catch (Exception e) {
                            log.debug("Received unencrypted control message type {} size {}", type, data.length);
                        }
                    }

                    GossipMessage localHandler;
                    synchronized(this) {
                        localHandler = this.gossipHandler;
                    }

                    if (localHandler != null) {
                        localHandler.processMessage(type, data);
                    }
                }
                default -> log.warn("Unknown message type: {}", type);
            }

        } catch (IOException e) {
            log.error("Error handling control message of type {} and size {}: {} ({})", 
                type, message.remaining(), e.getMessage(), e.getClass().getName(), e);
        }
    }
    
    /**
     * Sends a control message to the connected peer.
     *
     * @param type The type of the message to send.
     * @param data The data payload of the message.
     * @throws IOException If an error occurs during sending.
     */
    @Override
    public void sendMessage(byte type, byte[] data)  throws IOException {
        if (!isRunning()) {
            return;
        }

        try {
            byte[] messageData;

            // Don't encrypt pings or messages during handshake
            if (type == MSG_TYPE_PING || !handshakeCompleted) {
                messageData = data;
            } else {
                // Only encrypt if secure channel established
                if (crypto.isEstablished()) {
                    messageData = crypto.encryptMessage(data);
                } else {
                    messageData = data;
                }
            }

            ByteBuffer message = ByteBuffer.allocate(1 + messageData.length);
            message.put(type);
            message.put(messageData);
            message.flip();

            DatagramPacket packet = new DatagramPacket(message.array(), message.limit(), peerAddress);
            socket.send(packet);
            log.debug("Sent {} bytes type {} to {}", message.limit(), type, peerAddress);
            updateLastSeen();
        } catch (Exception e) {
            throw new IOException("Failed to send message", e);
        }
    }

    
    /**
     * Sends a gossip message to the connected peer.
     *
     * @param gossip The {@link GossipMessage} instance containing gossip information.
     * @throws IOException If an error occurs during sending.
     */
    public void sendGossip(GossipMessage gossip) throws IOException {
        sendMessage(MSG_TYPE_GOSSIP, gossip.serialize());
    }
    
    /**
     * Sends a proof of work message to the connected peer.
     *
     * @param proof     The proof of work data.
     * @param timestamp The timestamp associated with the proof.
     * @throws IOException If an error occurs during sending.
     */
    public void sendProof(byte[] proof, long timestamp) throws IOException {
        ByteBuffer buffer = ByteBuffer.allocate(proof.length + 8);
        buffer.put(proof);
        buffer.putLong(timestamp);
        sendMessage(MSG_TYPE_PROOF, buffer.array());
    }
    
    /**
     * Receives a raw message from the connected peer.
     *
     * @return The data payload of the received message, or {@code null} if no message is received.
     * @throws IOException If an error occurs during receiving.
     */
private byte[] receiveMessage() throws IOException {
    byte[] buffer = new byte[MAX_PACKET_SIZE];
    DatagramPacket packet = new DatagramPacket(buffer, buffer.length);

    try {
        log.debug("Waiting to receive message on port {} from {}", 
            socket.getLocalPort(),
            isServer ? "any" : peerAddress);

        while (running) {  // Loop until we get a non-echo message
            // Check if we have a stored packet first
            synchronized(this) {
                if (lastReceivedPacket != null) {
                    packet = lastReceivedPacket;
                    lastReceivedPacket = null;
                    log.debug("Using stored packet from {}", packet.getSocketAddress());
                } else {
                    socket.receive(packet);
                }
            }

            log.debug("Received {} bytes from {}", 
                packet.getLength(), 
                packet.getSocketAddress());
            lastReceivedTime = System.currentTimeMillis();

            ByteBuffer message = ByteBuffer.wrap(
                packet.getData(),
                packet.getOffset(),
                packet.getLength()
            );

            if (!message.hasRemaining()) {
                log.warn("Received empty packet");
                continue;
            }

            byte type = message.get();
            log.debug("Received message type: {} ({})", 
                MESSAGE_TYPE_NAMES.getOrDefault(type, "UNKNOWN"), type);

            // Handle echo requests immediately and continue listening
            if (type == MSG_TYPE_ECHO) {
                handleEchoPacket(packet);
                continue;  // Keep listening for non-echo messages
            }

            // For non-echo messages, return the data
            byte[] data = new byte[message.remaining()];
            message.get(data);
            return data;
        }

        throw new IOException("Connection closed while receiving message");

    } catch (IOException e) {
        if ("Connection closed by peer".equals(e.getMessage())) {
            setRunning(false);
            socket.close();
        }
        throw e;
    }
}


    

    /**
     * Verifies that the handshake has been completed successfully.
     *
     * @throws IOException If the secure channel has not been established.
     */
    private void verifyHandshake()  throws IOException {
        if (!handshakeCompleted) {
            throw new IOException("Secure channel not established");
        }
    }
    

    /**
     * Updates the connection latency.
     *
     * @param latency The new latency value in milliseconds.
     */
    public void updateLatency(double latency) {
        this.lastLatency = latency;
    }
    
    /**
     * Retrieves the current latency of the connection.
     *
     * @return The last recorded latency in milliseconds.
     */
    public double getLatency(){
        return lastLatency;
    }
    
    /**
     * Retrieves the current bandwidth estimate of the connection.
     *
     * @return The last estimated bandwidth in bytes per second.
     */
    public long getBandwidthEstimate() {
        long now = System.currentTimeMillis();
        long duration = now - lastStatsReset;
        
        if (duration > 0) {
            lastBandwidthEstimate = ((bytesSent.get() + bytesReceived.get()) * 1000) / duration;
            
            // Reset counters periodically
            if (duration > 60000) { // 1 minute
                bytesSent.set(0);
                bytesReceived.set(0);
                lastStatsReset = now;
            }
        }
        
        return lastBandwidthEstimate;
    }
    
    /**
     * Checks if the connection is stale based on the last received packet time.
     *
     * @return {@code true} if the connection is stale; {@code false} otherwise.
     */
    public boolean isStale() {
        return System.currentTimeMillis() - lastReceivedTime > STALE_THRESHOLD;
    }
    
    /**
     * Updates the timestamp of the last received packet to the current time.
     */
    public void updateLastSeen() {
        lastReceivedTime = System.currentTimeMillis();
    }
    
    /**
     * Closes the VPN connection, terminating all ongoing processes and releasing resources.
     *
     * @throws IOException If an error occurs during socket closure.
     */
    @Override
    public void close() throws IOException {
        setRunning(false);
        if (listenerThread != null) {
            listenerThread.interrupt();
        }
        socket.close();
    }
    
    /**
     * Returns a string representation of the {@code VPNConnection} instance, detailing the peer address,
     * latency, and bandwidth estimates.
     *
     * @return A {@code String} summarizing the VPN connection information.
     */
    @Override
    public String toString() {
        return String.format("VPNConnection[peer=%s, latency=%.1fms, bandwidth=%d B/s]",
            peerAddress, lastLatency, lastBandwidthEstimate);
    }
    
    /**
     * Receives peer information during the handshake process.
     *
     * @return A byte array containing the decrypted peer information.
     * @throws IOException If an error occurs during receiving or decryption.
     */
 public byte[] receivePeerInfo() throws IOException {
    byte[] buffer = new byte[MAX_PACKET_SIZE];
    DatagramPacket packet = new DatagramPacket(buffer, buffer.length);

    try {
        socket.receive(packet);
        lastReceivedTime = System.currentTimeMillis();

        ByteBuffer message = ByteBuffer.wrap(packet.getData(), 0, packet.getLength());
        byte type = message.get();

        // Handle echo requests during handshake
        if (type == MSG_TYPE_ECHO) {
            handleEchoPacket(packet);
            // After handling echo, try to receive peer info again
            return receivePeerInfo();
        }

        if (type != MSG_TYPE_PEER_INFO) {
            throw new IOException(String.format("Expected peer info message (%d), got: %d (%s)", 
                MSG_TYPE_PEER_INFO, type, 
                MESSAGE_TYPE_NAMES.getOrDefault(type, "UNKNOWN")));
        }

        byte[] data = new byte[message.remaining()];
        message.get(data);

        // Only try to decrypt if secure channel is established
        if (crypto.isEstablished()) {
            return crypto.decryptMessage(data);
        }
        return data;
    } catch (Exception e) {
        if (e instanceof IOException iOException) {
            throw iOException;
        }
        throw new IOException("Failed to receive peer info: " + e.getMessage(), e);
    }
}

    /**
     * Receives a proof of work message during the handshake process.
     *
     * @return A byte array containing the decrypted proof of work.
     * @throws IOException If an error occurs during receiving or decryption.
     */
    public byte[] receiveProof() throws IOException{
        byte[] buffer = new byte[MAX_PACKET_SIZE];
        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);

        socket.receive(packet);
        lastReceivedTime = System.currentTimeMillis();

        ByteBuffer message = ByteBuffer.wrap(packet.getData(), 0, packet.getLength());
        byte type = message.get();

        if (type != MSG_TYPE_PROOF) {
            throw new IOException("Expected proof message, got: " + type);
        }

        byte[] encryptedData = new byte[message.remaining()];
        message.get(encryptedData);

        try {
            return crypto.decryptMessage(encryptedData);
        } catch (Exception e) {
            throw new IOException("Failed to decrypt proof", e);
        }
    }
    
    /**
     * Handles incoming messages based on their type by delegating to appropriate handlers.
     *
     * @param type The type identifier of the received message.
     * @param data The data payload of the message.
     * @throws IOException If an error occurs during message handling.
     */
    @Override
    public void handleMessage(byte type, byte[] data) throws IOException {
        try {
            ByteBuffer message;
            if (type == MSG_TYPE_PEER_INFO || type == MSG_TYPE_ECHO || !crypto.isEstablished()) {
                message = ByteBuffer.wrap(data);
            } else {
                byte[] decrypted = crypto.decryptMessage(data);
                message = ByteBuffer.wrap(decrypted);
            }

            switch (type) {
                case MSG_TYPE_GOSSIP -> {
                    if (gossipHandler != null) {
                        gossipHandler.processMessage(type, message.array());
                    }
                }
                case MSG_TYPE_PROOF -> {
                    if (gossipHandler != null) {
                        gossipHandler.processMessage(type, message.array());
                    }
                }
                case MSG_TYPE_PEER_INFO -> {
                    if (gossipHandler != null) {
                        gossipHandler.processMessage(type, message.array());
                    }
                    // Update connection phase if this is an acknowledgment
                    if (message.remaining() == 1 && message.get(0) == 1) {
                        currentPhase = ConnectionPhase.NETWORK_HANDSHAKE_COMPLETE;
                    }
                }
                case MSG_TYPE_PING -> sendMessage(MSG_TYPE_PING, new byte[0]);
                default -> log.warn("Unknown message type: {}", type);
            }
        } catch (Exception e) {
            throw new IOException("Failed to handle message", e);
        }
    }

    /**
     * Retrieves the current phase of the VPN connection.
     *
     * @return The current {@link ConnectionPhase} of the connection.
     */
    @Override
    public ConnectionPhase getPhase() {
        return currentPhase;
    }
    
}
=============================================

/*
 * Copyright (C) 2024 Publius Pseudis
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.publiuspseudis.esadvpn.core;

import java.nio.ByteBuffer;
import java.util.Collections;
import java.util.Set;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * <p>
 * The {@code VirtualInterface} class represents a virtual network interface that operates entirely in userspace.
 * It manages the sending and receiving of network packets through designated ingress and egress queues,
 * utilizing a pool of pre-allocated buffers to optimize performance and resource usage.
 * </p>
 * 
 * <p>
 * <strong>Key Functionalities:</strong></p>
 * <ul>
 *   <li>Efficient management of network buffers to handle high-throughput packet processing.</li>
 *   <li>Thread-safe operations for sending and receiving packets without data races.</li>
 *   <li>Integration with network stacks through packet injection and retrieval mechanisms.</li>
 *   <li>Monitoring and control of the interface's operational state.</li>
 * </ul>
 * 
 * 
 * <p>
 * <strong>Example Usage:</strong>
 * </p>
 * <pre>{@code
 * // Initialize the virtual interface with an IP address and MTU
 * VirtualInterface vInterface = new VirtualInterface("192.168.1.100", 1500);
 * 
 * // Create a packet to send
 * ByteBuffer packet = ByteBuffer.allocateDirect(1500);
 * packet.put("Hello, Virtual Network!".getBytes());
 * packet.flip();
 * 
 * // Write the packet to the virtual interface
 * vInterface.write(packet);
 * 
 * // Read a packet from the virtual interface
 * ByteBuffer receivedPacket = vInterface.read();
 * if (receivedPacket != null) {
 *     byte[] data = new byte[receivedPacket.remaining()];
 *     receivedPacket.get(data);
 *     System.out.println("Received: " + new String(data));
 * }
 * 
 * // Inject a packet into the network stack
 * ByteBuffer injectPacket = ByteBuffer.allocateDirect(1500);
 * injectPacket.put("Injected Packet".getBytes());
 * injectPacket.flip();
 * vInterface.injectPacket(injectPacket);
 * 
 * // Close the virtual interface when done
 * vInterface.close();
 * }</pre>
 * 
 * <p>
 * <strong>Thread Safety:</strong>
 * </p>
 * <p>
 * The {@code VirtualInterface} class is designed to be thread-safe. It utilizes concurrent data structures
 * such as {@code ConcurrentHashMap} and {@code LinkedBlockingQueue} to manage buffers and packet queues.
 * Additionally, atomic variables like {@code AtomicBoolean} ensure that the interface's running state
 * is consistently maintained across multiple threads.
 * </p>
 * 
 * <p>
 * <strong>Dependencies:</strong>
 * </p>
 * <ul>
 *   <li>SLF4J Logging Framework: Used for logging informational, debug, and error messages.</li>
 * </ul>
 * 
 * @author 
 * Publius Pseudis
 */
public class VirtualInterface implements AutoCloseable {
    
    /**
     * Logger instance from SLF4J for logging informational, debug, and error messages.
     * Utilized throughout the class to trace execution flow and record significant events.
     */
    private static final Logger log = LoggerFactory.getLogger(VirtualInterface.class);
    
    /**
     * A thread-safe set containing buffers that are currently in use.
     * Utilizes a concurrent hash map to allow safe access across multiple threads.
     */
    private final Set<ByteBuffer> inUseBuffers = Collections.newSetFromMap(new ConcurrentHashMap<>());
    
    /**
     * The IP address assigned to this virtual interface.
     * Represented as a {@code String} in standard dotted-decimal notation.
     */
    private final String address;
    
    /**
     * The Maximum Transmission Unit (MTU) size for this virtual interface.
     * Determines the largest packet size that can be transmitted without fragmentation.
     */
    private final int mtu;
    
    /**
     * Queue for incoming packets destined for this virtual interface.
     * Utilizes a blocking queue to handle packet ingress in a thread-safe manner.
     */
    private final BlockingQueue<ByteBuffer> ingressQueue;
    
    /**
     * Queue for outgoing packets originating from this virtual interface.
     * Utilizes a blocking queue to handle packet egress in a thread-safe manner.
     */
    private final BlockingQueue<ByteBuffer> egressQueue;
    
    /**
     * Atomic boolean flag indicating whether the virtual interface is currently running.
     * Ensures visibility and atomicity across multiple threads.
     */
    private final AtomicBoolean running;
    
    /**
     * Array representing the pool of pre-allocated direct byte buffers.
     * Each buffer is sized according to the MTU and is reused to minimize memory allocations.
     */
    private final ByteBuffer[] bufferPool;
    
    /**
     * The total number of buffers in the buffer pool.
     * Determines the maximum number of packets that can be handled concurrently.
     */
    private static final int BUFFER_POOL_SIZE = 1024;
    
    /**
     * Constructs a new {@code VirtualInterface} with the specified IP address and MTU.
     * 
     * <p>
     * Initializes the ingress and egress queues, sets the running flag to {@code true},
     * and pre-allocates a pool of direct byte buffers for efficient packet handling.
     * </p>
     * 
     * @param address The IP address to assign to this virtual interface.
     * @param mtu The Maximum Transmission Unit size for this interface.
     */
    public VirtualInterface(String address, int mtu) {
        this.address = address;
        this.mtu = mtu;
        this.ingressQueue = new LinkedBlockingQueue<>();
        this.egressQueue = new LinkedBlockingQueue<>();
        this.running = new AtomicBoolean(true);
        
        // Pre-allocate buffer pool
        this.bufferPool = new ByteBuffer[BUFFER_POOL_SIZE];
        for (int i = 0; i < BUFFER_POOL_SIZE; i++) {
            this.bufferPool[i] = ByteBuffer.allocateDirect(mtu);
        }
    }
    
    /**
     * Writes a packet to the virtual interface's ingress queue.
     * 
     * <p>
     * Attempts to retrieve a buffer from the pool, copies the packet data into it,
     * and enqueues it for processing. If the buffer pool is exhausted, the packet is dropped
     * and a warning is logged.
     * </p>
     * 
     * @param packet The {@link ByteBuffer} containing the packet data to be written.
     */
    public void write(ByteBuffer packet) throws InterruptedException {
        if (!running.get() || packet == null || !packet.hasRemaining()) {
            return;
        }

        // Try to write to the egress queue with a timeout
        if (!egressQueue.offer(packet, 100, TimeUnit.MILLISECONDS)) {
            log.warn("Write operation timed out after 100ms");
        }
    }

    /**
     * Reads a packet from the virtual interface's egress queue.
     * 
     * <p>
     * Retrieves and returns a packet from the egress queue if available. If no packet is present,
     * returns {@code null}.
     * </p>
     * 
     * @return A {@link ByteBuffer} containing the packet data, or {@code null} if no packet is available.
     * @throws java.lang.InterruptedException
     */
    public ByteBuffer read() throws InterruptedException {
        if (!running.get()) {
            return null;
        }

        // Try to read from the ingress queue with a timeout
        ByteBuffer buffer = ingressQueue.poll(100, TimeUnit.MILLISECONDS);
        if (buffer != null && buffer.hasRemaining()) {
            return buffer;
        }
        return null;
    }

    /**
     * Injects a packet into the network stack for processing.
     * 
     * <p>
     * Allocates a buffer from the pool, copies the packet data into it, and enqueues it for network processing.
     * If buffer allocation fails, the packet is silently dropped.
     * </p>
     * 
     * @param packet The {@link ByteBuffer} containing the packet data to be injected.
     */
    public void injectPacket(ByteBuffer packet) {
        if (!running.get() || packet == null || !packet.hasRemaining()) {
            return;
        }

        try {
            ByteBuffer buffer = getBuffer();
            if (buffer == null) {
                return;
            }

            buffer.clear();
            buffer.put(packet);
            buffer.flip();

            egressQueue.offer(buffer);
        } catch (Exception e) {
            log.error("Failed to inject packet: {}", e.getMessage());
        }
    }

    /**
     * Retrieves an available buffer from the buffer pool.
     * 
     * <p>
     * Iterates through the buffer pool and returns the first buffer that is not currently in use.
     * Marks the buffer as in use by adding it to the {@code inUseBuffers} set.
     * </p>
     * 
     * @return A {@link ByteBuffer} from the pool if available, or {@code null} if all buffers are in use.
     */
    private ByteBuffer getBuffer() {
        for (ByteBuffer buffer : bufferPool) {
            if (buffer != null && !inUseBuffers.contains(buffer)) {
                inUseBuffers.add(buffer);
                return buffer;
            }
        }
        return null;
    }

    /**
     * Releases a buffer back to the buffer pool.
     * 
     * <p>
     * Clears the buffer and removes it from the {@code inUseBuffers} set, making it available for reuse.
     * </p>
     * 
     * @param buffer The {@link ByteBuffer} to be released.
     */
    public void releaseBuffer(ByteBuffer buffer) {
        if (buffer != null) {
            buffer.clear();
            inUseBuffers.remove(buffer);
        }
    }

    /**
     * Retrieves the IP address assigned to this virtual interface.
     * 
     * @return A {@code String} representing the IP address.
     */
    public String getAddress() {
        return address;
    }

    /**
     * Retrieves the Maximum Transmission Unit (MTU) size for this virtual interface.
     * 
     * @return An {@code int} representing the MTU size in bytes.
     */
    public int getMTU() {
        return mtu;
    }

    /**
     * Checks whether the virtual interface is currently running.
     * 
     * @return {@code true} if the interface is running; {@code false} otherwise.
     */
    public boolean isRunning() {
        return running.get();
    }

    /**
     * Closes the virtual interface, terminating all ongoing operations and releasing resources.
     * 
     * <p>
     * Sets the running flag to {@code false}, clears both ingress and egress queues,
     * and effectively stops the interface from processing any further packets.
     * </p>
     */
    @Override
    public void close() {
        running.set(false);
        ingressQueue.clear();
        egressQueue.clear();
    }
}

=============================================

/*
 * Copyright (C) 2024 Publius Pseudis
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.publiuspseudis.esadvpn.crypto;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.*;
import java.util.concurrent.*;
import java.nio.ByteBuffer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * <p>
 * The {@code ProofOfWork} class encapsulates the functionality required to generate and verify
 * proofs of work (PoW) within the peer-to-peer (P2P) VPN network. Proofs of work are essential
 * for securing the network by ensuring that peers perform computationally intensive tasks
 * before being allowed to join or maintain their presence in the network.
 * </p>
 * 
 * <p>
 * <strong>Key Functionalities:</strong></p>
 * <ul>
 *   <li>Generating a valid proof of work by finding a nonce that satisfies the difficulty criteria.</li>
 *   <li>Verifying the validity of a given proof of work.</li>
 *   <li>Managing proof-related metadata such as timestamps to ensure freshness and prevent replay attacks.</li>
 * </ul>
 * 
 * 
 * <p>
 * <strong>Example Usage:</strong>
 * </p>
 * <pre>{@code
 * // Initialize ProofOfWork with a unique node ID
 * byte[] nodeId = ...; // 32-byte unique identifier
 * ProofOfWork pow = new ProofOfWork(nodeId);
 * 
 * // Solve for a valid proof
 * boolean solved = pow.solve();
 * if (solved) {
 *     byte[] proof = pow.getCurrentProof();
 *     long timestamp = pow.getTimestamp();
 *     // Broadcast proof to peers or use in handshake
 * }
 * 
 * // Verify a received proof
 * boolean isValid = pow.verify(receivedProofData, receivedTimestamp);
 * if (isValid) {
 *     // Accept the peer or update network state
 * }
 * }</pre>
 * 
 * <p>
 * <strong>Thread Safety:</strong>
 * </p>
 * <p>
 * The {@code ProofOfWork} class is designed to be thread-safe. The `currentProof` and `timestamp` fields
 * are marked as `volatile` to ensure visibility across threads. Additionally, the `solve` and `verify`
 * methods handle their operations in a manner that prevents race conditions, allowing concurrent attempts
 * to solve proofs or verify received proofs without compromising data integrity.
 * </p>
 * 
 * <p>
 * <strong>Dependencies:</strong>
 * </p>
 * <ul>
 *   <li>{@link MessageDigest}: Utilized for hashing operations using the SHA-256 algorithm.</li>
 *   <li>SLF4J Logging Framework: Employed for logging informational, debug, and error messages.</li>
 * </ul>
 * 
 * @author 
 * Publius Pseudis
 */
public class ProofOfWork {
    /**
     * Logger instance for logging information, warnings, and errors.
     */
    private static final Logger log = LoggerFactory.getLogger(ProofOfWork.class);

    /**
     * The number of leading zero bits required in the hash to consider a proof as valid.
     */
    private static final int DIFFICULTY = 20; // Number of leading zero bits required

    /**
     * The unique node ID associated with this proof of work instance.
     */
    private final byte[] nodeId;

    /**
     * The current valid proof of work. This includes the node ID, timestamp, and nonce.
     *
     * <p>
     * Once a valid proof is found using the {@link #solve()} method, this field stores the proof data
     * that satisfies the difficulty requirement. It is used for verifying the legitimacy of the node
     * within the network.
     * </p>
     */
    private volatile byte[] currentProof;

    /**
     * The timestamp indicating when the current proof of work was generated.
     *
     * <p>
     * This timestamp is used to ensure the freshness of the proof and to prevent replay attacks
     * by associating the proof with a specific moment in time.
     * </p>
     */
    private volatile long timestamp;

    /**
     * Constructs a new {@code ProofOfWork} instance with the specified node ID.
     *
     * <p>
     * Initializes the proof of work with the provided unique node identifier. The constructor sets
     * the initial timestamp to the current system time to ensure the proof's validity period.
     * </p>
     *
     * @param nodeId The unique node ID for which the proof of work is to be generated and verified.
     *               Must be a non-null byte array of a specific length (e.g., 32 bytes).
     * @throws IllegalArgumentException If {@code nodeId} is {@code null} or does not meet the required criteria.
     */
    public ProofOfWork(byte[] nodeId) {
        if (nodeId == null) {
            throw new IllegalArgumentException("nodeId cannot be null");
        }
        this.nodeId = nodeId;
        this.timestamp = System.currentTimeMillis();
    }

    /**
     * Attempts to solve the proof of work by finding a nonce that, when combined with the node ID and timestamp,
     * produces a SHA-256 hash with the required number of leading zero bits.
     *
     * @return {@code true} if a valid proof is found; {@code false} otherwise.
     */
    public boolean solve() {
        long nonce = 0;
        timestamp = System.currentTimeMillis(); // Update timestamp before solving
        byte[] attempt = new byte[nodeId.length + 8 + 8]; // nodeId + timestamp + nonce
        System.arraycopy(nodeId, 0, attempt, 0, nodeId.length);
        ByteBuffer.wrap(attempt, nodeId.length, 8).putLong(timestamp);

        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            while (!Thread.currentThread().isInterrupted()) {
                // Insert nonce into the attempt array
                ByteBuffer.wrap(attempt, nodeId.length + 8, 8).putLong(nonce);
                byte[] hash = digest.digest(attempt);

                if (isValidProof(hash)) {
                    currentProof = Arrays.copyOf(attempt, attempt.length);
                    log.info("Found valid proof of work after {} attempts", nonce);
                    return true;
                }
                nonce++;
            }
        } catch (NoSuchAlgorithmException e) {
            log.error("SHA-256 not available", e);
        }
        return false;
    }

    /**
     * Checks whether the provided hash satisfies the difficulty requirement by having the requisite number of
     * leading zero bits.
     *
     * @param hash The SHA-256 hash to validate.
     * @return {@code true} if the hash meets the difficulty criteria; {@code false} otherwise.
     */
    private boolean isValidProof(byte[] hash) {
        int leadingZeros = 0;
        for (byte b : hash) {
            int bits = Integer.numberOfLeadingZeros(b & 0xFF) - 24;
            leadingZeros += bits;
            if (bits < 8) {
                break;
            }
        }
        return leadingZeros >= DIFFICULTY;
    }

    /**
     * Retrieves the current valid proof of work.
     *
     * @return A byte array representing the current proof of work, including node ID, timestamp, and nonce.
     */
    public byte[] getCurrentProof() {
        return currentProof;
    }

    /**
     * Retrieves the timestamp associated with the current proof of work.
     *
     * @return The timestamp in milliseconds since the epoch.
     */
    public long getTimestamp() {
        return timestamp;
    }

    /**
     * Verifies the validity of a received proof of work by ensuring it meets the difficulty criteria
     * and that its timestamp is within acceptable bounds.
     *
     * <p>
     * This method checks that the proof's timestamp is neither too old nor set in the future,
     * preventing replay attacks and ensuring proof freshness. It then validates the proof by
     * hashing the provided proof data and confirming that the resulting hash has the required
     * number of leading zero bits as defined by the {@link #DIFFICULTY} constant.
     * </p>
     *
     * @param proofData      The byte array containing the proof of work data (node ID + timestamp + nonce).
     *                       Must be structured correctly to match the hashing criteria.
     * @param proofTimestamp The timestamp associated with the proof of work in milliseconds since the epoch.
     *                       This should closely align with the current system time to be considered valid.
     * @return {@code true} if the proof is valid and meets all criteria; {@code false} otherwise.
     */
    public boolean verify(byte[] proofData, long proofTimestamp) {
      // Check timestamp bounds to ensure proof freshness
      long now = System.currentTimeMillis();
      log.debug("Verifying proof - Current time: {}, Proof time: {}, Delta: {}ms", 
          now, proofTimestamp, now - proofTimestamp);

      if (now - proofTimestamp > TimeUnit.DAYS.toMillis(1)) {
          log.warn("Proof expired. Current time: {}, Proof time: {}", now, proofTimestamp);
          return false;
      }
      if (proofTimestamp > now + TimeUnit.MINUTES.toMillis(5)) {
          log.warn("Proof from future. Current time: {}, Proof time: {}", now, proofTimestamp);
          return false;
      }

      try {
          // Extract nodeId and timestamp
          log.debug("Proof data length: {}, content: {}", 
              proofData.length, bytesToHex(proofData));

          // Calculate hash
          MessageDigest digest = MessageDigest.getInstance("SHA-256");
          byte[] hash = digest.digest(proofData);

          log.debug("Calculated hash: {}", bytesToHex(hash));

          int leadingZeros = countLeadingZeros(hash);
          log.debug("Leading zeros required: {}, found: {}", 
              DIFFICULTY, leadingZeros);

          return leadingZeros >= DIFFICULTY;

      } catch (NoSuchAlgorithmException e) {
          log.error("Failed to verify proof: {}", e.getMessage(), e);
          return false;
      }
  }
    /**
     * Converts an array of bytes into its corresponding hexadecimal string representation.
     *
     * <p>
     * This utility method is useful for logging binary data in a human-readable hexadecimal format,
     * aiding in debugging and monitoring network messages or cryptographic operations.
     * </p>
     *
     * @param bytes The array of bytes to convert.
     * @return A {@code String} representing the hexadecimal values of the input bytes.
     */
    private static String bytesToHex(byte[] bytes) {
        StringBuilder hex = new StringBuilder();
        for (byte b : bytes) {
            hex.append(String.format("%02x", b));
        }
        return hex.toString();
    }

    /**
     * Counts the number of leading zero bits in a given SHA-256 hash.
     *
     * <p>
     * This method iterates through the bytes of the hash, counting the number of consecutive zero bits
     * from the start. The count is used to determine if the hash meets the required difficulty level
     * for a valid proof of work.
     * </p>
     *
     * @param hash The byte array representing the SHA-256 hash to evaluate.
     * @return The total number of leading zero bits in the hash.
     */
    private int countLeadingZeros(byte[] hash) {
        int leadingZeros = 0;
        for (byte b : hash) {
            if (b == 0) {
                leadingZeros += 8;
            } else {
                leadingZeros += Integer.numberOfLeadingZeros(b & 0xFF);
                break;
            }
        }
        return leadingZeros;
    }
}

=============================================

/*
 * Copyright (C) 2024 Publius Pseudis
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.publiuspseudis.esadvpn.crypto;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.security.InvalidKeyException;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.spec.ECGenParameterSpec;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.X509EncodedKeySpec;
import java.util.Arrays;
import java.util.concurrent.TimeUnit;
import javax.crypto.Cipher;
import javax.crypto.KeyAgreement;
import javax.crypto.SecretKey;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import org.publiuspseudis.esadvpn.routing.RouteInfo;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * <p>
 * The {@code SecureChannel} class implements the {@link SecureChannelHandler} interface to manage
 * secure, encrypted communication channels between peers within the peer-to-peer (P2P) VPN network.
 * It leverages Elliptic Curve Diffie-Hellman (ECDH) for key agreement and Advanced Encryption
 * Standard (AES) in Galois/Counter Mode (GCM) for encrypting and decrypting messages.
 * </p>
 * 
 * <p>
 * <strong>Key Functionalities:</strong></p>
 * <ul>
 *   <li>Generating an elliptic curve (EC) key pair for secure key exchange.</li>
 *   <li>Establishing a shared secret using ECDH key agreement with a peer's public key.</li>
 *   <li>Encrypting plaintext messages using AES-GCM for confidentiality and integrity.</li>
 *   <li>Decrypting ciphertext messages using the established shared secret.</li>
 *   <li>Managing the state of the secure channel to determine if encryption/decryption is possible.</li>
 * </ul>
 * 
 * 
 * <p>
 * <strong>Example Usage:</strong>
 * </p>
 * <pre>{@code
 * try {
 *     // Initialize SecureChannel
 *     SecureChannel secureChannel = new SecureChannel();
 *     
 *     // Retrieve and share public key with peer
 *     byte[] localPublicKey = secureChannel.getPublicKey();
 *     // Send localPublicKey to peer through a secure out-of-band channel
 *     
 *     // Assume peerPublicKey is received from the peer
 *     byte[] peerPublicKey = ...;
 *     
 *     // Establish secure channel with peer
 *     secureChannel.establishSecureChannel(peerPublicKey);
 *     
 *     if (secureChannel.isEstablished()) {
 *         // Encrypt a message to send to the peer
 *         String message = "Hello, secure peer!";
 *         byte[] encryptedMessage = secureChannel.encryptMessage(message.getBytes(StandardCharsets.UTF_8));
 *         
 *         // Send encryptedMessage to peer
 *         
 *         // Receive encrypted response from peer
 *         byte[] receivedEncryptedResponse = ...;
 *         byte[] decryptedResponse = secureChannel.decryptMessage(receivedEncryptedResponse);
 *         
 *         String response = new String(decryptedResponse, StandardCharsets.UTF_8);
 *         System.out.println("Decrypted response: " + response);
 *     }
 * } catch (Exception e) {
 *     e.printStackTrace();
 * }
 * }</pre>
 * 
 * <p>
 * <strong>Thread Safety:</strong>
 * </p>
 * <p>
 * The {@code SecureChannel} class is designed to be thread-safe. The fields `sharedSecret` and `established`
 * are marked as `volatile` to ensure visibility across threads. The class does not expose mutable internal
 * state that could be altered concurrently, and cryptographic operations are performed in a thread-safe
 * manner provided by the underlying Java Cryptography Architecture (JCA).
 * </p>
 * 
 * <p>
 * <strong>Dependencies:</strong>
 * </p>
 * <ul>
 *   <li>Java Cryptography Architecture (JCA): Utilized for cryptographic operations such as key generation,
 *       key agreement, encryption, and decryption.</li>
 *   <li>SLF4J Logging Framework: Employed for logging informational, debug, and error messages.</li>
 * </ul>
 * 
 * @author 
 * Publius Pseudis
 */
public class SecureChannel implements SecureChannelHandler {
    /**
     * Logger instance for logging debug and informational messages.
     */
    private static final Logger log = LoggerFactory.getLogger(RouteInfo.class);
    /**
     * The transformation string specifying the encryption algorithm, mode, and padding scheme.
     * Uses AES encryption in Galois/Counter Mode (GCM) with no padding.
     */
    private static final String ALGORITHM = "AES/GCM/NoPadding";
    
    /**
     * The elliptic curve (EC) key pair used for ECDH key agreement. Contains both the public and private keys.
     */
    private final KeyPair keyPair;
    
    /**
     * The shared secret derived from ECDH key agreement with a peer. Used as the symmetric key for AES encryption.
     */
    private volatile SecretKey sharedSecret;
    
    /**
     * A secure random number generator instance used for generating initialization vectors (IVs) for AES-GCM.
     */
    private final SecureRandom random;
    
    /**
     * A flag indicating whether the secure channel has been successfully established.
     * Once set to {@code true}, the channel is ready for encrypting and decrypting messages.
     */
    private volatile boolean established = false;

    
    private volatile byte[] sessionId;
    private volatile long lastRekeyed;
    private static final long REKEY_INTERVAL = TimeUnit.HOURS.toMillis(1);
    private static final int NONCE_SIZE = 32;
    
    /**
     * Constructs a new {@code SecureChannel} instance by generating an EC key pair using the
     * "secp256r1" curve. This key pair is used for establishing a shared secret with a peer.
     *
     * @throws Exception If an error occurs during key pair generation, such as the specified algorithm
     *                   or curve being unavailable.
     */
    public SecureChannel() throws Exception {
        // Initialize KeyPairGenerator for Elliptic Curve (EC) algorithm
        KeyPairGenerator keyGen = KeyPairGenerator.getInstance("EC");
        
        // Specify the EC curve to use
        ECGenParameterSpec spec = new ECGenParameterSpec("secp256r1");
        keyGen.initialize(spec);
        
        // Generate the EC key pair
        this.keyPair = keyGen.generateKeyPair();
        
        // Initialize SecureRandom instance for IV generation
        this.random = new SecureRandom();
    }

    /**
     * Establishes a secure communication channel with a peer by performing ECDH key agreement using the
     * peer's public key. Upon successful key agreement, a shared secret is derived and used as the
     * symmetric key for AES-GCM encryption and decryption.
     *
     * @param peerPublicKey A {@code byte[]} representing the peer's public key in X.509 encoded format.
     *                      This key should be obtained through a secure exchange mechanism to prevent
     *                      man-in-the-middle attacks.
     * @throws IOException If an error occurs during the establishment of the secure channel, such as
     *                     failures in key agreement or cryptographic operations.
     */
    @Override
    public void establishSecureChannel(byte[] peerPublicKey) throws IOException {
       try {
           // Generate session nonce
           byte[] localNonce = new byte[NONCE_SIZE];
           random.nextBytes(localNonce);

           // Convert peer's public key
           KeyFactory keyFactory = KeyFactory.getInstance("EC");
           X509EncodedKeySpec keySpec = new X509EncodedKeySpec(peerPublicKey);
           PublicKey peerKey = keyFactory.generatePublic(keySpec);

           // Initialize KeyAgreement for ECDH
           KeyAgreement keyAgreement = KeyAgreement.getInstance("ECDH");
           keyAgreement.init(keyPair.getPrivate());

           // Perform the key agreement phase with the peer's public key
           keyAgreement.doPhase(peerKey, true);

           // Generate the shared secret
           byte[] sharedSecretBytes = keyAgreement.generateSecret();

           // Combine secret with nonce
           ByteBuffer material = ByteBuffer.allocate(sharedSecretBytes.length + localNonce.length);
           material.put(sharedSecretBytes).put(localNonce).flip();

           // Derive key and session ID
           MessageDigest hash = MessageDigest.getInstance("SHA-256");
           byte[] digestedSecret = hash.digest(material.array());

           byte[] keyBytes = Arrays.copyOfRange(digestedSecret, 0, 16);
           this.sessionId = Arrays.copyOfRange(digestedSecret, 16, 32);
           this.sharedSecret = new SecretKeySpec(keyBytes, "AES");
           this.lastRekeyed = System.currentTimeMillis();

           this.established = true;

       } catch (InvalidKeyException | NoSuchAlgorithmException | InvalidKeySpecException e) {
           throw new IOException("Failed to establish secure channel", e);
       }
   }

    /**
     * Retrieves the local public key used for establishing secure channels with peers. This key should be
     * shared with peers through a secure out-of-band channel to facilitate the key agreement process.
     *
     * @return A {@code byte[]} containing the local public key in X.509 encoded format.
     */
    @Override
    public byte[] getPublicKey() {
        return keyPair.getPublic().getEncoded();
    }

    /**
     * Encrypts the provided plaintext data using AES-GCM encryption with the established shared secret.
     * Generates a random initialization vector (IV) for each encryption operation to ensure security.
     *
     * @param data A {@code byte[]} containing the plaintext data to be encrypted.
     * @return A {@code byte[]} containing the encrypted data, prefixed with the IV for use in decryption.
     * @throws Exception If an error occurs during the encryption process, such as cipher initialization
     *                   failures or encryption algorithm issues.
     */

    @Override
    public byte[] encryptMessage(byte[] data) throws Exception {
        if (!established) {
            return data;
        }

        // Check if rekey needed
        if (System.currentTimeMillis() - lastRekeyed > REKEY_INTERVAL) {
            byte[] newNonce = new byte[NONCE_SIZE];
            random.nextBytes(newNonce);
            MessageDigest hash = MessageDigest.getInstance("SHA-256");
            hash.update(sharedSecret.getEncoded());
            hash.update(newNonce);
            byte[] newSecret = hash.digest();
            this.sharedSecret = new SecretKeySpec(newSecret, "AES");
            this.lastRekeyed = System.currentTimeMillis();
        }

        // Generate IV for AES-GCM
        byte[] iv = new byte[12];
        random.nextBytes(iv);

        // Initialize cipher for encryption
        Cipher cipher = Cipher.getInstance(ALGORITHM);
        cipher.init(Cipher.ENCRYPT_MODE, sharedSecret, new GCMParameterSpec(128, iv));

        // Add session ID as additional authenticated data
        if (sessionId != null) {
            cipher.updateAAD(sessionId);
        }

        // Perform encryption
        byte[] encrypted = cipher.doFinal(data);

        // Combine IV and encrypted data
        ByteBuffer result = ByteBuffer.allocate(iv.length + encrypted.length);
        result.put(iv).put(encrypted);
        return result.array();
    }

    /**
     * Decrypts the provided ciphertext data using AES-GCM decryption with the established shared secret.
     * Expects the ciphertext to be prefixed with the IV used during encryption.
     *
     * @param data A {@code byte[]} containing the encrypted data to be decrypted. The first 12 bytes should
     *             represent the IV, followed by the actual ciphertext.
     * @return A {@code byte[]} containing the decrypted plaintext data.
     * @throws Exception If an error occurs during the decryption process, such as invalid ciphertext format,
     *                   decryption algorithm issues, or authentication tag verification failures.
     */
    @Override
    public byte[] decryptMessage(byte[] data) throws Exception {
        if (!established || data == null || data.length < 12) {
            throw new IllegalArgumentException("Invalid message format or secure channel not established.");
        }

        // Extract the IV (first 12 bytes)
        ByteBuffer buffer = ByteBuffer.wrap(data);
        byte[] iv = new byte[12];
        buffer.get(iv);

        // Extract the actual encrypted data
        byte[] encrypted = new byte[buffer.remaining()];
        buffer.get(encrypted);

        // Initialize cipher for decryption
        Cipher cipher = Cipher.getInstance(ALGORITHM);
        cipher.init(Cipher.DECRYPT_MODE, sharedSecret, new GCMParameterSpec(128, iv));

        // Add session ID as additional authenticated data
        if (sessionId != null) {
            cipher.updateAAD(sessionId);
        }

        // Perform decryption
        return cipher.doFinal(encrypted);
    }

    /**
     * Checks whether the secure communication channel has been successfully established. Returns {@code true}
     * if the channel is active and ready for encrypted communication; otherwise, returns {@code false}.
     *
     * @return {@code true} if the secure channel is established and active; {@code false} otherwise.
     */
    @Override
    public boolean isEstablished() {
        return established;
    }
}

=============================================

/*
 * Copyright (C) 2024 Publius Pseudis
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.publiuspseudis.esadvpn.crypto;

import java.io.IOException;

/**
 * <p>
 * The {@code SecureChannelHandler} interface defines the contract for establishing and managing
 * secure communication channels between peers within the peer-to-peer (P2P) VPN network. Implementations
 * of this interface are responsible for handling the setup of encrypted connections, ensuring data
 * confidentiality and integrity during transmission.
 * </p>
 * 
 * <p>
 * <strong>Key Functionalities:</strong></p>
 * <ul>
 *   <li>Establishing a secure communication channel using the peer's public key.</li>
 *   <li>Providing access to the handler's public key for peer identification and encryption.</li>
 *   <li>Encrypting outgoing messages to ensure data confidentiality.</li>
 *   <li>Decrypting incoming messages to retrieve original data.</li>
 *   <li>Monitoring the establishment status of the secure channel.</li>
 * </ul>
 * 
 * 
 * <p>
 * <strong>Example Usage:</strong>
 * </p>
 * <pre>{@code
 * // Assume SecureChannelHandlerImpl is a concrete implementation of SecureChannelHandler
 * SecureChannelHandler secureHandler = new SecureChannelHandlerImpl();
 * 
 * // Establish a secure channel with a peer using their public key
 * byte[] peerPublicKey = ...; // Obtain the peer's public key through a secure exchange
 * try {
 *     secureHandler.establishSecureChannel(peerPublicKey);
 * } catch (IOException e) {
 *     // Handle exception during secure channel establishment
 * }
 * 
 * // Encrypt a message before sending
 * byte[] plainMessage = "Hello, Peer!".getBytes(StandardCharsets.UTF_8);
 * byte[] encryptedMessage;
 * try {
 *     encryptedMessage = secureHandler.encryptMessage(plainMessage);
 * } catch (Exception e) {
 *     // Handle encryption errors
 * }
 * 
 * // Decrypt a received message
 * byte[] receivedEncryptedMessage = ...; // Received encrypted data
 * byte[] decryptedMessage;
 * try {
 *     decryptedMessage = secureHandler.decryptMessage(receivedEncryptedMessage);
 * } catch (Exception e) {
 *     // Handle decryption errors
 * }
 * 
 * // Check if the secure channel is established
 * if (secureHandler.isEstablished()) {
 *     // Proceed with secure communication
 * }
 * }</pre>
 * 
 * <p>
 * <strong>Thread Safety:</strong>
 * </p>
 * <p>
 * Implementations of the {@code SecureChannelHandler} interface should ensure thread safety, especially
 * if the handler is accessed by multiple threads concurrently. Synchronization mechanisms or thread-safe
 * data structures should be employed to prevent race conditions and ensure consistent state management.
 * </p>
 * 
 * <p>
 * <strong>Dependencies:</strong>
 * </p>
 * <ul>
 *   <li>Java Cryptography Architecture (JCA): Utilized for cryptographic operations such as encryption and decryption.</li>
 *   <li>SLF4J Logging Framework: Recommended for logging informational, debug, and error messages.</li>
 * </ul>
 * 
 * @author 
 * Publius Pseudis
 */
public interface SecureChannelHandler {
    /**
     * Establishes a secure communication channel with a peer using the provided public key. This method
     * initiates the process of setting up encrypted communication, ensuring that subsequent messages
     * exchanged with the peer are confidential and tamper-proof.
     *
     * @param peerPublicKey A {@code byte[]} representing the peer's public key used for establishing
     *                      the secure channel. This key should be obtained through a secure exchange
     *                      mechanism to prevent man-in-the-middle attacks.
     * @throws IOException If an I/O error occurs during the establishment of the secure channel, such as
     *                     failures in cryptographic operations or network disruptions.
     */
    void establishSecureChannel(byte[] peerPublicKey) throws IOException;
    
    /**
     * Retrieves the public key associated with this secure channel handler. The public key is used by
     * peers to encrypt messages intended for this handler, ensuring that only the intended recipient
     * can decrypt and access the message content.
     *
     * @return A {@code byte[]} representing the public key of this handler.
     */
    byte[] getPublicKey();
    
    /**
     * Encrypts the provided plaintext data to ensure secure transmission over the network. The encryption
     * process transforms the data into an unreadable format, which can only be decrypted by the intended
     * recipient possessing the corresponding private key.
     *
     * @param data A {@code byte[]} containing the plaintext data to be encrypted.
     * @return A {@code byte[]} containing the encrypted data, ready for secure transmission.
     * @throws Exception If an error occurs during the encryption process, such as issues with the cryptographic
     *                   algorithm or invalid input data.
     */
    byte[] encryptMessage(byte[] data) throws Exception;
    
    /**
     * Decrypts the provided ciphertext data to retrieve the original plaintext. The decryption process
     * reverses the encryption, making the data readable and usable by the recipient.
     *
     * @param data A {@code byte[]} containing the encrypted data to be decrypted.
     * @return A {@code byte[]} containing the decrypted plaintext data.
     * @throws Exception If an error occurs during the decryption process, such as invalid ciphertext or
     *                   issues with the cryptographic algorithm.
     */
    byte[] decryptMessage(byte[] data) throws Exception;
    
    /**
     * Checks whether the secure communication channel has been successfully established. This method
     * returns {@code true} if the channel is active and secure, allowing for encrypted communication
     * between peers. Otherwise, it returns {@code false}, indicating that the secure channel is not
     * yet established or has been terminated.
     *
     * @return {@code true} if the secure channel is established and active; {@code false} otherwise.
     */
    boolean isEstablished();
}

=============================================

/*
 * Copyright (C) 2024 Publius Pseudis
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.publiuspseudis.esadvpn.proxy;

import org.publiuspseudis.esadvpn.network.UDPHandler;
import java.io.*;
import java.net.*;
import java.nio.ByteBuffer;
import java.util.concurrent.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * <p>
 * The {@code SocksProxy} class implements a SOCKS5 proxy server that facilitates secure and efficient
 * routing of TCP and UDP traffic through the peer-to-peer (P2P) VPN network. It listens for incoming
 * SOCKS5 client connections, handles the SOCKS5 handshake and connection requests, and manages the
 * forwarding of traffic between clients and destination servers.
 * </p>
 * 
 * <p>
 * <strong>Key Functionalities:</strong></p>
 * <ul>
 *   <li>Listening for and accepting incoming SOCKS5 client connections.</li>
 *   <li>Performing the SOCKS5 handshake and authenticating clients.</li>
 *   <li>Handling TCP connection requests to target servers.</li>
 *   <li>Managing UDP traffic through the VPN network via the {@link UDPHandler}.</li>
 *   <li>Ensuring concurrent handling of multiple client connections using thread pools.</li>
 *   <li>Gracefully shutting down the proxy server and releasing resources.</li>
 * </ul>
 * 
 * 
 * <p>
 * <strong>Example Usage:</strong>
 * </p>
 * <pre>{@code
 * // Initialize UDPHandler instance
 * UDPHandler udpHandler = new UDPHandler();
 * 
 * // Start the SOCKS proxy on port 1080
 * try (SocksProxy proxy = new SocksProxy(udpHandler, 1080)) {
 *     // The proxy runs and handles client connections
 *     // Add additional logic or monitoring as needed
 * } catch (IOException e) {
 *     e.printStackTrace();
 * }
 * }</pre>
 * 
 * <p>
 * <strong>Thread Safety:</strong>
 * </p>
 * <p>
 * The {@code SocksProxy} class is designed to handle multiple client connections concurrently. It uses
 * an {@link ExecutorService} to manage a pool of threads, ensuring that each client connection is handled
 * in a separate thread. The class maintains thread safety by ensuring that shared resources are
 * appropriately synchronized or are thread-safe by design.
 * </p>
 * 
 * <p>
 * <strong>Dependencies:</strong>
 * </p>
 * <ul>
 *   <li>{@link UDPHandler}: Manages UDP traffic routing through the VPN network.</li>
 *   <li>SLF4J Logging Framework: Used for logging informational, debug, and error messages.</li>
 * </ul>
 * 
 * @author
 * Publius Pseudis
 */
public class SocksProxy implements AutoCloseable {
    /**
     * Logger instance for logging informational, debug, and error messages.
     */
    private static final Logger log = LoggerFactory.getLogger(SocksProxy.class);
    
    /**
     * The server socket that listens for incoming SOCKS5 client connections.
     */
    private final ServerSocket serverSocket;
    
    /**
     * The {@link UDPHandler} instance responsible for managing UDP traffic through the VPN network.
     */
    private final UDPHandler udpHandler;
    
    /**
     * Executor service for handling client connections concurrently using a cached thread pool.
     */
    private final ExecutorService executor;
    
    /**
     * A flag indicating whether the SOCKS proxy server is currently running.
     */
    private volatile boolean running;
    
    // SOCKS protocol constants
    
    /**
     * SOCKS protocol version (0x05 for SOCKS5).
     */
    private static final byte SOCKS_VERSION = 0x05;
    
    /**
     * Authentication method identifier for "No Authentication" (0x00).
     */
    private static final byte AUTH_METHOD_NONE = 0x00;
    
    /**
     * Command identifier for "Connect" (0x01).
     */
    private static final byte CMD_CONNECT = 0x01;
    
    /**
     * Address type identifier for IPv4 addresses (0x01).
     */
    private static final byte ADDR_TYPE_IPV4 = 0x01;
    
    /**
     * Address type identifier for domain names (0x03).
     */
    private static final byte ADDR_TYPE_DOMAIN = 0x03;
    
    /**
     * Constructs a new {@code SocksProxy} instance, initializes the server socket on the specified port,
     * and starts the client acceptance loop.
     *
     * @param udpHandler The {@link UDPHandler} instance for managing UDP traffic.
     * @param port       The port number on which the SOCKS proxy will listen for incoming connections.
     * @throws IOException If an I/O error occurs when opening the server socket.
     */
    public SocksProxy(UDPHandler udpHandler, int port) throws IOException {
        this.udpHandler = udpHandler;
        this.serverSocket = new ServerSocket(port);
        this.executor = Executors.newCachedThreadPool();
        this.running = true;
        
        log.info("SOCKS proxy listening on port {}", port);
        startAcceptLoop();
    }
    
    /**
     * Starts the loop that continuously accepts incoming client connections and delegates them
     * to the executor service for handling.
     */
    private void startAcceptLoop() {
        executor.submit(() -> {
            while (running) {
                try {
                    Socket client = serverSocket.accept();
                    executor.submit(() -> handleClient(client));
                } catch (IOException e) {
                    if (running) {
                        log.error("Error accepting client: {}", e.getMessage());
                    }
                }
            }
        });
    }
    
    /**
     * Handles an individual SOCKS5 client connection by performing the handshake, processing
     * the connection request, and managing the forwarding of traffic.
     *
     * @param client The {@link Socket} representing the connected SOCKS5 client.
     */
    private void handleClient(Socket client) {
       try {
           InputStream in = client.getInputStream();
           OutputStream out = client.getOutputStream();

           // Handle SOCKS5 handshake
           if (!handleHandshake(in, out)) {
               log.error("SOCKS5 handshake failed");
               return;
           }

           // Read connection request
           byte[] requestHeader = new byte[4];
           if (in.read(requestHeader) != 4) {
               log.error("Failed to read SOCKS5 request header");
               sendError(out, (byte) 0x01);
               return;
           }

           if (requestHeader[0] != SOCKS_VERSION || requestHeader[1] != CMD_CONNECT) {
               log.error("Invalid SOCKS5 request or unsupported command");
               sendError(out, (byte) 0x07);
               return;
           }

           // Parse destination address
           byte addrType = requestHeader[3];
           String destAddr;
           int destPort;

           try {
               switch (addrType) {
                   case ADDR_TYPE_IPV4 -> {
                       byte[] addr = new byte[4];
                       if (in.read(addr) != 4) throw new IOException("Failed to read IPv4 address");
                       destAddr = InetAddress.getByAddress(addr).getHostAddress();
                   }
                   case ADDR_TYPE_DOMAIN -> {
                       int len = in.read();
                       if (len <= 0) throw new IOException("Invalid domain name length");
                       byte[] domain = new byte[len];
                       if (in.read(domain) != len) throw new IOException("Failed to read domain name");
                       destAddr = new String(domain);
                   }
                   default -> {
                       log.error("Unsupported address type: {}", addrType);
                       sendError(out, (byte) 0x08);
                       return;
                   }
               }

               byte[] portBytes = new byte[2];
               if (in.read(portBytes) != 2) throw new IOException("Failed to read port");
               destPort = ((portBytes[0] & 0xFF) << 8) | (portBytes[1] & 0xFF);

               log.info("SOCKS5 connection request to {}:{}", destAddr, destPort);

               // Connect to destination
               Socket target = new Socket(destAddr, destPort);
               target.setKeepAlive(true);
               target.setTcpNoDelay(true);

               // Send success response
               byte[] response = {
                   SOCKS_VERSION,
                   0x00, // Success
                   0x00, // Reserved
                   ADDR_TYPE_IPV4,
                   0, 0, 0, 0, // Bind address (0.0.0.0)
                   0, 0       // Bind port
               };
               out.write(response);
               out.flush();

               log.info("Established connection from {}:{} to {}:{}",
                   client.getInetAddress().getHostAddress(),
                   client.getPort(),
                   destAddr,
                   destPort);

               // Start forwarding data
               forwardTraffic(client, target);

           } catch (Exception e) {
               log.error("Error handling SOCKS5 connection: {}", e.getMessage());
               sendError(out, (byte) 0x04);
               return;
           }

       } catch (IOException e) {
           log.error("Error handling client: {}", e.getMessage());
       } finally {
           try {
               client.close();
           } catch (IOException e) {
               log.debug("Error closing client socket: {}", e.getMessage());
           }
       }
   }
    
    /**
     * Handles the SOCKS5 handshake by negotiating the authentication method with the client.
     *
     * @param in  The {@link InputStream} from the client.
     * @param out The {@link OutputStream} to the client.
     * @return {@code true} if the handshake was successful and "No Authentication" was selected; {@code false} otherwise.
     * @throws IOException If an I/O error occurs during the handshake.
     */
    private boolean handleHandshake(InputStream in, OutputStream out) throws IOException {
        // Read SOCKS version
        int version = in.read();
        if (version != SOCKS_VERSION) {
            log.warn("Unsupported SOCKS version: {}", version);
            return false;
        }
        
        // Read number of authentication methods
        int methodCount = in.read();
        if (methodCount <= 0) {
            log.warn("No authentication methods provided by client.");
            return false;
        }
        
        // Read authentication methods
        byte[] methods = new byte[methodCount];
        if (in.read(methods) != methodCount) {
            log.warn("Failed to read authentication methods.");
            return false;
        }
        
        // Check if "No Authentication" is supported
        boolean noAuthSupported = false;
        for (byte method : methods) {
            if (method == AUTH_METHOD_NONE) {
                noAuthSupported = true;
                break;
            }
        }
        
        if (!noAuthSupported) {
            // No acceptable authentication methods
            out.write(new byte[]{SOCKS_VERSION, (byte) 0xFF});
            log.warn("Client does not support 'No Authentication' method.");
            return false;
        }
        
        // Respond with "No Authentication" selected
        out.write(new byte[]{SOCKS_VERSION, AUTH_METHOD_NONE});
        return true;
    }
    
    /**
     * Sends an error response to the client with the specified error code.
     *
     * @param out   The {@link OutputStream} to the client.
     * @param error The error code to send, as defined by the SOCKS5 protocol.
     * @throws IOException If an I/O error occurs while sending the error response.
     */
    private void sendError(OutputStream out, byte error) throws IOException {
        byte[] response = {
            SOCKS_VERSION,
            error,
            0x00, // Reserved
            ADDR_TYPE_IPV4,
            0, 0, 0, 0, // Bind address (0.0.0.0)
            0, 0       // Bind port
        };
        out.write(response);
    }
    
    /**
     * Forwards traffic between two sockets by continuously reading from the input socket and writing to the output socket.
     *
     * @param input  The {@link Socket} to read data from.
     * @param output The {@link Socket} to write data to.
     */
    private void forwardTraffic(Socket client, Socket target) {
        log.debug("Starting traffic forwarding between {} and {}", 
            client.getRemoteSocketAddress(), 
            target.getRemoteSocketAddress());

        Thread clientToTarget = new Thread(() -> {
            try {
                InputStream in = client.getInputStream();
                OutputStream out = target.getOutputStream();
                byte[] buffer = new byte[8192];
                int bytesRead;

                while ((bytesRead = in.read(buffer)) != -1) {
                    log.debug("Client -> Target: {} bytes", bytesRead);
                    out.write(buffer, 0, bytesRead);
                    out.flush();
                }
            } catch (IOException e) {
                log.debug("Client -> Target stream closed: {}", e.getMessage());
            }
        });

        Thread targetToClient = new Thread(() -> {
            try {
                InputStream in = target.getInputStream();
                OutputStream out = client.getOutputStream();
                byte[] buffer = new byte[8192];
                int bytesRead;

                while ((bytesRead = in.read(buffer)) != -1) {
                    log.debug("Target -> Client: {} bytes", bytesRead);
                    out.write(buffer, 0, bytesRead);
                    out.flush();
                }
            } catch (IOException e) {
                log.debug("Target -> Client stream closed: {}", e.getMessage());
            }
        });

        clientToTarget.start();
        targetToClient.start();

        try {
            clientToTarget.join();
            targetToClient.join();
        } catch (InterruptedException e) {
            log.warn("Traffic forwarding interrupted");
        } finally {
            try {
                client.close();
                target.close();
            } catch (IOException e) {
                log.debug("Error closing sockets: {}", e.getMessage());
            }
        }
    }
    
    /**
     * Closes the SOCKS proxy server by stopping the acceptance loop, closing the server socket,
     * shutting down the executor service, and releasing all associated resources.
     */
    @Override
    public void close() {
        running = false;
        try {
            serverSocket.close();
        } catch (IOException ignored) {}
        executor.shutdownNow();
        log.info("SOCKS proxy has been shut down.");
    }
}

=============================================

/*
 * Copyright (C) 2024 Publius Pseudis
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.publiuspseudis.esadvpn.routing;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * <p>
 * The {@code RouteInfo} class encapsulates routing information and associated metrics for a specific
 * destination within the peer-to-peer (P2P) VPN network. It maintains details such as the next hop
 * peer, hop count, pheromone levels (used for routing decisions), latency, and bandwidth estimates.
 * This class is instrumental in determining the optimal paths for routing packets through the network
 * based on current network conditions and historical data.
 * </p>
 * 
 * <p>
 * <strong>Key Functionalities:</strong></p>
 * <ul>
 *   <li>Maintaining and updating routing metrics such as latency and bandwidth.</li>
 *   <li>Calculating route scores based on normalized metrics and pheromone levels.</li>
 *   <li>Applying pheromone decay to simulate the evaporation of route desirability over time.</li>
 *   <li>Reinforcing routes based on successful usage to increase their desirability.</li>
 * </ul>
 * 
 * 
 * <p>
 * <strong>Example Usage:</strong>
 * </p>
 * <pre>{@code
 * // Create a new RouteInfo instance for a destination network
 * String destination = "192.168.1.0/24";
 * String nextHop = "Peer[192.168.1.100:8081]";
 * int hopCount = 2;
 * RouteInfo route = new RouteInfo(destination, nextHop, hopCount);
 * 
 * // Update routing metrics based on network activity
 * double observedLatency = 50.5; // in milliseconds
 * long observedBandwidth = 1024000; // in bytes per second
 * route.updateMetrics(observedLatency, observedBandwidth);
 * 
 * // Calculate the current route score
 * double score = route.getRouteScore();
 * 
 * // Apply pheromone decay over time
 * route.decayPheromone();
 * 
 * // Reinforce the route based on successful usage
 * double reinforcementQuality = 0.2;
 * route.reinforcePath(reinforcementQuality);
 * }</pre>
 * 
 * <p>
 * <strong>Thread Safety:</strong>
 * </p>
 * <p>
 * The {@code RouteInfo} class employs synchronization mechanisms to ensure thread-safe updates
 * to its mutable fields. Fields such as {@code latency} and {@code bandwidth} are marked as
 * {@code volatile} to guarantee visibility across threads. Additionally, atomic operations and
 * careful update sequences are used to maintain data integrity during concurrent modifications.
 * </p>
 * 
 * <p>
 * <strong>Dependencies:</strong>
 * </p>
 * <ul>
 *   <li>SLF4J Logging Framework: Utilized for logging debug and informational messages.</li>
 * </ul>
 * 
 * @author
 * Publius Pseudis
 */
public class RouteInfo {
    /**
     * Logger instance for logging debug and informational messages.
     */
    private static final Logger log = LoggerFactory.getLogger(RouteInfo.class);
    
    /**
     * The IP address or subnet representing the destination network.
     */
    private final String destination; // Destination network/IP

    /**
     * The identifier of the next hop peer through which packets to the destination should be routed.
     */
    private final String nextHop;
    
    /**
     * The number of hops required to reach the destination from the current peer.
     */
    private final int hopCount;
    
    /**
     * The current pheromone level associated with this route. Higher pheromone levels indicate more
     * desirable routes based on historical usage and network conditions.
     */
    private double pheromoneLevel;
    
    /**
     * The latest measured latency to the next hop peer in milliseconds.
     */
    private volatile double latency;
    
    /**
     * The estimated bandwidth of the connection to the next hop peer in bytes per second.
     */
    private volatile long bandwidth;
    
    /**
     * The timestamp indicating when the routing metrics were last updated.
     */
    private long lastUpdated;
    
    // Constants for route scoring
    
    /**
     * The decay factor applied to pheromone levels to simulate the evaporation of route desirability
     * over time. A value less than 1.0 reduces the pheromone level each time decay is applied.
     */
    private static final double PHEROMONE_DECAY = 0.95;  // Pheromone decay factor
    
    /**
     * The minimum pheromone level that a route can have. If pheromone levels fall below this threshold,
     * they are set to this minimum value to prevent routes from becoming completely obsolete.
     */
    private static final double MIN_PHEROMONE = 0.01;    // Minimum pheromone level
    
    /**
     * The initial pheromone level assigned to a new route upon creation. This provides a baseline
     * desirability for newly discovered routes.
     */
    private static final double INIT_PHEROMONE = 1.0;    // Initial pheromone level
        
    /**
     * Constructs a new {@code RouteInfo} instance with the specified destination, next hop, and hop count.
     * Initializes routing metrics to default values.
     *
     * @param destination The destination network or IP address.
     * @param nextHop     The identifier of the next hop peer.
     * @param hopCount    The number of hops to reach the destination.
     */
    public RouteInfo(String destination, String nextHop, int hopCount) {
        this.destination = destination;
        this.nextHop = nextHop;
        this.hopCount = hopCount;
        this.pheromoneLevel = INIT_PHEROMONE;
        this.lastUpdated = System.currentTimeMillis();
        this.latency = 0;
        this.bandwidth = 0;
    }
    
    /**
     * Updates the routing metrics for this route based on newly observed latency and bandwidth values.
     * Implements an exponential moving average for latency to smooth out fluctuations and uses the
     * highest observed bandwidth to provide a conservative estimate.
     *
     * @param newLatency    The newly observed latency in milliseconds.
     * @param newBandwidth  The newly observed bandwidth in bytes per second.
     */
    public void updateMetrics(double newLatency, long newBandwidth) {
        // Update latency with exponential moving average
        if (this.getLatency() == Double.MAX_VALUE) {
            this.latency = newLatency;
        } else {
            this.latency = (this.getLatency() * 0.7) + (newLatency * 0.3);
        }
        
        // Update bandwidth (use highest observed)
        this.bandwidth = Math.max(this.getBandwidth(), newBandwidth);
        this.lastUpdated = System.currentTimeMillis();
    }
    
    /**
     * Calculates and returns the current score of the route based on normalized latency, bandwidth,
     * and hop count metrics, weighted by their respective importance. The pheromone level further
     * influences the overall desirability of the route.
     *
     * @return The calculated route score as a {@code double}.
     */
    public double getScore() {
        double latencyScore = 1.0 / (1 + getLatency());
        double bandwidthScore = Math.log1p(getBandwidth()) / 10.0;
        double hopScore = 1.0 / (1 + getHopCount());
        
        return (latencyScore * 0.4 + bandwidthScore * 0.4 + hopScore * 0.2) 
               * getPheromoneLevel();
    }

    /**
     * Applies pheromone decay to simulate the evaporation of route desirability over time.
     * The pheromone level is multiplied by the decay factor, and if it falls below the minimum
     * threshold, it is set to the minimum value to maintain a base level of desirability.
     */
    public void decayPheromone() {
        pheromoneLevel *= getPHEROMONE_DECAY();
        if (getPheromoneLevel() < getMIN_PHEROMONE()) {
            pheromoneLevel = getMIN_PHEROMONE();
        }
    }
    
    /**
     * Reinforces the desirability of the route based on successful usage by increasing the pheromone level.
     * This method should be called when the route is utilized effectively to encourage its selection
     * in future routing decisions.
     *
     * @param quality A {@code double} representing the quality or effectiveness of the route usage.
     */
    public void reinforcePath(double quality) {
        pheromoneLevel += quality;
    }
    
    /**
     * Calculates and returns the overall route score based on normalized latency, bandwidth, and hop count
     * metrics, combined with the pheromone level. This method provides a comprehensive measure of the
     * route's current desirability for packet forwarding.
     *
     * @return The overall route score as a {@code double}.
     */
    public double getRouteScore() {
        // Normalize metrics to 0-1 range
        double latencyScore = 1.0 / (1 + getLatency());
        double bandwidthScore = Math.log1p(getBandwidth()) / 10.0;
        double hopScore = 1.0 / (1 + getHopCount());
        
        // Weighted combination of metrics
        return (latencyScore * 0.4 + bandwidthScore * 0.4 + hopScore * 0.2) 
               * getPheromoneLevel();
    }

    // Getters

    /**
     * Retrieves the destination network or IP address associated with this route.
     *
     * @return A {@code String} representing the destination.
     */
    public String getDestination() { return destination; }
    
    /**
     * Retrieves the identifier of the next hop peer for this route.
     *
     * @return A {@code String} representing the next hop peer.
     */
    public String getNextHop() { return nextHop; }
    
    /**
     * Retrieves the current pheromone level of this route.
     *
     * @return A {@code double} representing the pheromone level.
     */
    public double getPheromoneLevel() { return pheromoneLevel; }
    
    /**
     * Retrieves the number of hops required to reach the destination from this route.
     *
     * @return An {@code int} representing the hop count.
     */
    public int getHopCount() { return hopCount; }
    
    /**
     * Retrieves the timestamp of the last update to the routing metrics.
     *
     * @return A {@code long} representing the last updated time in milliseconds since the epoch.
     */
    public long getLastUpdated() { return lastUpdated; }
    
    /**
     * Retrieves the current latency metric for this route.
     *
     * @return A {@code double} representing the latency in milliseconds.
     */
    public double getLatency() { return latency; }
    
    /**
     * Retrieves the current bandwidth estimate for this route.
     *
     * @return A {@code long} representing the bandwidth in bytes per second.
     */
    public long getBandwidth() { return bandwidth; }
    
    /**
     * Provides a string representation of the {@code RouteInfo} instance, detailing its destination,
     * next hop, hop count, pheromone level, latency, and bandwidth.
     *
     * @return A {@code String} summarizing the route information.
     */
    @Override
    public String toString() {
        return String.format("RouteInfo[destination=%s, nextHop=%s, hopCount=%d, pheromoneLevel=%.3f, latency=%.2fms, bandwidth=%d B/s]", getDestination(), getNextHop(), getHopCount(), getPheromoneLevel(), getLatency(), getBandwidth());
    }

    /**
     * @return the PHEROMONE_DECAY
     */
    public static double getPHEROMONE_DECAY() {
        return PHEROMONE_DECAY;
    }

    /**
     * @return the MIN_PHEROMONE
     */
    public static double getMIN_PHEROMONE() {
        return MIN_PHEROMONE;
    }

    /**
     * @return the INIT_PHEROMONE
     */
    public static double getINIT_PHEROMONE() {
        return INIT_PHEROMONE;
    }

    public void setPheramoneLevel(double pheromoneLevel_) {
        this.pheromoneLevel = pheromoneLevel_;
    }

    public void setLatency(double latency_) {
        this.latency = latency_;
    }

    public void setBandwidth(long bandwidth_) {
        this.bandwidth = bandwidth_;
    }
}

=============================================

/*
 * Copyright (C) 2024 Publius Pseudis
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.publiuspseudis.esadvpn.routing;

import java.nio.ByteBuffer;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * <p>
 * The {@code SwarmRouter} class implements swarm intelligence-based routing mechanisms for the peer-to-peer
 * (P2P) VPN network. It manages routing tables, pheromone trails, and route metrics to determine the optimal
 * paths for data packets through the network. By leveraging principles inspired by swarm intelligence, the
 * router adapts to changing network conditions, reinforcing successful routes and decaying less effective ones.
 * </p>
 * 
 * <p>
 * <strong>Key Functionalities:</strong></p>
 * <ul>
 *   <li>Maintaining and updating routing tables for various destinations and next-hop peers.</li>
 *   <li>Managing pheromone trails to influence route selection based on historical performance.</li>
 *   <li>Calculating route scores based on latency, bandwidth, hop count, and pheromone levels.</li>
 *   <li>Handling packet routing by enqueueing packets for respective peers.</li>
 *   <li>Evaporating pheromones over time to simulate the fading of route desirability.</li>
 *   <li>Cleaning up stale routes that have not been used within a specified timeout period.</li>
 *   <li>Exporting the current state of the router for persistence or transfer purposes.</li>
 * </ul>
 * 
 * 
 * <p>
 * <strong>Example Usage:</strong>
 * </p>
 * <pre>{@code
 * // Initialize SwarmRouter
 * SwarmRouter router = new SwarmRouter();
 * 
 * // Update routes based on discovered peers
 * router.updateRoute("192.168.1.0/24", "PeerA", 2);
 * router.updateRoute("192.168.1.0/24", "PeerB", 3);
 * 
 * // Update route metrics based on observed performance
 * router.updateMetrics("192.168.1.0/24", "PeerA", 50.5, 1024000);
 * router.updateMetrics("192.168.1.0/24", "PeerB", 70.2, 512000);
 * 
 * // Select the next hop for a destination
 * String nextHop = router.getNextHop("192.168.1.0/24");
 * if (nextHop != null) {
 *     // Forward packet to nextHop
 * }
 * 
 * // Periodically evaporate pheromones and clean up routes
 * router.evaporatePheromones();
 * router.cleanupRoutes();
 * 
 * // Export router state
 * Map<String, Object> state = router.exportState();
 * }</pre>
 * 
 * <p>
 * <strong>Thread Safety:</strong>
 * </p>
 * <p>
 * The {@code SwarmRouter} class employs thread-safe data structures such as {@link ConcurrentHashMap} and
 * {@link LinkedBlockingQueue} to manage routing tables, pheromone trails, and packet queues. This ensures
 * that multiple threads can safely interact with the router concurrently without risking data inconsistencies
 * or race conditions.
 * </p>
 * 
 * <p>
 * <strong>Dependencies:</strong>
 * </p>
 * <ul>
 *   <li>SLF4J Logging Framework: Utilized for logging informational, debug, and error messages.</li>
 * </ul>
 * 
 * @author 
 * Publius Pseudis
 */
public class SwarmRouter {
    /**
     * Logger instance for logging informational, debug, and error messages.
     */
    private static final Logger log = LoggerFactory.getLogger(SwarmRouter.class);
    
    /**
     * Routing table mapping destinations to their respective routes and next-hop peers.
     * <p>
     * Structure: Destination -> (NextHop -> {@link RouteInfo})
     * </p>
     */
    private final Map<String, Map<String, RouteInfo>> routingTable;
    
    /**
     * Pheromone trails tracking the desirability of routes.
     * <p>
     * Each entry maps a destination-nextHop combination to its pheromone level.
     * </p>
     */
    private final Map<String, Double> pheromoneTrails;
    
    /**
     * Queue for incoming data packets to be routed.
     */
    private final BlockingQueue<ByteBuffer> packetQueue = new LinkedBlockingQueue<>();
    
    /**
     * Tracks the last usage timestamp of each route.
     * <p>
     * Used to identify and clean up stale routes.
     * Structure: Destination-NextHop -> LastUsedTimestamp
     * </p>
     */
    private final Map<String, Long> routeLastUsed;
    
    /**
     * Packet queues for each peer, facilitating the forwarding of data packets to the respective peers.
     * <p>
     * Structure: PeerId -> Queue of ByteBuffers
     * </p>
     */
    private final Map<String, BlockingQueue<ByteBuffer>> peerQueues;
    
    // Routing constants
    
    /**
     * The amount of pheromone deposited on a successful route update.
     */
    private static final double PHEROMONE_DEPOSIT = 1.0;
    
    /**
     * The decay factor applied to pheromone trails to simulate the evaporation of route desirability over time.
     */
    private static final double PHEROMONE_DECAY = 0.95;
    
    /**
     * The minimum pheromone level that a route can have.
     * <p>
     * Ensures that routes do not become completely obsolete.
     * </p>
     */
    private static final double MIN_PHEROMONE = 0.01;
    
    /**
     * The timeout duration after which a route is considered stale if not used.
     * <p>
     * Specified in milliseconds.
     * </p>
     */
    private static final long ROUTE_TIMEOUT = TimeUnit.MINUTES.toMillis(30);
    
    /**
     * Constructs a new {@code SwarmRouter} instance, initializing routing tables, pheromone trails,
     * and packet queues.
     */
    public SwarmRouter() {
        this.routingTable = new ConcurrentHashMap<>();
        this.pheromoneTrails = new ConcurrentHashMap<>();
        this.routeLastUsed = new ConcurrentHashMap<>();
        this.peerQueues = new ConcurrentHashMap<>();
    }
    
    /**
     * Adds a new route or updates an existing one based on the destination, next hop, and hop count.
     * <p>
     * If the new route has a lower hop count, it replaces the existing route.
     * </p>
     *
     * @param destination The destination network or IP address.
     * @param nextHop     The identifier of the next hop peer.
     * @param hopCount    The number of hops to reach the destination.
     */
    public void updateRoute(String destination, String nextHop, int hopCount) {
        Map<String, RouteInfo> routes = routingTable.computeIfAbsent(
            destination, k -> new ConcurrentHashMap<>());
        
        routes.compute(nextHop, (k, v) -> {
            if (v == null || v.getHopCount() > hopCount) {
                return new RouteInfo(destination, nextHop, hopCount);
            }
            return v;
        });
    }
    
    /**
     * Updates the routing metrics for a specific route based on observed latency and bandwidth.
     * <p>
     * Reinforces the pheromone trail of the route based on its performance.
     * </p>
     *
     * @param destination The destination network or IP address.
     * @param nextHop     The identifier of the next hop peer.
     * @param latency     The observed latency in milliseconds.
     * @param bandwidth   The observed bandwidth in bytes per second.
     */
    public void updateMetrics(String destination, String nextHop, 
                            double latency, long bandwidth) {
        Map<String, RouteInfo> routes = routingTable.get(destination);
        if (routes != null) {
            RouteInfo route = routes.get(nextHop);
            if (route != null) {
                route.updateMetrics(latency, bandwidth);
                
                // Reinforce successful route
                String key = destination + "-" + nextHop;
                double currentPheromone = pheromoneTrails.getOrDefault(key, 1.0);
                
                // Calculate reinforcement based on performance
                double latencyScore = 1.0 / (1 + latency);
                double bandwidthScore = Math.log1p(bandwidth) / 10.0;
                double reinforcement = PHEROMONE_DEPOSIT * 
                    (latencyScore * 0.6 + bandwidthScore * 0.4);
                
                pheromoneTrails.put(key, currentPheromone + reinforcement);
                routeLastUsed.put(key, System.currentTimeMillis());
            }
        }
    }
    
    /**
     * Determines the next hop peer for a given destination based on route scores and pheromone trails.
     * <p>
     * Utilizes a probabilistic selection mechanism influenced by pheromone levels to choose the most
     * suitable next hop.
     * </p>
     *
     * @param destination The destination network or IP address.
     * @return The identifier of the selected next hop peer, or {@code null} if no route is available.
     */
    public String getNextHop(String destination) {
        Map<String, RouteInfo> routes = routingTable.get(destination);
        if (routes == null || routes.isEmpty()) {
            // If no specific route found, use default route
            // For internet traffic, route to the initiator node (10.0.0.1)
            routes = routingTable.get("10.0.0.1");
            if (routes == null || routes.isEmpty()) {
                log.debug("No route to {}", destination);
                return null;
            }
        }
        
        // Use probability based on route scores
        double totalScore = 0;
        Map<String, Double> scores = new ConcurrentHashMap<>();
        
        for (Map.Entry<String, RouteInfo> entry : routes.entrySet()) {
            String nextHop = entry.getKey();
            RouteInfo route = entry.getValue();
            
            double pheromone = pheromoneTrails.getOrDefault(
                destination + "-" + nextHop, MIN_PHEROMONE);
            double score = route.getScore() * pheromone;
            
            scores.put(nextHop, score);
            totalScore += score;
        }
        
        // Probabilistic selection based on scores
        double random = Math.random() * totalScore;
        double cumulative = 0;
        
        for (Map.Entry<String, Double> entry : scores.entrySet()) {
            cumulative += entry.getValue();
            if (random <= cumulative) {
                return entry.getKey();
            }
        }
        
        // Fallback to highest scoring route
        return routes.entrySet().stream()
            .max((a, b) -> Double.compare(
                scores.getOrDefault(a.getKey(), 0.0),
                scores.getOrDefault(b.getKey(), 0.0)))
            .map(Map.Entry::getKey)
            .orElse(null);
    }

    /**
     * Applies pheromone decay to all pheromone trails, simulating the natural evaporation of route
     * desirability over time. Ensures that routes not reinforced by successful usage gradually become
     * less preferable.
     */
    public void evaporatePheromones() {
        pheromoneTrails.replaceAll((k, v) -> 
            Math.max(MIN_PHEROMONE, v * PHEROMONE_DECAY));
    }
    
    /**
     * Cleans up stale routes that have not been used within the specified timeout period.
     * <p>
     * Removes both the route from the routing table and its associated pheromone trail to maintain an
     * up-to-date and efficient routing state.
     * </p>
     */
    public void cleanupRoutes() {
        long now = System.currentTimeMillis();
        
        // Remove expired routes
        routeLastUsed.entrySet().removeIf(entry ->
            now - entry.getValue() > ROUTE_TIMEOUT);
            
        // Clean up orphaned pheromone trails
        pheromoneTrails.entrySet().removeIf(entry ->
            !routeLastUsed.containsKey(entry.getKey()));
    }
    
    /**
     * Enqueues a data packet to be routed to a specific peer. Ensures that each peer has its own
     * packet queue for orderly and efficient packet forwarding.
     *
     * @param packet The {@link ByteBuffer} containing the data packet to be routed.
     * @param peerId The identifier of the peer to which the packet should be sent.
     */
    public void routePacket(ByteBuffer packet, String peerId) {
        packetQueue.offer(packet);
    }
    
    /**
     * Retrieves the next available data packet to be sent to any peer.
     * <p>
     * Implements a simple polling mechanism to retrieve packets from the queue in a sequential manner.
     * </p>
     *
     * @return The next {@link ByteBuffer} packet to be sent, or {@code null} if no packets are available within the timeout.
     * @throws InterruptedException If the thread is interrupted while waiting for a packet.
     */
    public ByteBuffer getNextPacket() throws InterruptedException {
        // Try to get a packet with a timeout to prevent busy waiting
        return packetQueue.poll(100, TimeUnit.MILLISECONDS);
    }
    
    /**
     * Removes a peer from the router, including its routes, pheromone trails, and packet queue.
     * <p>
     * Ensures that all routing information associated with the peer is cleaned up to prevent
     * stale or invalid routes.
     * </p>
     *
     * @param peerId The identifier of the peer to be removed.
     */
    public void removePeer(String peerId) {
        // Remove from routing table
        routingTable.values().forEach(routes -> routes.remove(peerId));
        
        // Remove pheromone trails
        pheromoneTrails.entrySet().removeIf(entry -> 
            entry.getKey().contains(peerId));
            
        // Remove queue
        peerQueues.remove(peerId);
        
        log.info("Removed peer {}", peerId);
    }
    
    /**
     * Retrieves a snapshot of all current routes managed by the router.
     * <p>
     * This includes all destinations and their associated next-hop peers with routing information.
     * </p>
     *
     * @return A {@link Map} representing the current routing table.
     */
    public Map<String, Map<String, RouteInfo>> getRoutes() {
        return new HashMap<>(routingTable);
    }
    
    /**
     * Calculates and retrieves the highest route score for a specific peer across all destinations.
     * <p>
     * This score represents the best performance metric of the peer based on current routing metrics.
     * </p>
     *
     * @param peerId The identifier of the peer whose score is to be retrieved.
     * @return The highest route score for the specified peer, or {@code 0.0} if no routes are found.
     */
    public double getScore(String peerId) {
        double maxScore = 0.0;
        for (Map<String, RouteInfo> routes : routingTable.values()) {
            RouteInfo route = routes.get(peerId);
            if (route != null) {
                maxScore = Math.max(maxScore, route.getScore());
            }
        }
        return maxScore;
    }

    /**
     * Exports the current state of the router, including routing tables, pheromone trails,
     * and route usage timestamps. This can be used for persistence, backup, or transferring
     * the routing state to another instance.
     *
     * @return A {@link Map} representing the serialized state of the router.
     */
    public Map<String, Object> exportState() {
        Map<String, Object> state = new HashMap<>();
        state.put("routingTable", new HashMap<>(routingTable));
        state.put("pheromoneTrails", new HashMap<>(pheromoneTrails));
        state.put("routeLastUsed", new HashMap<>(routeLastUsed));
        return state;
    }
}

=============================================

/*
 * Copyright (C) 2024 Publius Pseudis
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.publiuspseudis.esadvpn.network;

import java.nio.ByteBuffer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * <p>
 * The {@code IPPacket} class is responsible for handling IPv4 packet processing within the VPN framework.
 * It provides functionalities to create, serialize, deserialize, and validate IPv4 packets.
 * </p>
 *
 * <p>
 * This class manages the construction and interpretation of IPv4 headers, including fields such as
 * version, header length, type of service, total length, identification, flags, fragment offset,
 * time to live (TTL), protocol, checksum, source IP, and destination IP. Additionally, it supports
 * payload extraction and checksum verification to ensure data integrity.
 * </p>
 *
 * <p>
 * <strong>Example Usage:</strong>
 * </p>
 * <pre>{@code
 * // Creating a payload
 * ByteBuffer payload = ByteBuffer.wrap(new byte[]{/* payload data * /});
 * 
 * // Defining source and destination IP addresses
 * byte[] sourceIP = {(byte)192, (byte)168, 1, 2};
 * byte[] destIP = {(byte)192, (byte)168, 1, 3};
 * 
 * // Creating an IPPacket instance
 * IPPacket ipPacket = IPPacket.create(IPPacket.PROTO_TCP, sourceIP, destIP, payload);
 * 
 * // Serializing the packet for transmission
 * ByteBuffer serializedPacket = ipPacket.getPacket();
 * 
 * // Deserializing the packet upon reception
 * IPPacket receivedPacket = new IPPacket(serializedPacket);
 * 
 * // Verifying the checksum
 * boolean isValid = receivedPacket.verifyChecksum();
 * 
 * // Accessing payload
 * ByteBuffer receivedPayload = receivedPacket.getPayload();
 * }</pre>
 * 
 * @author
 * Publius Pseudis
 * 
 * @version 1.0
 * @since 2024-01-01
 */
public class IPPacket {
    /**
     * Logger instance for logging information, warnings, and errors.
     */
    private static final Logger log = LoggerFactory.getLogger(IPPacket.class);
    
    // IP header offsets
    /**
     * Offset for the IP version field within the header.
     */
    private static final int VERSION_OFFSET = 0;
    
    /**
     * Offset for the Internet Header Length (IHL) field within the header.
     */
    private static final int IHL_OFFSET = 0;
    
    /**
     * Offset for the Type of Service (ToS) field within the header.
     */
    private static final int TOS_OFFSET = 1;
    
    /**
     * Offset for the Total Length field within the header.
     */
    private static final int TOTAL_LENGTH_OFFSET = 2;
    
    /**
     * Offset for the Identification field within the header.
     */
    private static final int ID_OFFSET = 4;
    
    /**
     * Offset for the Flags field within the header.
     */
    private static final int FLAGS_OFFSET = 6;
    
    /**
     * Offset for the Time To Live (TTL) field within the header.
     */
    private static final int TTL_OFFSET = 8;
    
    /**
     * Offset for the Protocol field within the header.
     */
    private static final int PROTOCOL_OFFSET = 9;
    
    /**
     * Offset for the Header Checksum field within the header.
     */
    private static final int CHECKSUM_OFFSET = 10;
    
    /**
     * Offset for the Source IP Address field within the header.
     */
    private static final int SRC_IP_OFFSET = 12;
    
    /**
     * Offset for the Destination IP Address field within the header.
     */
    private static final int DST_IP_OFFSET = 16;
    
    // IP protocols
    /**
     * Protocol number for Internet Control Message Protocol (ICMP).
     */
    public static final int PROTO_ICMP = 1;
    
    /**
     * Protocol number for Transmission Control Protocol (TCP).
     */
    public static final int PROTO_TCP = 6;
    
    /**
     * Protocol number for User Datagram Protocol (UDP).
     */
    public static final int PROTO_UDP = 17;
    
    /**
     * The {@code ByteBuffer} containing the entire IP packet, including headers and payload.
     */
    private final ByteBuffer packet;
    
    /**
     * The length of the IP header in bytes.
     */
    private final int headerLength;
    
    /**
     * Constructs a new {@code IPPacket} instance by wrapping the provided {@code ByteBuffer}.
     * It calculates the header length based on the Internet Header Length (IHL) field.
     *
     * @param packet The {@code ByteBuffer} containing the IP packet data.
     */
    public IPPacket(ByteBuffer packet) {
        this.packet = packet;
        this.headerLength = (packet.get(IHL_OFFSET) & 0x0F) * 4;
    }
    
    /**
     * Creates a new IP packet with the specified protocol, source IP, destination IP, and payload.
     * It constructs the IPv4 header, appends the payload, and calculates the checksum.
     *
     * @param protocol The protocol number (e.g., {@code PROTO_TCP}, {@code PROTO_UDP}).
     * @param sourceIP A byte array representing the source IP address (4 bytes).
     * @param destIP   A byte array representing the destination IP address (4 bytes).
     * @param payload  A {@code ByteBuffer} containing the payload data.
     * @return A new {@code IPPacket} instance representing the constructed IP packet.
     */
    public static IPPacket create(int protocol, byte[] sourceIP, byte[] destIP, ByteBuffer payload) {
        ByteBuffer packet = ByteBuffer.allocate(20 + payload.remaining());
        
        // Version and IHL
        packet.put((byte) 0x45);  // IPv4, 5 words header
        
        // Type of Service (ToS)
        packet.put((byte) 0);
        
        // Total Length
        packet.putShort((short) (20 + payload.remaining()));
        
        // Identification
        packet.putShort((short) 0);
        
        // Flags and Fragment Offset
        packet.putShort((short) 0x4000);  // Don't fragment
        
        // Time To Live (TTL)
        packet.put((byte) 64);
        
        // Protocol
        packet.put((byte) protocol);
        
        // Header Checksum (initially 0)
        packet.putShort((short) 0);
        
        // Source IP Address
        packet.put(sourceIP);
        
        // Destination IP Address
        packet.put(destIP);
        
        // Payload
        packet.put(payload);
        packet.flip();
        
        // Calculate and update checksum
        updateChecksum(packet);
        
        return new IPPacket(packet);
    }
    
    /**
     * Retrieves the source IP address from the IP packet.
     *
     * @return An integer representing the source IP address.
     */
    public int getSourceIP() {
        return packet.getInt(SRC_IP_OFFSET);
    }
    
    /**
     * Retrieves the destination IP address from the IP packet.
     *
     * @return An integer representing the destination IP address.
     */
    public int getDestinationIP() {
        return packet.getInt(DST_IP_OFFSET);
    }
    
    /**
     * Retrieves the protocol number from the IP packet.
     *
     * @return An integer representing the protocol number.
     */
    public int getProtocol() {
        return packet.get(PROTOCOL_OFFSET) & 0xFF;
    }
    
    /**
     * Retrieves the payload data from the IP packet.
     *
     * @return A {@code ByteBuffer} containing the payload data.
     */
    public ByteBuffer getPayload() {
        ByteBuffer payload = packet.duplicate();
        payload.position(headerLength);
        return payload.slice();
    }
    
    /**
     * Retrieves the entire packet data, including headers and payload.
     *
     * @return A duplicate {@code ByteBuffer} of the entire IP packet.
     */
    public ByteBuffer getPacket() {
        return packet.duplicate();
    }
    
    /**
     * Updates the IP header checksum based on the current state of the packet.
     * This method calculates the checksum by summing all 16-bit words in the header,
     * adding any carry-over bits, and then taking the one's complement of the sum.
     *
     * @param packet The {@code ByteBuffer} containing the IP packet data.
     */
    private static void updateChecksum(ByteBuffer packet) {
        // Clear existing checksum
        packet.putShort(CHECKSUM_OFFSET, (short) 0);
        
        // Calculate checksum
        int sum = 0;
        int position = packet.position();
        packet.position(0);
        
        while (packet.hasRemaining()) {
            if (packet.remaining() >= 2) {
                sum += packet.getShort() & 0xFFFF;
            } else {
                sum += (packet.get() & 0xFF) << 8;
            }
        }
        
        // Add carry bits
        sum = (sum >> 16) + (sum & 0xFFFF);
        sum += (sum >> 16);
        
        // Store checksum
        packet.putShort(CHECKSUM_OFFSET, (short) ~sum);
        packet.position(position);
    }
    
    /**
     * Verifies the IP header checksum to ensure the integrity of the packet.
     * This method recalculates the checksum and compares it with the original value.
     *
     * @return {@code true} if the checksum is valid; {@code false} otherwise.
     */
    public boolean verifyChecksum() {
        int original = packet.getShort(CHECKSUM_OFFSET) & 0xFFFF;
        
        // Calculate checksum
        packet.putShort(CHECKSUM_OFFSET, (short) 0);
        int sum = 0;
        int position = packet.position();
        packet.position(0);
        
        while (packet.hasRemaining()) {
            if (packet.remaining() >= 2) {
                sum += packet.getShort() & 0xFFFF;
            } else {
                sum += (packet.get() & 0xFF) << 8;
            }
        }
        
        // Restore original checksum and position
        packet.putShort(CHECKSUM_OFFSET, (short) original);
        packet.position(position);
        
        // Add carry bits
        sum = (sum >> 16) + (sum & 0xFFFF);
        sum += (sum >> 16);
        
        return (short) ~sum == original;
    }
    
    /**
     * Formats an IP address from its integer representation to the standard dotted-decimal notation.
     *
     * @param ip An integer representing the IP address.
     * @return A {@code String} in the format "x.x.x.x" representing the IP address.
     */
    public static String formatIP(int ip) {
        return String.format("%d.%d.%d.%d",
            (ip >> 24) & 0xFF,
            (ip >> 16) & 0xFF,
            (ip >> 8) & 0xFF,
            ip & 0xFF);
    }
    
    /**
     * Provides a string representation of the IP packet, including source and destination IPs,
     * protocol number, and total length.
     *
     * @return A {@code String} describing the IP packet.
     */
    @Override
    public String toString() {
        return String.format("IP[%s -> %s, proto=%d, len=%d]",
            formatIP(getSourceIP()),
            formatIP(getDestinationIP()),
            getProtocol(),
            packet.limit());
    }
}

=============================================

/*
 * Copyright (C) 2024 Publius Pseudis
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.publiuspseudis.esadvpn.network;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.InterfaceAddress;
import java.net.NetworkInterface;
import java.net.SocketTimeoutException;
import java.nio.ByteBuffer;
import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;
import org.publiuspseudis.esadvpn.core.VPNConnection;
import org.publiuspseudis.esadvpn.crypto.ProofOfWork;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * The {@code PeerDiscovery} class is responsible for discovering and managing peers within the
 * peer-to-peer (P2P) VPN network. It facilitates the discovery process through various
 * mechanisms, including direct peer connections, local network scanning, and bootstrap node
 * queries. The class ensures that only verified and valid peers are added to the network,
 * maintaining the integrity and security of the VPN.
 *
 * <p>
 * <strong>Key Functionalities:</strong>
 * </p>
 * <ul>
 *   <li>Discovering peers via direct connections, local network broadcasts, or bootstrap nodes.</li>
 *   <li>Verifying peers' proofs of work to authenticate their legitimacy.</li>
 *   <li>Managing known peers and their states, including node IDs and proof of work data.</li>
 *   <li>Handling bootstrap attempts with retry mechanisms and backoff intervals.</li>
 *   <li>Refreshing peer lists periodically to maintain network connectivity and robustness.</li>
 * </ul>
 *
 * <p>
 * <strong>Usage Example:</strong>
 * </p>
 * <pre>{@code
 * byte[] nodeId = ...; // 32-byte unique identifier
 * ProofOfWork pow = new ProofOfWork(nodeId);
 * PeerDiscovery.ConnectionMode mode = PeerDiscovery.ConnectionMode.BOOTSTRAP_NODE;
 * String directPeerAddress = "192.168.1.100:8080";
 * String[] bootstrapAddresses = {"bootstrap1.example.com:51820", "bootstrap2.example.com:51820"};
 *
 * PeerDiscovery peerDiscovery = new PeerDiscovery(nodeId, pow, mode, directPeerAddress, bootstrapAddresses);
 *
 * try {
 *     Set<InetSocketAddress> peers = peerDiscovery.bootstrap();
 *     // Proceed with connecting to discovered peers
 * } catch (IOException e) {
 *     // Handle bootstrap failure
 * }
 * }</pre>
 *
 * <p>
 * <strong>Thread Safety:</strong>
 * </p>
 * <p>
 * The {@code PeerDiscovery} class is designed to be thread-safe. It utilizes concurrent data structures
 * such as {@link ConcurrentHashMap} and synchronization mechanisms to manage shared resources safely
 * across multiple threads.
 * </p>
 *
 * <p>
 * <strong>Dependencies:</strong>
 * </p>
 * <ul>
 *   <li>{@link ProofOfWork}: Used for generating and verifying proofs of work for peer authentication.</li>
 *   <li>{@link VPNConnection}: Represents the VPN connection used for communication with peers.</li>
 *   <li>SLF4J Logging Framework: Utilized for logging discovery processes, peer verification, and errors.</li>
 * </ul>
 *
 * @author
 * Publius Pseudis
 */
public final class PeerDiscovery {
    /**
     * Logger instance for logging information, warnings, and errors related to peer discovery.
     */
    private static final Logger log = LoggerFactory.getLogger(PeerDiscovery.class);

    /**
     * The maximum number of attempts to contact bootstrap nodes during the discovery process.
     */
    private static final int MAX_BOOTSTRAP_ATTEMPTS = 3;

    /**
     * The interval in milliseconds to wait before retrying bootstrap attempts after a failure.
     */
    private static final long BOOTSTRAP_RETRY_INTERVAL = TimeUnit.SECONDS.toMillis(30);

    /**
     * The interval in milliseconds to refresh the peer list by discovering new peers.
     */
    private static final long PEER_REFRESH_INTERVAL = TimeUnit.MINUTES.toMillis(5);

    /**
     * The minimum number of valid peers required to maintain network health.
     */
    private static final int MIN_VALID_PEERS = 3;

    /**
     * A set of predefined bootstrap nodes used for initiating peer discovery.
     */
    private final Set<InetSocketAddress> bootstrapNodes;

    /**
     * A set of known peers that have been successfully discovered and verified.
     */
    private final Set<InetSocketAddress> knownPeers;

    /**
     * A concurrent map storing the state of each peer, identified by their {@link InetSocketAddress}.
     */
    private final Map<InetSocketAddress, PeerState> peerStates;

    /**
     * An object used as a lock for synchronizing access to shared state variables.
     */
    private final Object stateLock = new Object();

    /**
     * The timestamp of the last bootstrap attempt.
     */
    private volatile long lastBootstrapAttempt;

    /**
     * The timestamp of the last peer list refresh.
     */
    private volatile long lastPeerRefresh;

    /**
     * A secure random number generator used for randomizing operations such as peer selection.
     */
    private final SecureRandom random;

    /**
     * The {@link ProofOfWork} instance used for generating and verifying proofs of work.
     */
    private final ProofOfWork pow;

    /**
     * The unique node ID of this peer discovery instance.
     */
    private final byte[] nodeId;

    /**
     * Enumeration representing the different modes of peer connection for discovery.
     */
    public enum ConnectionMode {
        /**
         * Direct connection to a specified known peer.
         */
        DIRECT_PEER,

        /**
         * Discovery via local network broadcasts.
         */
        LOCAL_NETWORK,

        /**
         * Connection to bootstrap nodes for initial peer discovery.
         */
        BOOTSTRAP_NODE
    }

    /**
     * The current connection mode determining the peer discovery strategy.
     */
    private final ConnectionMode mode;

    /**
     * The direct peer's {@link InetSocketAddress} if operating in {@link ConnectionMode#DIRECT_PEER} mode.
     */
    private final InetSocketAddress directPeer;

    /**
     * Represents the state of a peer, including node ID, proof of work, last verification time, and reliability score.
     */
    private static class PeerState {
        /**
         * The unique node ID of the peer.
         */
        final byte[] nodeId;

        /**
         * The proof of work data of the peer.
         */
        final byte[] proofOfWork;

        /**
         * The timestamp of the last verification attempt.
         */
        volatile long lastVerified;

        /**
         * The reliability score of the peer, indicating trustworthiness.
         */
        volatile double reliability;

        /**
         * Constructs a new {@code PeerState} with the specified parameters.
         *
         * @param nodeId       The unique node ID of the peer.
         * @param proofOfWork  The proof of work data of the peer.
         * @param lastVerified The timestamp of the last verification.
         * @param reliability  The reliability score of the peer.
         */
        PeerState(byte[] nodeId, byte[] proofOfWork, long lastVerified, double reliability) {
            this.nodeId = nodeId;
            this.proofOfWork = proofOfWork;
            this.lastVerified = lastVerified;
            this.reliability = reliability;
        }

        /**
         * Updates the reliability score of the peer based on the outcome of the last interaction.
         *
         * @param success Indicates whether the last interaction was successful.
         */
        void updateReliability(boolean success) {
            if (success) {
                this.reliability = Math.min(this.reliability + 0.1, 1.0);
            } else {
                this.reliability = Math.max(this.reliability - 0.1, 0.0);
            }
        }
    }

    /**
     * Constructs a new {@code PeerDiscovery} instance with the specified parameters.
     *
     * <p>
     * Initializes the peer discovery mechanism based on the provided connection mode. Depending on the mode,
     * it sets up direct peer connections, local network scanning, or initializes connections to bootstrap nodes.
     * </p>
     *
     * @param nodeId               The unique node ID for which the peer discovery is being performed.
     * @param pow                  The {@link ProofOfWork} instance used for proof verification.
     * @param mode                 The {@link ConnectionMode} determining the discovery strategy.
     * @param directPeerAddress    The address of the direct peer (required if {@code mode} is {@link ConnectionMode#DIRECT_PEER}).
     * @param bootstrapAddresses   A varargs array of bootstrap node addresses in the format "hostname:port".
     *                             These are used when {@code mode} is {@link ConnectionMode#BOOTSTRAP_NODE}.
     * @throws IllegalArgumentException If the {@code directPeerAddress} format is invalid when required.
     */
    public PeerDiscovery(byte[] nodeId, ProofOfWork pow, ConnectionMode mode, 
                         String directPeerAddress, String... bootstrapAddresses) {
        this.nodeId = nodeId;
        this.pow = pow;
        this.mode = mode;
        this.random = new SecureRandom();
        this.bootstrapNodes = ConcurrentHashMap.newKeySet();
        this.knownPeers = ConcurrentHashMap.newKeySet();
        this.peerStates = new ConcurrentHashMap<>();

        // Handle direct peer connection if in DIRECT_PEER mode
        if (mode == ConnectionMode.DIRECT_PEER && directPeerAddress != null) {
            String[] parts = directPeerAddress.split(":");
            if (parts.length == 2) {
                this.directPeer = new InetSocketAddress(
                        parts[0].trim(), Integer.parseInt(parts[1].trim()));
            } else {
                throw new IllegalArgumentException("Invalid direct peer address format. Expected format: 'hostname:port'");
            }
        } else {
            this.directPeer = null;
        }

        // Add bootstrap nodes if in BOOTSTRAP_NODE mode
        if (mode == ConnectionMode.BOOTSTRAP_NODE) {
            for (String addr : bootstrapAddresses) {
                try {
                    String[] parts = addr.split(":");
                    if (parts.length == 2) {
                        InetSocketAddress bootstrapNode = new InetSocketAddress(
                                parts[0].trim(), Integer.parseInt(parts[1].trim()));
                        bootstrapNodes.add(bootstrapNode);
                    } else {
                        log.warn("Invalid bootstrap address format: {}", addr);
                    }
                } catch (NumberFormatException e) {
                    log.warn("Invalid port number in bootstrap address: {}", addr);
                }
            }
        }
    }

    /**
     * Initiates the bootstrap process to discover and verify peers based on the configured connection mode.
     *
     * <p>
     * This method attempts to discover peers through bootstrap nodes, local network scanning, or direct peer
     * connections depending on the {@link ConnectionMode} specified during initialization. It verifies each
     * discovered peer's proof of work before adding them to the known peers list.
     * </p>
     *
     * @return A {@link Set} of {@link InetSocketAddress} representing successfully discovered and verified peers.
     * @throws IOException If the bootstrap process fails to discover any valid peers after maximum attempts.
     */
    public Set<InetSocketAddress> bootstrap() throws IOException {
        synchronized (stateLock) {
            Set<InetSocketAddress> peers = new HashSet<>();
            int attempt = 0;

            while (attempt < MAX_BOOTSTRAP_ATTEMPTS) {
                attempt++;
                log.info("Bootstrap attempt {}/{}", attempt, MAX_BOOTSTRAP_ATTEMPTS);

                try {
                    switch (mode) {
                        case BOOTSTRAP_NODE -> {
                            peers = bootstrapFromNodes();
                        }
                        case LOCAL_NETWORK -> peers = bootstrapLocalNetwork();
                        case DIRECT_PEER -> peers = bootstrapDirectPeer();
                    }

                    if (!peers.isEmpty()) {
                        log.info("Bootstrap successful on attempt {}/{}", attempt, MAX_BOOTSTRAP_ATTEMPTS);
                        return peers;
                    } else {
                        log.warn("No peers discovered on attempt {}/{}", attempt, MAX_BOOTSTRAP_ATTEMPTS);
                    }
                } catch (IOException e) {
                    log.warn("Bootstrap attempt {}/{} failed: {}", attempt, MAX_BOOTSTRAP_ATTEMPTS, e.getMessage());
                }

                if (attempt < MAX_BOOTSTRAP_ATTEMPTS) {
                    log.info("Waiting for {} ms before next bootstrap attempt...", BOOTSTRAP_RETRY_INTERVAL);
                    try {
                        Thread.sleep(BOOTSTRAP_RETRY_INTERVAL);
                    } catch (InterruptedException ie) {
                        Thread.currentThread().interrupt();
                        throw new IOException("Bootstrap interrupted during sleep", ie);
                    }
                }
            }

            throw new IOException("Failed to bootstrap after " + MAX_BOOTSTRAP_ATTEMPTS + " attempts.");
        }
    }

    /**
     * Bootstraps the peer discovery process by connecting to predefined bootstrap nodes.
     *
     * <p>
     * This method iterates through the list of configured bootstrap nodes, querying each for known peers.
     * It verifies each discovered peer's proof of work before adding them to the known peers set.
     * </p>
     *
     * @return A {@link Set} of {@link InetSocketAddress} representing successfully discovered and verified peers.
     * @throws IOException If the bootstrap attempts to all bootstrap nodes fail to discover valid peers.
     */
    private Set<InetSocketAddress> bootstrapFromNodes() throws IOException {
        long now = System.currentTimeMillis();
        if (now - lastBootstrapAttempt < BOOTSTRAP_RETRY_INTERVAL) {
            return new HashSet<>(knownPeers);
        }
        lastBootstrapAttempt = now;

        Set<InetSocketAddress> discoveredPeers = new HashSet<>();

        // Attempt to query each bootstrap node
        for (InetSocketAddress bootstrap : bootstrapNodes) {
            try {
                Set<InetSocketAddress> peers = queryPeer(bootstrap);
                if (!peers.isEmpty()) {
                    discoveredPeers.addAll(verifyAndAddPeers(peers));
                }
            } catch (IOException e) {
                log.debug("Failed to query bootstrap node {}: {}", bootstrap, e.getMessage());
            }
        }

        // If bootstrap nodes fail, attempt to query known peers
        if (discoveredPeers.isEmpty() && !knownPeers.isEmpty()) {
            List<InetSocketAddress> shuffledPeers = new ArrayList<>(knownPeers);
            Collections.shuffle(shuffledPeers, random);

            for (InetSocketAddress peer : shuffledPeers) {
                try {
                    Set<InetSocketAddress> peers = queryPeer(peer);
                    if (!peers.isEmpty()) {
                        discoveredPeers.addAll(verifyAndAddPeers(peers));
                    }
                } catch (IOException e) {
                    log.debug("Failed to query peer {}: {}", peer, e.getMessage());
                    removePeer(peer);
                }
            }
        }

        if (discoveredPeers.isEmpty()) {
            throw new IOException("Failed to bootstrap from nodes: No valid peers discovered.");
        }

        return discoveredPeers;
    }

    /**
     * Bootstraps the peer discovery process by scanning the local network for peers.
     *
     * <p>
     * This method broadcasts a discovery request over each active and non-loopback network interface's
     * broadcast address. It collects and verifies responses from peers within the local network segment.
     * </p>
     *
     * @return A {@link Set} of {@link InetSocketAddress} representing successfully discovered and verified peers.
     * @throws IOException If the local network discovery fails to find any valid peers.
     */
    private Set<InetSocketAddress> bootstrapLocalNetwork() throws IOException {
        Set<InetSocketAddress> discovered = new HashSet<>();

        // Iterate through all network interfaces
        for (NetworkInterface iface : Collections.list(NetworkInterface.getNetworkInterfaces())) {
            if (!iface.isUp() || iface.isLoopback()) {
                continue;
            }

            // Iterate through all interface addresses to get broadcast addresses
            for (InterfaceAddress addr : iface.getInterfaceAddresses()) {
                InetAddress broadcast = addr.getBroadcast();
                if (broadcast == null) continue;

                discovered.addAll(sendLocalDiscovery(broadcast));
            }
        }

        if (!discovered.isEmpty()) {
            return verifyAndAddPeers(discovered);
        }
        throw new IOException("No peers found on the local network.");
    }

    /**
     * Bootstraps the peer discovery process by establishing a direct connection to a specified peer.
     *
     * <p>
     * This method attempts to verify the direct peer's proof of work and adds it to the known peers
     * set upon successful verification.
     * </p>
     *
     * @return A {@link Set} containing the direct peer's {@link InetSocketAddress} if successfully verified.
     * @throws IOException If the direct peer verification fails.
     */
    private Set<InetSocketAddress> bootstrapDirectPeer() throws IOException {
        if (directPeer == null) {
            throw new IOException("No direct peer configured for DIRECT_PEER mode.");
        }

        // Verify the direct peer's proof of work
        if (verifyPeer(directPeer)) {
            Set<InetSocketAddress> result = new HashSet<>();
            result.add(directPeer);
            knownPeers.add(directPeer);
            log.info("Direct peer {} successfully verified and added.", directPeer);
            return result;
        }
        throw new IOException("Failed to verify the direct peer's proof of work.");
    }

    /**
     * Sends a local discovery request to the specified broadcast address and collects responses.
     *
     * <p>
     * This method constructs a discovery packet containing the node's ID and a timestamp, broadcasts it
     * to the local network, and listens for responses from other peers. Responses are validated before
     * adding the responding peers to the discovery results.
     * </p>
     *
     * @param broadcast The {@link InetAddress} representing the broadcast address to send discovery requests to.
     * @return A {@link Set} of {@link InetSocketAddress} representing peers that responded to the discovery request.
     */
    private Set<InetSocketAddress> sendLocalDiscovery(InetAddress broadcast) {
        Set<InetSocketAddress> discovered = new HashSet<>();

        try (DatagramSocket socket = new DatagramSocket()) {
            socket.setBroadcast(true);
            socket.setSoTimeout(1000); // 1-second timeout for responses

            // Construct discovery request packet
            ByteBuffer request = ByteBuffer.allocate(nodeId.length + Long.BYTES);
            request.put(nodeId);
            request.putLong(System.currentTimeMillis());

            DatagramPacket packet = new DatagramPacket(
                    request.array(), request.array().length,
                    broadcast, VPNConnection.VPN_PORT);
            socket.send(packet);
            log.debug("Sent local discovery request to {}", broadcast.getHostAddress());

            // Collect responses within the timeout period
            long deadline = System.currentTimeMillis() + 1000; // 1-second window
            while (System.currentTimeMillis() < deadline) {
                try {
                    byte[] responseData = new byte[1024];
                    DatagramPacket responsePacket = new DatagramPacket(responseData, responseData.length);
                    socket.receive(responsePacket);

                    if (validateDiscoveryResponse(responsePacket)) {
                        InetSocketAddress peerAddress = new InetSocketAddress(
                                responsePacket.getAddress(), responsePacket.getPort());
                        discovered.add(peerAddress);
                        log.debug("Discovered peer at {}", peerAddress);
                    }
                } catch (SocketTimeoutException e) {
                    // No more responses within the timeout
                    break;
                }
            }
        } catch (IOException e) {
            log.debug("Local discovery on {} failed: {}", broadcast.getHostAddress(), e.getMessage());
        }

        return discovered;
    }

    /**
     * Queries a specific peer for known peers by sending a discovery request and processing the response.
     *
     * <p>
     * This method sends a discovery packet to the specified peer and waits for a response containing
     * a list of known peers. It then extracts and returns the list of peers provided in the response.
     * </p>
     *
     * @param peer The {@link InetSocketAddress} of the peer to query.
     * @return A {@link Set} of {@link InetSocketAddress} representing peers discovered from the queried peer.
     * @throws IOException If there is an error during communication with the peer or if the response is invalid.
     */
    private Set<InetSocketAddress> queryPeer(InetSocketAddress peer) throws IOException {
        Set<InetSocketAddress> discoveredPeers = new HashSet<>();

        // Establish a temporary UDP socket for querying
        try (DatagramSocket socket = new DatagramSocket()) {
            socket.setSoTimeout(5000); // 5-second timeout

            // Construct discovery request packet
            ByteBuffer request = ByteBuffer.allocate(nodeId.length + 8);
            request.put(nodeId);
            request.putLong(System.currentTimeMillis());

            byte[] requestData = request.array();
            DatagramPacket packet = new DatagramPacket(
                    requestData,
                    requestData.length,
                    peer.getAddress(),
                    peer.getPort()
            );

            // Send discovery request
            socket.send(packet);
            log.debug("Sent discovery request to peer {}", peer);

            // Receive and validate response
            byte[] responseData = new byte[4096];
            DatagramPacket response = new DatagramPacket(responseData, responseData.length);
            socket.receive(response);

            log.debug("Received discovery response from {}: size {}, data {}", 
                    response.getSocketAddress(), response.getLength(), bytesToHex(Arrays.copyOf(responseData, response.getLength())));

            ByteBuffer buffer = ByteBuffer.wrap(responseData, 0, response.getLength());

            // Validate response format
            if (buffer.remaining() < nodeId.length + Long.BYTES + Integer.BYTES) {
                throw new IOException("Invalid discovery response format from peer " + peer);
            }

            // Extract responding node's ID and timestamp
            byte[] respNodeId = new byte[nodeId.length];
            buffer.get(respNodeId);
            long timestamp = buffer.getLong();

            // Extract the number of peers reported
            int peerCount = buffer.getInt();

            // Extract peer addresses
            for (int i = 0; i < peerCount && buffer.remaining() >= 6; i++) {
                byte[] addrBytes = new byte[4];
                buffer.get(addrBytes);
                int port = buffer.getShort() & 0xFFFF; // Convert to unsigned

                InetAddress addr = InetAddress.getByAddress(addrBytes);
                InetSocketAddress newPeer = new InetSocketAddress(addr, port);

                if (!newPeer.equals(peer)) { // Exclude the querying peer itself
                    discoveredPeers.add(newPeer);
                }
            }
        }

        return discoveredPeers;
    }

    /**
     * Verifies the discovered peers by validating their proofs of work and adds them to the known peers set.
     *
     * <p>
     * This method iterates through the provided set of peers, verifies each peer's proof of work,
     * and adds the peer to the known peers set if the verification is successful.
     * </p>
     *
     * @param peers A {@link Set} of {@link InetSocketAddress} representing discovered peers to verify.
     * @return A {@link Set} of {@link InetSocketAddress} representing successfully verified peers.
     */
    private Set<InetSocketAddress> verifyAndAddPeers(Set<InetSocketAddress> peers) {
        Set<InetSocketAddress> verifiedPeers = new HashSet<>();

        for (InetSocketAddress peer : peers) {
            try {
                // Verify the peer's proof of work
                if (verifyPeer(peer)) {
                    knownPeers.add(peer);
                    verifiedPeers.add(peer);
                    log.debug("Verified and added peer {}", peer);
                }
            } catch (Exception e) {
                log.debug("Failed to verify peer {}: {}", peer, e.getMessage());
            }
        }

        return verifiedPeers;
    }

    /**
     * Verifies a peer's authenticity by validating its proof of work.
     *
     * <p>
     * This method sends a verification request to the specified peer and awaits a response containing
     * the peer's node ID and timestamp. It then uses the {@link ProofOfWork} instance to verify the received
     * proof data.
     * </p>
     *
     * @param peer The {@link InetSocketAddress} of the peer to verify.
     * @return {@code true} if the peer's proof of work is valid; {@code false} otherwise.
     */
    public boolean verifyPeer(InetSocketAddress peer) {
        try (DatagramSocket socket = new DatagramSocket()) {
            socket.setSoTimeout(5000); // 5-second timeout

            // Construct verification request packet
            ByteBuffer request = ByteBuffer.allocate(nodeId.length + 1);
            request.put((byte) 0x01); // Verification request marker
            request.put(nodeId);
            request.flip();

            log.debug("Sending verification request to {}: nodeId length {}, content {}", 
                    peer, nodeId.length, bytesToHex(nodeId));

            DatagramPacket packet = new DatagramPacket(
                    request.array(),
                    request.limit(),
                    peer.getAddress(),
                    peer.getPort()
            );

            // Attempt to send verification request and receive response
            int maxAttempts = 3;
            for (int attempt = 1; attempt <= maxAttempts; attempt++) {
                try {
                    socket.send(packet);
                    log.debug("Sent verification request to {} (attempt {}/{})", 
                            peer, attempt, maxAttempts);

                    // Receive response
                    byte[] responseData = new byte[1024];
                    DatagramPacket responsePacket = new DatagramPacket(responseData, responseData.length);
                    socket.receive(responsePacket);

                    log.debug("Received verification response from {}: size {}, data {}", 
                            responsePacket.getSocketAddress(), responsePacket.getLength(), 
                            bytesToHex(Arrays.copyOf(responseData, responsePacket.getLength())));

                    ByteBuffer buffer = ByteBuffer.wrap(responseData, 0, responsePacket.getLength());

                    // Validate response format
                    if (buffer.remaining() < nodeId.length + Long.BYTES) {
                        log.debug("Invalid response size from {}: expected >= {}, got {}", 
                                peer, nodeId.length + Long.BYTES, buffer.remaining());
                        continue;
                    }

                    // Extract peer node ID and timestamp
                    byte[] peerNodeId = new byte[nodeId.length];
                    buffer.get(peerNodeId);
                    long timestamp = buffer.getLong();

                    log.debug("Received nodeId: {}, timestamp: {}", 
                            bytesToHex(peerNodeId), timestamp);

                    // Construct proof data for verification
                    byte[] proofData = new byte[peerNodeId.length + Long.BYTES];
                    System.arraycopy(peerNodeId, 0, proofData, 0, peerNodeId.length);
                    System.arraycopy(responseData, nodeId.length, proofData, peerNodeId.length, Long.BYTES);

                    log.debug("Constructed proof data for verification: {}", bytesToHex(proofData));

                    // Verify proof of work using ProofOfWork instance
                    boolean isValid = pow.verify(proofData, timestamp);
                    log.debug("Proof verification result for {}: {}", peer, isValid);

                    if (!isValid) {
                        log.debug("Invalid proof of work from peer {}, will retry", peer);
                        continue;
                    }

                    // Update PeerState upon successful verification
                    PeerState newPeerState = new PeerState(peerNodeId, proofData, System.currentTimeMillis(), 1.0);
                    peerStates.put(peer, newPeerState);
                    knownPeers.add(peer);

                    log.debug("Successfully verified and added peer {}", peer);
                    return true;

                } catch (SocketTimeoutException e) {
                    log.debug("Verification attempt {} timed out for peer {}", attempt, peer);
                    if (attempt == maxAttempts) {
                        throw e;
                    }
                    // Exponential backoff before retrying
                    Thread.sleep(1000 * attempt);
                }
            }

            return false;

        } catch (Exception e) {
            log.debug("Peer verification failed for {}: {}", peer, e.getMessage(), e);
            return false;
        }
    }

    /**
     * Validates a discovery response packet received from a peer.
     *
     * <p>
     * This method checks the format of the discovery response, ensuring it contains the correct
     * markers, node ID, and a recent timestamp. It also validates the proof of work if the peer
     * is known.
     * </p>
     *
     * @param responsePacket The {@link DatagramPacket} containing the discovery response data.
     * @return {@code true} if the discovery response is valid; {@code false} otherwise.
     */
    private boolean validateDiscoveryResponse(DatagramPacket responsePacket) {
        try {
            ByteBuffer buffer = ByteBuffer.wrap(
                    responsePacket.getData(),
                    responsePacket.getOffset(),
                    responsePacket.getLength()
            );

            // Minimum required bytes: 1 (type) + nodeId.length + 8 (timestamp)
            if (buffer.remaining() < 1 + nodeId.length + 8) {
                return false;
            }

            // Check response type marker
            byte type = buffer.get();
            if (type != 0x03) { // Discovery response marker
                return false;
            }

            // Extract responding node's ID and timestamp
            byte[] respNodeId = new byte[nodeId.length];
            buffer.get(respNodeId);
            long timestamp = buffer.getLong();

            // Validate timestamp is within the acceptable range (e.g., within the last minute)
            long now = System.currentTimeMillis();
            if (Math.abs(now - timestamp) > TimeUnit.MINUTES.toMillis(1)) {
                log.debug("Discovery response timestamp too old from {}", responsePacket.getAddress());
                return false;
            }

            // Retrieve peer state if already known
            PeerState peerState = peerStates.get(
                    new InetSocketAddress(responsePacket.getAddress(), responsePacket.getPort())
            );

            if (peerState != null) {
                // For known peers, ensure node ID matches
                if (!Arrays.equals(respNodeId, peerState.nodeId)) {
                    log.warn("NodeId mismatch from known peer {}", responsePacket.getAddress());
                    return false;
                }

                // Optionally, update lastVerified and reliability based on the discovery response
                peerState.lastVerified = now;
                peerState.updateReliability(true); // Assuming discovery success
            } else {
                // For unknown peers, perform proof of work verification
                if (!pow.verify(respNodeId, timestamp)) {
                    log.debug("Invalid proof of work in discovery response from {}", 
                            responsePacket.getAddress());
                    return false;
                }

                // Optionally, add the peer with initial PeerState
                PeerState newPeerState = new PeerState(respNodeId, 
                        Arrays.copyOfRange(responsePacket.getData(), 0, nodeId.length + Long.BYTES),
                        now, 1.0);
                peerStates.put(new InetSocketAddress(responsePacket.getAddress(), responsePacket.getPort()), newPeerState);
                knownPeers.add(new InetSocketAddress(responsePacket.getAddress(), responsePacket.getPort()));
            }

            return true;

        } catch (Exception e) {
            log.debug("Error validating discovery response: {}", e.getMessage());
            return false;
        }
    }

    /**
     * Removes a peer from the known peers set and cleans up associated state information.
     *
     * <p>
     * This method deregisters the specified peer from the known peers list and removes any stored
     * state information related to the peer. It ensures that stale or invalid peers do not persist
     * in the network.
     * </p>
     *
     * @param peer The {@link InetSocketAddress} of the peer to remove.
     */
    public void removePeer(InetSocketAddress peer) {
        knownPeers.remove(peer);
        peerStates.remove(peer);
        log.debug("Removed peer {}", peer);
    }

    /**
     * Determines whether the peer discovery process requires a bootstrap attempt.
     *
     * <p>
     * This method checks if the number of known peers is below the minimum required or if the peer
     * list has not been refreshed within the specified interval. It indicates whether a new bootstrap
     * attempt should be initiated to discover additional peers.
     * </p>
     *
     * @return {@code true} if a bootstrap attempt is needed; {@code false} otherwise.
     */
    public boolean needsBootstrap() {
        return knownPeers.size() < MIN_VALID_PEERS ||
                System.currentTimeMillis() - lastPeerRefresh > PEER_REFRESH_INTERVAL;
    }

    /**
     * Retrieves the current set of known peers.
     *
     * <p>
     * This method returns a defensive copy of the known peers set to prevent external modification.
     * </p>
     *
     * @return A {@link Set} of {@link InetSocketAddress} representing the currently known peers.
     */
    public Set<InetSocketAddress> getKnownPeers() {
        return new HashSet<>(knownPeers);
    }

    /**
     * Selects a peer based on reliability scores.
     *
     * <p>
     * This method sorts the known peers by their reliability scores in descending order and selects the
     * most reliable peer available. If no peers are available, it returns {@code null}.
     * </p>
     *
     * @return An {@link InetSocketAddress} of a selected peer, or {@code null} if no suitable peer is found.
     */
    public InetSocketAddress selectPeer() {
        return peerStates.entrySet().stream()
                .sorted((e1, e2) -> Double.compare(e2.getValue().reliability, e1.getValue().reliability))
                .map(Map.Entry::getKey)
                .findFirst()
                .orElse(null);
    }

    /**
     * Prunes peers with reliability scores below a specified threshold.
     *
     * <p>
     * This method iterates through the known peers and removes those whose reliability scores are
     * below the provided threshold. This helps maintain a network of reliable and trustworthy peers.
     * </p>
     *
     * @param threshold The reliability threshold below which peers will be removed.
     */
    public void pruneUnreliablePeers(double threshold) {
        peerStates.entrySet().removeIf(entry -> {
            boolean shouldRemove = entry.getValue().reliability < threshold;
            if (shouldRemove) {
                knownPeers.remove(entry.getKey());
                log.info("Pruned unreliable peer {}", entry.getKey());
            }
            return shouldRemove;
        });
    }

    /**
     * Converts a byte array into its hexadecimal string representation.
     *
     * <p>
     * This utility method is primarily used for logging purposes, allowing binary data to be
     * represented in a human-readable hexadecimal format.
     * </p>
     *
     * @param bytes The byte array to convert.
     * @return A {@link String} representing the hexadecimal values of the input bytes.
     */
    private static String bytesToHex(byte[] bytes) {
        StringBuilder hex = new StringBuilder();
        for (byte b : bytes) {
            hex.append(String.format("%02x", b));
        }
        return hex.toString();
    }
}

=============================================

package org.publiuspseudis.esadvpn.network;

/*
 * Copyright (C) 2024 Publius Pseudis
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

import org.publiuspseudis.esadvpn.protocol.GossipMessage;
import org.publiuspseudis.esadvpn.crypto.ProofOfWork;
import org.publiuspseudis.esadvpn.core.NetworkStack;
import org.publiuspseudis.esadvpn.core.VPNConnection;
import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.net.DatagramSocket;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketException;
import java.net.SocketTimeoutException;
import java.nio.ByteBuffer;
import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;
import java.util.logging.Level;
import org.publiuspseudis.esadvpn.network.PeerDiscovery.ConnectionMode;
import org.publiuspseudis.esadvpn.proxy.SocksProxy;
import org.publiuspseudis.esadvpn.routing.RouteInfo;
import org.publiuspseudis.esadvpn.routing.SwarmRouter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * <p>
 * The {@code P2PNetwork} class represents a peer-to-peer (P2P) network node within the VPN framework.
 * It handles the establishment and management of connections with peers, routing of network packets,
 * NAT (Network Address Translation) handling, proof-of-work verification, and periodic maintenance tasks
 * such as gossiping and proof updates. This class integrates various components like {@link NetworkStack},
 * {@link SwarmRouter}, {@link NATHandler}, and utilizes multithreading to ensure efficient and concurrent
 * operations.
 * </p>
 *
 * <p>
 * <strong>Key Functionalities:</strong></p>
 * <ul>
 *   <li>Establishing and managing peer connections.</li>
 *   <li>Routing network packets between peers using pheromone-based routing metrics.</li>
 *   <li>Handling NAT translations for incoming and outgoing packets.</li>
 *   <li>Maintaining network health by ensuring a minimum number of active peers.</li>
 *   <li>Periodic tasks including gossiping, proof-of-work updates, keepalive messages, and logging statistics.</li>
 *   <li>Providing diagnostics and network state export/import functionalities.</li>
 * </ul>
 * 
 * 
 * <p>
 * <strong>Example Usage:</strong>
 * </p>
 * <pre>{@code
 * // Initialize P2PNetwork as an initiator node
 * int port = 8080;
 * boolean isInitiator = true;
 * P2PNetwork p2pNetwork = new P2PNetwork(port, isInitiator);
 * 
 * // Start the network node
 * p2pNetwork.start();
 * 
 * // Connect to a peer
 * p2pNetwork.connectToPeer("192.168.1.100", 8081);
 * 
 * // Retrieve network statistics
 * Map<String, Object> stats = p2pNetwork.getNetworkStats();
 * System.out.println("Network Stats: " + stats);
 * 
 * // Run diagnostics
 * String diagnostics = p2pNetwork.runDiagnostics();
 * System.out.println(diagnostics);
 * 
 * // Close the network node when done
 * p2pNetwork.close();
 * }</pre>
 * 
 * <p>
 * <strong>Thread Safety:</strong>  
 * The {@code P2PNetwork} class is designed to be thread-safe, utilizing concurrent data structures like
 * {@link ConcurrentHashMap} and synchronized operations where necessary. It employs an {@code ExecutorService}
 * and a {@code ScheduledExecutorService} to manage asynchronous tasks, ensuring that network operations
 * do not block each other and are handled efficiently.
 * </p>
 * 
 * <p>
 * <strong>Dependencies:</strong>
 * </p>
 * <ul>
 *   <li>{@link NetworkStack}: Manages the virtual network interface and packet processing.</li>
 *   <li>{@link SwarmRouter}: Handles routing decisions based on pheromone metrics.</li>
 *   <li>{@link NATHandler}: Manages NAT translations for network packets.</li>
 *   <li>{@link ProofOfWork}: Handles proof-of-work generation and verification.</li>
 *   <li>{@link GossipMessage}: Manages gossip protocol messages for peer discovery and routing information sharing.</li>
 *   <li>SLF4J Logging Framework: Utilized for logging events and debugging.</li>
 * </ul>
 * 
 * @author
 * Publius Pseudis
 * 
 * @version 1.0
 * @since 2024-01-01
 */
public final class P2PNetwork implements GossipMessage.GossipHandler, AutoCloseable {
    /**
     * The {@link PeerDiscovery} instance responsible for discovering and managing peers within the P2P network.
     *
     * <p>
     * This component handles the discovery of new peers through various mechanisms such as local network scanning
     * and bootstrap server queries. It maintains an updated list of available peers to facilitate connection establishment
     * and network expansion.
     * </p>
     */
    private final PeerDiscovery peerDiscovery;

    /**
     * Logger instance for logging information, warnings, and errors.
     */
    private static final Logger log = LoggerFactory.getLogger(P2PNetwork.class);
    
    // Network components
    /**
     * The {@link NetworkStack} instance managing the virtual network interface and packet processing.
     */
    private final NetworkStack networkStack;
    
    /**
     * The {@link SwarmRouter} instance responsible for determining the next hop for routing packets.
     */
    private final SwarmRouter router;
    
    /**
     * The {@link ServerSocket} used for listening to incoming peer connection requests.
     */
    private final ServerSocket serverSocket;
    
    /**
     * A thread-safe map storing active peers identified by their node IDs.
     */
    private final Map<ByteBuffer, Peer> peers;
    
    /**
     * The {@link NATHandler} instance managing NAT translations for network packets.
     */
    private final NATHandler natHandler;
    
    // Identity and security
    /**
     * The unique node ID generated for this P2P network node.
     */
    private final byte[] nodeId;
    
    /**
     * The IP address associated with this network node.
     */
    private final String ipAddress;
    
    /**
     * The {@link ProofOfWork} instance managing proof-of-work generation and verification.
     */
    private final ProofOfWork pow;
    
    /**
     * The port number on which this network node listens for peer connections.
     */
    private final int port;
    
    // Configuration constants
    /**
     * The maximum number of peers this node can connect to simultaneously.
     */
    private static final int MAX_PEERS = 10;
    
    /**
     * The minimum number of peers required to maintain network health.
     */
    private static final int MIN_PEERS = 3;
    
    /**
     * The socket timeout duration in milliseconds for peer connections.
     */
    private static final int SOCKET_TIMEOUT = 30000;
    private final int THREAD_POOL_SIZE = Math.min(Runtime.getRuntime().availableProcessors(), 4);
    /**
     * The number of connection retry attempts when attempting to connect to a peer.
     */
    private static final int CONNECTION_RETRY_COUNT = 3;
    
    // Threading and scheduling
    /**
     * The {@link ScheduledExecutorService} for scheduling periodic maintenance tasks.
     */
    private final ScheduledExecutorService scheduler;
    
    /**
     * The {@link ExecutorService} for handling asynchronous tasks such as peer connections and packet routing.
     */
    private final ExecutorService executor;
    
    /**
     * A flag indicating whether the network node is currently running.
     */
    private volatile boolean running;
    
    // Statistics and metrics
    /**
     * A thread-safe map tracking the number of bytes sent to each peer.
     */
    private final Map<String, Long> bytesSent;
    
    /**
     * A thread-safe map tracking the number of bytes received from each peer.
     */
    private final Map<String, Long> bytesReceived;
    
    /**
     * The timestamp marking when the network node was started.
     */
    private final long startTime;
    
    /**
     * A flag indicating whether this node is the initiator of the network.
     */
    private final boolean isInitiator;


    /**
     * An interface for handling new peer connections.
     */
    public interface ConnectionHandler {
        /**
         * Callback method invoked when a new connection is established with a peer.
         *
         * @param address The IP address of the connected peer.
         * @param port    The port number of the connected peer.
         * @param conn    The {@link VPNConnection} instance representing the connection.
         */
        void onNewConnection(String address, int port, VPNConnection conn);
    }

    /**
     * The handler for managing new connections.
     */
    private ConnectionHandler connectionHandler;

    /**
     * Sets the {@link ConnectionHandler} for handling new peer connections.
     *
     * @param handler The {@link ConnectionHandler} implementation to be set.
     */
    public void setConnectionHandler(ConnectionHandler handler) {
        this.connectionHandler = handler;
    }


    /**
     * Creates a new P2P VPN network node.
     *
     * @param port        The port number on which this node will listen for peer connections.
     * @param isInitiator A flag indicating whether this node is initiating a new network.
     * @throws IOException If there is an error during network setup, such as binding to the specified port.
     */
      public P2PNetwork(int port, boolean isInitiator, String peerAddress) throws IOException {
        this.port = port;
        this.nodeId = generateNodeId();
        this.ipAddress = isInitiator ? "10.0.0.1" : "10.0.1.1";
        this.peers = new ConcurrentHashMap<>();
        this.bytesSent = new ConcurrentHashMap<>();
        this.bytesReceived = new ConcurrentHashMap<>();
        this.isInitiator = isInitiator;

        // Create executor services with custom thread factories
        this.executor = Executors.newFixedThreadPool(THREAD_POOL_SIZE, r -> {
            Thread t = new Thread(r);
            t.setDaemon(true);
            t.setPriority(Thread.MIN_PRIORITY); // Lower priority for background tasks
            return t;
        });

        this.scheduler = Executors.newScheduledThreadPool(2, r -> {
            Thread t = new Thread(r);
            t.setDaemon(true);
            t.setPriority(Thread.MIN_PRIORITY);
            t.setName("P2P-Scheduler-" + t.getId());
            return t;
        });

        // Initialize core components
        this.router = new SwarmRouter();
        this.networkStack = new NetworkStack(ipAddress, router);
        this.natHandler = new NATHandler();
        this.pow = new ProofOfWork(nodeId);
        
        // Create server socket for peer connections
        this.serverSocket = new ServerSocket();
        this.serverSocket.setReuseAddress(true);
        this.serverSocket.bind(new InetSocketAddress(port));
        
        // Set up periodic tasks with more reasonable intervals
        scheduler.scheduleAtFixedRate(this::gossip, 30, 30, TimeUnit.SECONDS);
        scheduler.scheduleAtFixedRate(this::updateProofOfWork, 20, 20, TimeUnit.HOURS);
        scheduler.scheduleAtFixedRate(this::sendKeepalive, 5, 5, TimeUnit.SECONDS);
        scheduler.scheduleAtFixedRate(router::evaporatePheromones, 10, 10, TimeUnit.SECONDS);
        scheduler.scheduleAtFixedRate(router::cleanupRoutes, 1, 1, TimeUnit.MINUTES);
        scheduler.scheduleAtFixedRate(natHandler::cleanupExpiredMappings, 1, 1, TimeUnit.MINUTES);
        scheduler.scheduleAtFixedRate(this::checkPeerCount, 1, 1, TimeUnit.MINUTES);
        scheduler.scheduleAtFixedRate(this::logStats, 5, 5, TimeUnit.MINUTES);

        // Set up UDP handlers
        setupUDPHandlers();
        
        this.running = true;
        this.startTime = System.currentTimeMillis();
        
        log.info("P2P Network node started on port {} with IP {}", port, ipAddress);
        log.info("Node ID: {}", ByteBuffer.wrap(nodeId).toString());
        setConnectionHandler((address, remotePort, conn) -> {
            try {
                handleNewPeerConnection(address, remotePort, conn);
            } catch (Exception e) {
                log.error("Failed to handle new peer: {}", e.getMessage());
            }
        });
        
        // Initialize peer discovery with appropriate mode and peer info
        ConnectionMode mode;
        String directPeer = null;
        if (isInitiator) {
            mode = PeerDiscovery.ConnectionMode.LOCAL_NETWORK;
        } else if (peerAddress != null) {
            mode = PeerDiscovery.ConnectionMode.DIRECT_PEER;
            directPeer = peerAddress;
        } else {
            mode = PeerDiscovery.ConnectionMode.LOCAL_NETWORK;
        }

        this.peerDiscovery = new PeerDiscovery(
            nodeId, 
            pow,
            mode,
            directPeer,
            "bootstrap1.example.com:51820",
            "bootstrap2.example.com:51820"
        );

        // Start bootstrap process if not initiator
        if (!isInitiator) {
            try {
                Set<InetSocketAddress> peers = peerDiscovery.bootstrap();
                if (peers.isEmpty()) {
                    throw new IOException("Could not find any peers");
                }
                connectToInitialPeers(peers);
            } catch (IOException e) {
                log.error("Bootstrap failed: {}", e.getMessage());
                throw e;
            }
        }
    }


    private void connectToInitialPeers(Set<InetSocketAddress> peers) {
        // Connect to a subset of peers
        List<InetSocketAddress> peerList = new ArrayList<>(peers);
        Collections.shuffle(peerList);
        int connectCount = Math.min(3, peerList.size());
        
        for (int i = 0; i < connectCount; i++) {
            InetSocketAddress peer = peerList.get(i);
            try {
                connectToPeer(peer.getAddress().getHostAddress(), peer.getPort());
            } catch (IOException e) {
                log.warn("Failed to connect to peer {}: {}", peer, e.getMessage());
            }
        }
    }

   
    /**
     * Generates a unique node identifier using a secure random number generator.
     *
     * <p>
     * This method creates a 32-byte array filled with cryptographically strong random bytes to serve as the
     * unique identifier for the network node. Ensuring uniqueness is crucial for peer identification and
     * network integrity.
     * </p>
     *
     * @return A {@code byte[]} representing the unique node ID.
     */
    private static byte[] generateNodeId() {
        // Use a larger size for better uniqueness
        byte[] id = new byte[32];
        new SecureRandom().nextBytes(id);
        return id;
    }


    
    /**
     * Configures UDP handlers for managing VPN traffic.
     *
     * <p>
     * This method sets up the necessary handlers for processing incoming and outgoing VPN packets.
     * It binds to the specified port and delegates packet handling to appropriate callbacks. This setup
     * is only performed if the node is designated as an initiator.
     * </p>
     */
    private void setupUDPHandlers() {
        // Handle VPN traffic - only bind if we're an initiator
        if (isInitiator) {
            getUDPHandler().bind(port, (payload, sourceIP, sourcePort) -> {
                try {
                    // Extract original ports from payload
                    short origSrcPort = payload.getShort();
                    short origDstPort = payload.getShort();

                    // Extract actual data
                    byte[] data = new byte[payload.remaining()];
                    payload.get(data);

                    String sourcePeer = IPPacket.formatIP(sourceIP);
                    updatePeerStats(sourcePeer, data.length, true);

                    // Process through NAT
                    byte[] processedPacket = natHandler.processIncomingPacket(data);
                    if (processedPacket != null) {
                        processIncomingPacket(ByteBuffer.wrap(processedPacket), sourcePeer);

                        // Send response data back through UDP tunnel
                        ByteBuffer response = ByteBuffer.allocate(processedPacket.length + 4);
                        response.putShort(origDstPort);  // Swap ports for response
                        response.putShort(origSrcPort);
                        response.put(processedPacket);
                        response.flip();

                        getUDPHandler().sendPacket(sourcePort, sourceIP, origSrcPort, response);
                    }

                } catch (Exception e) {
                    log.error("Error handling VPN packet: {}", e.getMessage());
                }
            });
        }
    }

    
    /**
     * Updates the traffic statistics for a specific peer.
     *
     * <p>
     * This method increments the byte counters for a given peer based on whether the data was sent
     * or received. It ensures that traffic metrics are accurately maintained for monitoring and
     * bandwidth estimation purposes.
     * </p>
     *
     * @param peerId     The identifier of the peer (typically in the format "address:port").
     * @param bytes      The number of bytes to add to the counter.
     * @param isReceived {@code true} if the bytes were received from the peer; {@code false} if sent to the peer.
     */
    private void updatePeerStats(String peerId, int bytes, boolean isReceived) {
        Map<String, Long> stats = isReceived ? bytesReceived : bytesSent;
        stats.compute(peerId, (k, v) -> (v == null ? 0L : v) + bytes);
    }



    /**
     * Initiates the P2P network node by solving the initial proof of work, setting up UDP listeners if initiator,
     * and preparing the node to accept peer connections and route network packets.
     *
     * <p>
     * This method performs the following actions:
     * <ul>
     *   <li>Solves the initial proof of work to authenticate the node within the network.</li>
     *   <li>If the node is an initiator, it sets up the necessary listeners for incoming connections.</li>
     *   <li>Connects to initial peers obtained from the bootstrap process.</li>
     *   <li>Starts background services for accepting connections, routing packets, and managing proxies.</li>
     *   <li>Initializes the SOCKS proxy to facilitate external applications to use the VPN network.</li>
     * </ul>
     * </p>
     *
     * @throws IOException  If there is an error during network setup, such as binding to the specified port.
     * @throws Exception    If the proof of work cannot be solved or other initialization errors occur.
     */
    public void start() throws IOException, Exception {
        // Solve initial proof of work
        if (!pow.solve()) {
            throw new RuntimeException("Failed to generate initial proof of work");
        }

        try {
            if (isInitiator) {
                log.info("Starting initiator node on port {}", port);

                // Create and start initiator connection
                VPNConnection serverConn = new VPNConnection("0.0.0.0", port, true, nodeId, pow);
                serverConn.setGossipHandler(this);

            } else {
                // For non-initiator nodes
                try {
                    // First try to find and connect to peers
                    Set<InetSocketAddress> peers_ = peerDiscovery.bootstrap();
                    if (peers_.isEmpty()) {
                        throw new IOException("Could not find any peers");
                    }
                    connectToInitialPeers(peers_);

                    // We're already connected and listening through the VPNConnection 
                    // created in connectToInitialPeers - no need for a second listener
                    log.info("Connected to peers successfully, ready for traffic");

                } catch (IOException e) {
                    log.error("Failed to initialize network: {}", e.getMessage());
                    throw e;
                }
            }

            // Start services that are common to both modes
            // Start threads with debug logging
            executor.submit(() -> {
                Thread.currentThread().setName("AcceptConnectionsThread");
                log.info("Starting AcceptConnectionsThread");
                acceptConnections();
            });

            executor.submit(() -> {
                Thread.currentThread().setName("RoutePacketsThread");
                log.info("Starting RoutePacketsThread");
                routePackets();
            });

            // Start SOCKS proxy
            try {
                int socksPort = port + 1;  // Use next port for SOCKS proxy
                log.info("Starting SOCKS proxy on port {}", socksPort);
                new SocksProxy(networkStack.getUDPHandler(), socksPort);
                log.info("SOCKS proxy started successfully on port {}", socksPort);
            } catch (IOException e) {
                log.error("Failed to start SOCKS proxy: {}", e.getMessage());
                throw e;
            }

            log.info("Network node fully started and ready for connections");
        } catch (Exception e) {
            log.error("Failed to start network: {}", e.getMessage());
            throw e;
        }
    }




    /**
     * Continuously listens for and accepts incoming peer connection requests.
     *
     * <p>
     * This method runs in a dedicated thread and handles new connections by delegating them to
     * the {@link #handleNewPeer(Socket)} method. It ensures that the node can accept multiple
     * peer connections concurrently, respecting the maximum peer limit.
     * </p>
     */
       private void acceptConnections() {
        Thread.currentThread().setName("P2P-AcceptLoop");
        Thread.currentThread().setPriority(Thread.NORM_PRIORITY);
        
        try {
            log.info("Starting accept loop with socket timeout: {}", 
                serverSocket.getSoTimeout());
            
            serverSocket.setReuseAddress(true);
            serverSocket.setSoTimeout(1000); // 1 second timeout
            
            while (running && !Thread.currentThread().isInterrupted()) {
                try {
                    Socket socket = serverSocket.accept();
                    socket.setSoTimeout(SOCKET_TIMEOUT);

                    if (peers.size() >= MAX_PEERS) {
                        log.warn("Rejecting connection from {}: peer limit reached", 
                            socket.getInetAddress());
                        socket.close();
                        continue;
                    }

                    // Submit connection handling with a meaningful thread name
                    executor.submit(() -> {
                        Thread.currentThread().setName("P2P-PeerHandler-" + socket.getInetAddress());
                        Thread.currentThread().setPriority(Thread.MIN_PRIORITY);
                        try {
                            handleNewPeer(socket);
                        } catch (Exception e) {
                            log.error("Error handling new peer: {}", e.getMessage());
                        }
                    });

                } catch (SocketTimeoutException e) {
                    // This is expected, just continue
                    Thread.sleep(100);
                } catch (IOException e) {
                    if (running) {
                        log.error("Error accepting connection: {}", e.getMessage());
                        Thread.sleep(1000); // Back off on error
                    }
                }
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            log.info("Accept loop interrupted");
        } catch (Exception e) {
            log.error("Fatal error in accept loop: {}", e.getMessage());
        }
    }
    
    /**
     * Continuously retrieves and routes network packets based on routing decisions.
     *
     * <p>
     * This method operates in a loop, fetching packets from the {@link SwarmRouter} and determining
     * their appropriate destinations. It ensures efficient packet routing by handling each packet
     * asynchronously and updating relevant routing metrics.
     * </p>
     */
    private void routePackets() {
        Thread.currentThread().setName("P2P-PacketRouter");
        Thread.currentThread().setPriority(Thread.MIN_PRIORITY);

        int emptyCount = 0;
        while (running && !Thread.currentThread().isInterrupted()) {
            try {
                ByteBuffer packet = router.getNextPacket();
                if (packet != null) {
                    routePacket(packet);
                    emptyCount = 0;
                } else {
                    emptyCount++;
                    // Exponential backoff with max delay of 1 second
                    long sleepTime = Math.min(10L * emptyCount, 1000L);
                    Thread.sleep(sleepTime);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            } catch (Exception e) {
                log.error("Error routing packet: {}", e.getMessage());
                try {
                    Thread.sleep(100); // Brief pause on error
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        }
    }
        private void logThreadState() {
        Thread currentThread = Thread.currentThread();
        log.debug("Thread {} (ID: {}) executing, priority: {}", 
            currentThread.getName(),
            currentThread.getId(),
            currentThread.getPriority());
        
        // Print stack trace for debugging
        StackTraceElement[] stackTrace = currentThread.getStackTrace();
        StringBuilder sb = new StringBuilder();
        for (StackTraceElement element : stackTrace) {
            sb.append("\n\tat ").append(element);
        }
        log.debug("Stack trace: {}", sb);
    }
    /**
     * Routes a single network packet to its designated destination.
     *
     * <p>
     * This method parses the incoming packet to determine its destination IP address, retrieves
     * the next hop using the {@link SwarmRouter}, and forwards the packet through the appropriate
     * peer's {@link VPNConnection}. It also applies NAT processing and updates routing metrics based
     * on the packet's transmission.
     * </p>
     *
     * @param packet The {@link ByteBuffer} containing the raw IP packet data to be routed.
     */
    private void routePacket(ByteBuffer packet) {
        try {
            IPPacket ipPacket = new IPPacket(packet);
            String destIP = IPPacket.formatIP(ipPacket.getDestinationIP());
            
            // Get next hop
            String nextHop = router.getNextHop(destIP);
            if (nextHop == null) {
                log.debug("No route to {}, dropping packet", destIP);
                return;
            }
            
            // Get peer for next hop
            Peer peer = findPeerById(nextHop);
            if (peer == null) {
                log.debug("Peer {} not found for route to {}", nextHop, destIP);
                return;
            }
            
            // Apply NAT and send
            byte[] nattedPacket = natHandler.processOutgoingPacket(packet.array(), 
                getLocalSubnet());
            if (nattedPacket != null) {
                peer.getConnection().sendPacket(nattedPacket);
                updatePeerStats(nextHop, nattedPacket.length, false);
                
                // Update route metrics
                updateRouteMetrics(nextHop, ipPacket, nattedPacket.length);
            }
            
        } catch (IOException e) {
            log.error("Error processing outbound packet: {}", e.getMessage());
        }
    }


    /**
     * Processes an incoming network packet from a specific peer.
     *
     * <p>
     * This method analyzes the packet to determine if it is destined for the local network or needs
     * to be forwarded to another peer. It updates routing metrics based on the packet's source and
     * destination, and ensures that packets intended for the local subnet are injected into the
     * virtual network interface.
     * </p>
     *
     * @param packet      The {@link ByteBuffer} containing the raw IP packet data.
     * @param sourcePeer  The identifier of the peer from which the packet was received.
     */
    private void processIncomingPacket(ByteBuffer packet, String sourcePeer) {
        try {
            IPPacket ipPacket = new IPPacket(packet);
            String destIP = IPPacket.formatIP(ipPacket.getDestinationIP());
            
            // Update routing information
            updateRouteMetrics(sourcePeer, ipPacket, packet.remaining());
            
            // Check if packet is for us
            if (isForLocalNetwork(destIP)) {
                networkStack.injectPacket(packet);
                return;
            }
            
            // Forward packet
            String nextHop = router.getNextHop(destIP);
            if (nextHop != null && !nextHop.equals(sourcePeer)) {
                router.routePacket(packet, nextHop);
            } else {
                log.debug("No route to {} from {}", destIP, sourcePeer);
            }
            
        } catch (Exception e) {
            log.error("Error processing inbound packet: {}", e.getMessage());
        }
    }
    
    /**
     * Updates routing metrics based on the transmission of a packet.
     *
     * <p>
     * This method calculates and updates metrics such as latency and bandwidth for the route
     * through the specified peer. These metrics inform routing decisions and help optimize
     * packet forwarding within the network.
     * </p>
     *
     * @param peerId     The identifier of the peer through which the packet was sent or received.
     * @param packet     The {@link IPPacket} representing the packet.
     * @param packetSize The size of the packet in bytes.
     */
    private void updateRouteMetrics(String peerId, IPPacket packet, int packetSize) {
        Peer peer = findPeerById(peerId);
        if (peer != null) {
            String destIP = IPPacket.formatIP(packet.getDestinationIP());
            
            // Calculate metrics
            double latency = peer.getLatency();
            long bandwidth = calculateBandwidth(peer, packetSize);
            
            // Update router
            router.updateMetrics(destIP, peerId, latency, bandwidth);
        }
    }
    
    /**
     * Estimates the bandwidth for a specific peer based on recent packet transmissions.
     *
     * <p>
     * This method calculates the bandwidth by summing the bytes sent and received from the peer
     * over a defined duration and normalizes it to bytes per second. It provides an estimate of
     * the current network capacity with the peer.
     * </p>
     *
     * @param peer          The {@link Peer} for which bandwidth is being calculated.
     * @param newPacketSize The size of the new packet in bytes.
     * @return The estimated bandwidth in bytes per second.
     */
    private long calculateBandwidth(Peer peer, int newPacketSize) {
        long totalBytes = bytesSent.getOrDefault(Arrays.toString(peer.getNodeId()), 0L) +
                           bytesReceived.getOrDefault(Arrays.toString(peer.getNodeId()), 0L) +
                           newPacketSize;
                         
        long duration = System.currentTimeMillis() - peer.getLastProofTimestamp();
        if (duration == 0) return 0;
        
        return (totalBytes * 1000) / duration; // bytes per second
    }


    /**
     * Searches for a peer based on its identifier.
     *
     * <p>
     * This method iterates through the list of active peers to find a peer that matches the
     * provided identifier. It is used to retrieve peer details required for routing decisions.
     * </p>
     *
     * @param peerId The identifier of the peer to find.
     * @return The {@link Peer} instance if found; {@code null} otherwise.
     */
    private Peer findPeerById(String peerId) {
        for (Peer peer : peers.values()) {
            if (ByteBuffer.wrap(peer.getNodeId()).toString().equals(peerId)) {
                return peer;
            }
        }
        return null;
    }
    
    /**
     * Retrieves the local subnet based on the node's IP address.
     *
     * <p>
     * This method extracts the subnet portion of the node's IP address to determine the range
     * of IP addresses that are considered part of the local network. It is used for routing
     * decisions and NAT processing.
     * </p>
     *
     * @return A {@link String} representing the local subnet (e.g., "10.0.0").
     */
    private String getLocalSubnet() {
        return ipAddress.substring(0, ipAddress.lastIndexOf('.'));
    }
    
    /**
     * Determines whether a given IP address belongs to the local network.
     *
     * <p>
     * This method checks if the provided IP address falls within the node's local subnet. It is
     * used to decide whether to inject packets into the local network interface or to route them
     * through the P2P network.
     * </p>
     *
     * @param ipAddress The IP address to evaluate.
     * @return {@code true} if the IP address is within the local subnet; {@code false} otherwise.
     */
    private boolean isForLocalNetwork(String ipAddress) {
        String ourSubnet = this.ipAddress.startsWith("10.0.0") ? "10.0.0" : "10.0.1";
        return ipAddress.startsWith(ourSubnet);
    }

    
    /**
     * Conducts a handshake with a connected peer to establish a secure communication channel.
     *
     * <p>
     * This method exchanges peer information and proofs of work to authenticate the peer and
     * validate its legitimacy within the network. It ensures that both parties agree on their
     * identities and have performed the necessary computational work to participate in the network.
     * </p>
     *
     * @param conn The {@link VPNConnection} instance representing the connection to the peer.
     * @throws IOException If the handshake fails due to I/O errors or invalid data exchange.
     */
    private void performHandshake(VPNConnection conn) throws IOException {
        try {
            // Wait for peer info first
            log.info("Receiving peer info...");
            byte[] peerNodeId = conn.receivePeerInfo();
            log.info("Received peer ID, length: {}", peerNodeId.length);
            
            // Then receive proof of work
            byte[] proofData = conn.receiveProof();
            long peerTimestamp = ByteBuffer.wrap(proofData, proofData.length - 8, 8).getLong();
            
            // Send our info back
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            DataOutputStream dos = new DataOutputStream(baos);
            dos.writeInt(nodeId.length);
            dos.write(nodeId);
            conn.sendMessage(VPNConnection.MSG_TYPE_PEER_INFO, baos.toByteArray());
            
            // Send our proof
            byte[] proof = pow.getCurrentProof();
            long timestamp = pow.getTimestamp();
            conn.sendProof(proof, timestamp);
        } catch (IOException e) {
            throw new IOException("Handshake failed: " + e.getMessage(), e);
        }
    }
    
    /**
     * Handles the establishment of a new peer connection by performing handshake procedures and validating proofs of work.
     *
     * <p>
     * This method ensures that the connecting peer is authenticated and meets the network's proof-of-work
     * requirements. Upon successful validation, it initializes the peer's connection details and integrates
     * the peer into the network routing mechanisms.
     * </p>
     *
     * @param address The IP address of the new peer.
     * @param port    The port number of the new peer.
     * @param conn    The {@link VPNConnection} instance representing the connection to the peer.
     * @throws Exception If there is an error during the handshake or validation process.
     */
    private void handleNewPeerConnection(String address, int port, VPNConnection conn) throws Exception {
        // Wait for peer info and proof
        log.info("Receiving peer info from {}:{}", address, port);
        byte[] peerNodeId = conn.receivePeerInfo();
        log.info("Received peer ID, length: {}", peerNodeId.length);
        
        ByteBuffer peerId = ByteBuffer.wrap(peerNodeId);
        if (peers.containsKey(peerId)) {
            try (conn) {
                log.warn("Duplicate peer connection, closing");
            }
            return;
        }
        
        // Get and verify proof of work
        byte[] proofData = conn.receiveProof();
        long peerTimestamp = ByteBuffer.wrap(proofData, proofData.length - 8, 8).getLong();
        
        if (!pow.verify(Arrays.copyOf(proofData, proofData.length - 8), peerTimestamp)) {
            try (conn) {
                log.warn("Invalid proof of work from peer");
            }
            return;
        }
        
        // Create peer
        Peer peer = new Peer(address, port, peerNodeId);
        peer.setProofOfWork(Arrays.copyOf(proofData, proofData.length - 8));
        peer.setLastProofTimestamp(peerTimestamp);
        peer.setConnection(conn);
        
        peers.put(peerId, peer);
        log.info("Added peer to network: {}:{}", address, port);
        
        sendInitialRoutes(peer);
        executor.submit(() -> handlePeerTraffic(peer));
        // Send acknowledgment
        conn.sendMessage(VPNConnection.MSG_TYPE_PEER_INFO, new byte[]{1});  // Simple ack
        
        log.info("New peer connection established: {}:{}", address, port);
    }


    /**
     * Initializes and sets up a new peer connection from an accepted socket.
     *
     * <p>
     * This method creates a {@link VPNConnection} instance for the newly connected peer, assigns
     * appropriate handlers, and prepares the connection for data transmission. It ensures that the
     * peer is integrated into the network's routing and NAT mechanisms.
     * </p>
     *
     * @param socket The {@link Socket} representing the incoming peer connection.
     */
    private void handleNewPeer(Socket socket) {
        try {
            log.info("Setting up new peer connection from: {}", socket.getInetAddress());
            
            // Create VPN connection with handler
            VPNConnection conn = new VPNConnection(null, port, isInitiator, this.nodeId);
            conn.setGossipHandler(this);
            conn.setConnectionHandler(connectionHandler);  // Add this line
            
            log.info("UDP listener established on port {}", port);
            
        } catch (Exception e) {
            log.error("Failed to setup peer connection: {}", e.getMessage());
            try {
                socket.close();
            } catch (IOException ignored) {}
        }
    }
    
    /**
     * Retrieves the UDP handler responsible for managing UDP traffic within the network stack.
     *
     * <p>
     * This method provides access to the {@link UDPHandler} instance from the {@link NetworkStack},
     * allowing for direct manipulation or monitoring of UDP-based VPN traffic.
     * </p>
     *
     * @return The {@link UDPHandler} associated with this network node.
     */
    public UDPHandler getUDPHandler() {
        return networkStack.getUDPHandler();
    }

    /**
     * Initiates a connection to a specified peer using its address and port.
     *
     * <p>
     * This method attempts to establish a secure connection to the given peer by creating a {@link VPNConnection}.
     * It employs an exponential backoff strategy for connection retries and respects the maximum peer limit.
     * Upon successful connection, the peer is integrated into the network's routing and NAT systems.
     * </p>
     *
     * @param address The IP address of the peer to connect to.
     * @param port    The port number of the peer to connect to.
     * @throws IOException If the connection attempt fails after exhausting all retry attempts.
     */
    public void connectToPeer(String address, int port) throws IOException {
        String peerAddr = address + ":" + port;
        log.info("Connecting to peer {}:{}", address, port);
    
        // Check if already connected
        for (Peer peer : peers.values()) {
            if ((peer.getAddress() + ":" + peer.getPort()).equals(peerAddr)) {
                log.info("Already connected to peer {}", peerAddr);
                return;
            }
        }
    
        IOException lastException = null;
        int initialTimeout = 1000; // Start with 1 second timeout
        int maxAttempts = 5;
    
        for (int attempt = 1; attempt <= maxAttempts; attempt++) {
            try {
                int currentTimeout = initialTimeout * (int) Math.pow(2, attempt - 1); // Exponential backoff
                log.info("Connecting to peer {}:{} (attempt {}/{}) with timeout {}ms",
                        address, port, attempt, maxAttempts, currentTimeout);
    
                // Create connection with pow instance
                VPNConnection conn = new VPNConnection(address, port, isInitiator, nodeId, pow);
                conn.setTimeout(currentTimeout); 
                conn.setGossipHandler(this);
    
                // Exchange keys and establish secure channel 
                log.debug("Exchanging peer info and proofs with {}:{}", address, port);
    
                // Send peer info 
                ByteBuffer info = ByteBuffer.allocate(32);
                info.putInt(4);  // Version
                info.putLong(System.currentTimeMillis());
                info.flip();
                conn.sendMessage(VPNConnection.MSG_TYPE_PEER_INFO, info.array());
    
                // Send proof
                ByteBuffer proof = ByteBuffer.allocate(40);
                proof.putInt(1);  // Version
                proof.putLong(System.currentTimeMillis());
                proof.flip();
                conn.sendMessage(VPNConnection.MSG_TYPE_PROOF, proof.array());
    
                // Create and add peer
                Peer peer = new Peer(address, port, nodeId);
                peer.setProofOfWork(pow.getCurrentProof());
                peer.setLastProofTimestamp(pow.getTimestamp());
                peer.setConnection(conn);
    
                peers.put(ByteBuffer.wrap(nodeId), peer);
                
                log.info("Successfully connected to peer {}:{}", address, port);
                return;
    
            } catch (SocketTimeoutException e) {
                log.warn("Connection attempt {} timed out", attempt);
                lastException = e;
    
            } catch (IOException e) {
                log.error("Failed to connect to peer {}:{}: {}", address, port, e.getMessage());
                lastException = e;
    
            } catch (Exception e) {
                log.error("Unexpected error while connecting to peer {}:{}: {}", address, port, e.getMessage());
                throw new IOException(e);
            }
    
            // Wait before the next attempt
            try {
                Thread.sleep(initialTimeout * (int) Math.pow(2, attempt - 1));
            } catch (InterruptedException ie) {
                Thread.currentThread().interrupt();
                throw new IOException("Connection interrupted during backoff", ie);
            }
        }
    
        throw new IOException("Failed to connect after " + maxAttempts + " attempts", lastException);
    }


    /**
     * Manages the data traffic from a connected peer by continuously receiving and processing packets.
     *
     * <p>
     * This method runs in a separate thread, listening for incoming VPN packets from the specified peer.
     * It updates latency metrics based on packet reception times and delegates packet processing to
     * the {@link #processIncomingPacket(ByteBuffer, String)} method. If the connection is disrupted,
     * the peer is removed from the network.
     * </p>
     *
     * @param peer The {@link Peer} instance representing the connected peer.
     */
    private void handlePeerTraffic(Peer peer) {
        try {
            VPNConnection conn = peer.getConnection();
            while (running && !Thread.currentThread().isInterrupted()) {
                try {
                    long hPt_startTime = System.nanoTime();
                    byte[] packet = conn.receivePacket();
                    
                    if (packet != null) {
                        updatePeerStats(Arrays.toString(peer.getNodeId()), packet.length, true);
                        double latency = (System.nanoTime() - hPt_startTime) / 1_000_000.0;
                        peer.updateLatency(latency);
                        processIncomingPacket(ByteBuffer.wrap(packet), 
                            Arrays.toString(peer.getNodeId()));
                    }
                    
                } catch (SocketTimeoutException e) {
                    // This is normal, continue
    
                } catch (IOException e) {
                    if ("Connection closed by peer".equals(e.getMessage())) {
                        log.info("Peer {} disconnected gracefully", peer.getAddress());
                    } else {
                        log.error("Error reading from peer {}: {}", 
                            peer.getAddress(), e.getMessage());
                    }
                    break;
                }
            }
        } finally {
            removePeer(peer);
        }
    }
    
    /**
     * Sends the initial routing information to a newly connected peer to establish routing pathways.
     *
     * <p>
     * This method prepares and transmits the current routing table and peer information to the specified
     * peer using gossip messages. It ensures that both nodes have a consistent view of the network's routing
     * state, facilitating efficient packet forwarding and network synchronization.
     * </p>
     *
     * @param peer The {@link Peer} instance representing the newly connected peer.
     * @throws IOException If there is an error while sending routing information.
     */
    private void sendInitialRoutes(Peer peer) throws IOException {
        // Always add a direct route to this peer
        String peerSubnet = peer.getAddress().substring(0, peer.getAddress().lastIndexOf('.')) + ".0";
        String peerId = Arrays.toString(peer.getNodeId());
        
        // Add direct route to peer's subnet
        router.updateRoute(peerSubnet, peerId, 1);
        
        // If this is the initiator (10.0.0.1), add route to self for default gateway
        if (isInitiator) {
            router.updateRoute("10.0.0.1", peerId, 1);
            
            // Add high pheromone level for direct connection
            String routeKey = "10.0.0.1-" + peerId;
            router.updateMetrics("10.0.0.1", peerId, 0.1, 1000000); // Low latency, high bandwidth
        } else {
            // If we're not the initiator, add route to initiator through this peer if it's 10.0.0.x
            if (peer.getAddress().startsWith("10.0.0")) {
                router.updateRoute("10.0.0.1", peerId, 1);
                router.updateMetrics("10.0.0.1", peerId, 0.1, 1000000);
            }
        }
        
        // Share current routes
        Map<String, RouteInfo> currentRoutes = new HashMap<>();
        for (Map.Entry<String, Map<String, RouteInfo>> entry : router.getRoutes().entrySet()) {
            String destination = entry.getKey();
            Map<String, RouteInfo> routes = entry.getValue();
            
            for (Map.Entry<String, RouteInfo> routeEntry : routes.entrySet()) {
                String nextHop = routeEntry.getKey();
                RouteInfo route = routeEntry.getValue();
                
                // Only share routes we're actually using
                if (route.getScore() > 0) {
                    currentRoutes.put(destination + "-" + nextHop, route);
                }
            }
        }
        
        GossipMessage gossip = new GossipMessage(
            nodeId,
            pow.getCurrentProof(),
            pow.getTimestamp(),
            new ArrayList<>(peers.values()),
            currentRoutes
        );
        
        peer.getConnection().sendGossip(gossip);
        peer.updateLastGossip();
        log.debug("Sent initial routes to peer: {}", peer.getAddress());
    }


    /**
     * Removes a peer from the network, updating routing tables and cleaning up associated resources.
     *
     * <p>
     * This method deregisters the peer from the active peers list, removes any associated routes
     * from the {@link SwarmRouter}, and closes the peer's {@link VPNConnection}. It also cleans up
     * traffic statistics related to the peer and triggers peer count checks to maintain network health.
     * </p>
     *
     * @param peer The {@link Peer} instance to be removed from the network.
     */
    private void removePeer(Peer peer) {
        log.info("Removing peer: {}", peer.getAddress());
        
        ByteBuffer peerId = ByteBuffer.wrap(peer.getNodeId());
        peers.remove(peerId);
        router.removePeer(Arrays.toString(peer.getNodeId()));
        
        try {
            peer.getConnection().close();
        } catch (IOException e) {
            log.debug("Error closing peer connection: {}", e.getMessage());
        }
        
        // Clean up statistics
        bytesSent.remove(Arrays.toString(peer.getNodeId()));
        bytesReceived.remove(Arrays.toString(peer.getNodeId()));
        
        // Check if we need to find more peers
        checkPeerCount();
    }
    
    /**
     * Verifies that the network maintains the minimum required number of active peers.
     *
     * <p>
     * If the current peer count falls below the defined minimum, this method initiates a bootstrap
     * process to discover and connect to new peers, ensuring network robustness and reliability.
     * </p>
     */
    private void checkPeerCount() {
        if (peers.size() < MIN_PEERS || peerDiscovery.needsBootstrap()) {
            try {
                Set<InetSocketAddress> newPeers = peerDiscovery.bootstrap();
                connectToInitialPeers(newPeers);
            } catch (IOException e) {
                log.warn("Failed to bootstrap new peers: {}", e.getMessage());
            }
        }
    }
    
    /**
     * Initiates a search for new peers by requesting peer lists from existing connections.
     *
     * <p>
     * This method broadcasts peer discovery requests to currently connected peers via gossip messages,
     * allowing the node to expand its peer list and reinforce network connectivity. It ensures that
     * the network remains decentralized and resilient against peer disconnections.
     * </p>
     */
    private void seekNewPeers() {
        // Get list of known peers from existing connections
        Set<String> knownPeers = new HashSet<>();
        for (Peer peer : peers.values()) {
            knownPeers.add(peer.getAddress() + ":" + peer.getPort());
        }
        
        // Ask existing peers for their peer lists
        for (Peer peer : peers.values()) {
            try {
                GossipMessage gossip = new GossipMessage(
                    nodeId,
                    pow.getCurrentProof(),
                    pow.getTimestamp(),
                    new ArrayList<>(peers.values()),
                    new HashMap<>()
                );
                peer.getConnection().sendGossip(gossip);
            } catch (IOException e) {
                log.error("Failed to request peers from {}: {}", 
                    peer.getAddress(), e.getMessage());
            }
        }
    }

    /**
     * Executes the gossip protocol to share routing information and known peers with a subset of connected peers.
     *
     * <p>
     * This method selects a random subset of active peers and transmits the current network state,
     * including routing tables and peer lists. Gossiping helps in disseminating network information
     * efficiently, aiding in peer discovery and maintaining synchronized routing paths across the network.
     * </p>
     */
    private void gossip() {
        if (!running || peers.isEmpty()) return;
        
        // Select random subset of peers to gossip with
        List<Peer> activePeers = new ArrayList<>(peers.values());
        Collections.shuffle(activePeers);
        int gossipCount = Math.min(3, activePeers.size());
        
        // Prepare current routing information
        Map<String, RouteInfo> currentRoutes = new HashMap<>();
        for (Map.Entry<String, Map<String, RouteInfo>> entry : router.getRoutes().entrySet()) {
            String destination = entry.getKey();
            Map<String, RouteInfo> routes = entry.getValue();
            
            // Only share active routes
            routes.entrySet().stream()
                .filter(r -> r.getValue().getScore() > 0)
                .forEach(r -> currentRoutes.put(
                    destination + "-" + r.getKey(), r.getValue()));
        }
        
        // Add our direct routes
        for (Peer peer : peers.values()) {
            String peerSubnet = getSubnetForIP(peer.getAddress());
            RouteInfo directRoute = new RouteInfo(
                peerSubnet,             // destination
                Arrays.toString(peer.getNodeId()),  // nextHop
                1                       // hopCount
            );
            currentRoutes.put(peerSubnet + "-direct", directRoute);
        }

        // Send gossip to selected peers
        for (int i = 0; i < gossipCount; i++) {
            Peer peer = activePeers.get(i);
            try {
                GossipMessage gossip = new GossipMessage(
                    nodeId,
                    pow.getCurrentProof(),
                    pow.getTimestamp(),
                    new ArrayList<>(peers.values()),
                    currentRoutes
                );
                
                peer.getConnection().sendGossip(gossip);
                peer.updateLastGossip();
                
                log.debug("Sent gossip to peer: {}", peer.getAddress());
            } catch (IOException e) {
                log.error("Failed to gossip with peer {}: {}", 
                    peer.getAddress(), e.getMessage());
                removePeer(peer);
            }
        }
    }


    /**
     * Processes an incoming gossip message by updating routing tables and discovering new peers.
     *
     * <p>
     * This method validates the received gossip message and integrates any new routing information
     * or peer data into the network. It ensures that the node's routing decisions are informed by
     * the collective knowledge of connected peers, enhancing network efficiency and connectivity.
     * </p>
     *
     * @param message     The {@link GossipMessage} received from a peer.
     * @param sourcePeer  The {@link Peer} instance representing the source of the gossip message.
     */
    private void handleGossipMessage(GossipMessage message, Peer sourcePeer) {
        if (!message.isValid()) {
            log.warn("Received invalid gossip message from peer: {}", 
                sourcePeer != null ? sourcePeer.getAddress() : "unknown");
            return;
        }
        
        if (sourcePeer != null) {  // Add null check here
            // Update peer's proof of work if newer
            if (message.getProofTimestamp() > sourcePeer.getLastProofTimestamp()) {
                sourcePeer.setProofOfWork(message.getProofOfWork());
                sourcePeer.setLastProofTimestamp(message.getProofTimestamp());
            }
        }

        // Process peer information
        for (GossipMessage.PeerInfo peerInfo : message.getKnownPeers()) {
            ByteBuffer peerId = ByteBuffer.wrap(peerInfo.nodeId());
            
            // Skip if this is us
            if (Arrays.equals(peerInfo.nodeId(), nodeId)) continue;
            
            // Update existing peer information
            Peer existingPeer = peers.get(peerId);
            if (existingPeer != null) {
                if (peerInfo.proofTimestamp() > existingPeer.getLastProofTimestamp()) {
                    existingPeer.setProofOfWork(peerInfo.proofOfWork());
                    existingPeer.setLastProofTimestamp(peerInfo.proofTimestamp());
                }
                continue;
            }

            // Connect to new peers if we have capacity
            if (peers.size() < MAX_PEERS) {
                executor.submit(() -> {
                    try {
                        connectToPeer(peerInfo.address(), peerInfo.port());
                    } catch (IOException e) {
                        log.debug("Failed to connect to discovered peer {}:{}: {}", 
                            peerInfo.address(), peerInfo.port(), e.getMessage());
                    }
                });
            }
        }

        // Process routing information
        for (Map.Entry<String, RouteInfo> entry : message.getRoutes().entrySet()) {
            String[] parts = entry.getKey().split("-");
            if (parts.length != 2) continue;
            
            String destination = parts[0];
            String nextHop = parts[1];
            RouteInfo newRoute = entry.getValue();
            
            // Skip routes through ourselves
            if (Arrays.equals(newRoute.getNextHop().getBytes(), nodeId)) continue;
            
            // Update routing table
            router.updateRoute(destination, nextHop, newRoute.getHopCount() + 1);
            
            // Update metrics if available
            if (newRoute.getLatency() > 0 || newRoute.getBandwidth() > 0) {
                router.updateMetrics(destination, nextHop, 
                    newRoute.getLatency(), newRoute.getBandwidth());
            }
        }
    }


    /**
     * Updates the proof of work by generating a new proof and broadcasting it to all connected peers.
     *
     * <p>
     * This method periodically solves a new proof of work to maintain the node's authenticated status
     * within the network. Upon successfully generating a new proof, it disseminates the proof to all
     * peers via gossip messages, ensuring that the network acknowledges the node's ongoing participation.
     * </p>
     */
    private void updateProofOfWork() {
        executor.submit(() -> {
            if (pow.solve()) {
                byte[] newProof = pow.getCurrentProof();
                long newTimestamp = pow.getTimestamp();
                
                // Broadcast new proof to all peers
                for (Peer peer : peers.values()) {
                    try {
                        peer.getConnection().sendProof(newProof, newTimestamp);
                        log.debug("Sent new proof to peer: {}", peer.getAddress());
                    } catch (IOException e) {
                        log.error("Failed to send new proof to peer: {}", 
                            peer.getAddress(), e.getMessage());
                        removePeer(peer);
                    }
                }
                
                log.info("Successfully updated and broadcast new proof of work");
            } else {
                log.error("Failed to generate new proof of work");
            }
        });
    }
    
    /**
     * Sends keepalive messages to all connected peers to maintain active connections and detect inactive peers.
     *
     * <p>
     * This method periodically transmits ping messages to each peer, signaling the node's continued presence
     * within the network. Receiving acknowledgments from peers confirms active connections, while missing responses
     * may indicate stale or disconnected peers, prompting their removal from the network.
     * </p>
     */
    private void sendKeepalive() {
        if (!running) return;
            
        // Send keepalive to each connected peer
        for (Peer peer : peers.values()) {
            try {
                if (peer.getConnection() != null && peer.getConnection().isRunning()) {
                    log.debug("Sending keepalive to peer: {}", peer.getAddress());
                    peer.getConnection().sendMessage(VPNConnection.MSG_TYPE_PING, new byte[]{});
                    peer.updateLastSeen();
                }
            } catch (IOException e) {
                log.error("Failed to send keepalive to peer {}: {}", peer.getAddress(), e.getMessage());
                removePeer(peer);
            }
        }
    }
    
    /**
     * Evaluates the health of all connected peers and removes any that are deemed stale or unresponsive.
     *
     * <p>
     * This method iterates through the list of active peers, checking metrics such as last seen timestamps
     * and latency. Peers that have not communicated within a defined threshold or exhibit poor performance
     * are removed to maintain network integrity and performance.
     * </p>
     */
    private void checkPeerHealth() {
        if (!running || peers.isEmpty()) return;
            
        List<Peer> stalePeers = new ArrayList<>();
        
        for (Peer peer : peers.values()) {
            if (peer.isStale()) {
                log.warn("Peer {} is stale, marking for removal", peer.getAddress());
                stalePeers.add(peer);
            }
        }
        
        // Remove stale peers
        for (Peer peer : stalePeers) {
            removePeer(peer);
        }
        
        // Check if we need more peers
        if (peers.size() < MIN_PEERS) {
            log.info("Peer count ({}) below minimum ({}), seeking new peers", 
                peers.size(), MIN_PEERS);
            seekNewPeers();
        }
    }


    /**
     * Determines the subnet for a given IP address.
     *
     * <p>
     * This method extracts the subnet portion from the provided IP address, facilitating routing
     * decisions and network segmentation. It assumes a standard IPv4 address format.
     * </p>
     *
     * @param ipAddress The IP address for which the subnet is to be determined.
     * @return A {@link String} representing the subnet in CIDR notation (e.g., "10.0.0.0/24").
     */
    private String getSubnetForIP(String ipAddress) {
        return ipAddress.substring(0, ipAddress.lastIndexOf('.')) + ".0/24";
    }
    
    /**
     * Aggregates and retrieves comprehensive network statistics.
     *
     * <p>
     * This method compiles various metrics such as active peers, traffic statistics, latency,
     * bandwidth estimates, routing information, proof of work status, and NAT mappings. The
     * returned data is suitable for monitoring tools, dashboards, or diagnostic purposes.
     * </p>
     *
     * @return A {@link Map} containing key-value pairs of network statistics and metrics.
     */
    public Map<String, Object> getNetworkStats() {
        Map<String, Object> stats = new HashMap<>();
        
        // Basic network info
        stats.put("nodeId", ByteBuffer.wrap(nodeId).toString());
        stats.put("ipAddress", ipAddress);
        stats.put("port", port);
        stats.put("uptime", System.currentTimeMillis() - startTime);
        
        // Peer statistics
        stats.put("activePeers", peers.size());
        stats.put("maxPeers", MAX_PEERS);
        stats.put("minPeers", MIN_PEERS);
        
        // Traffic statistics
        long totalBytesSent = bytesSent.values().stream().mapToLong(Long::longValue).sum();
        long totalBytesReceived = bytesReceived.values().stream().mapToLong(Long::longValue).sum();
        stats.put("totalBytesSent", totalBytesSent);
        stats.put("totalBytesReceived", totalBytesReceived);
        
        // Calculate average metrics
        double avgLatency = peers.values().stream()
            .mapToDouble(Peer::getLatency)
            .filter(l -> l != Double.MAX_VALUE)
            .average()
            .orElse(0.0);
        
        double avgBandwidth = peers.values().stream()
            .mapToLong(Peer::getEstimatedBandwidth)
            .average()
            .orElse(0.0);
        
        stats.put("averageLatency", String.format("%.2fms", avgLatency));
        stats.put("averageBandwidth", String.format("%.2f KB/s", avgBandwidth / 1024));
        
        // Route statistics
        stats.put("activeRoutes", router.getRoutes().size());
        Map<String, Double> pheromoneStats = new HashMap<>();
        router.getRoutes().forEach((dest, routes) -> 
            routes.forEach((next, route) -> 
                pheromoneStats.put(dest + "-" + next, route.getScore())));
        stats.put("routeScores", pheromoneStats);
        
        // Proof of work info
        stats.put("lastProofUpdate", pow.getTimestamp());
        stats.put("proofAge", 
            TimeUnit.MILLISECONDS.toMinutes(System.currentTimeMillis() - pow.getTimestamp()));
            
        // NAT statistics
        stats.put("natStats", natHandler.getStats());
        
        return stats;
    }


    /**
     * Retrieves detailed information about all active peers in the network.
     *
     * <p>
     * This method collects and formats data such as each peer's address, port, node ID, latency,
     * bandwidth usage, traffic statistics, last seen timestamp, and routing scores. The information
     * is structured in a list of maps for easy consumption by external systems or for display purposes.
     * </p>
     *
     * @return A {@link List} of {@link Map} objects, each containing detailed attributes of a peer.
     */
    public List<Map<String, Object>> getPeerDetails() {
        List<Map<String, Object>> peerList = new ArrayList<>();
        
        for (Peer peer : peers.values()) {
            Map<String, Object> details = new HashMap<>();
            details.put("address", peer.getAddress());
            details.put("port", peer.getPort());
            details.put("nodeId", ByteBuffer.wrap(peer.getNodeId()).toString());
            details.put("latency", peer.getLatency());
            details.put("bandwidth", peer.getEstimatedBandwidth());
            details.put("bytesSent", bytesSent.getOrDefault(Arrays.toString(peer.getNodeId()), 0L));
            details.put("bytesReceived", bytesReceived.getOrDefault(Arrays.toString(peer.getNodeId()), 0L));
            details.put("lastSeen", System.currentTimeMillis() - peer.getLastGossip());
            details.put("routeScore", router.getScore(Arrays.toString(peer.getNodeId())));
            peerList.add(details);
        }
        
        return peerList;
    }
    
    /**
     * Generates a comprehensive string representation of the current routing table.
     *
     * <p>
     * This method iterates through all active routes, detailing each destination, the next hop,
     * hop count, pheromone score, latency, and bandwidth. The output is formatted for readability,
     * making it useful for diagnostics and network monitoring.
     * </p>
     *
     * @return A {@link String} containing the formatted routing table information.
     */
    public String dumpRoutingTable() {
        StringBuilder dump = new StringBuilder();
        dump.append("Current Routing Table:\n");
        
        router.getRoutes().forEach((destination, routes) -> {
            dump.append("\nDestination: ").append(destination).append("\n");
            routes.forEach((nextHop, route) -> {
                String peerAddress = "unknown";
                for (Peer peer : peers.values()) {
                    if (nextHop.equals(Arrays.toString(peer.getNodeId()))) {
                        peerAddress = peer.getAddress();
                        break;
                    }
                }
                
                dump.append(String.format("  via %s (peer: %s):\n", nextHop, peerAddress));
                dump.append(String.format("    hops: %d\n", route.getHopCount()));
                dump.append(String.format("    score: %.3f\n", route.getScore()));
                dump.append(String.format("    latency: %.2fms\n", route.getLatency()));
                dump.append(String.format("    bandwidth: %d B/s\n", route.getBandwidth()));
            });
        });
        
        return dump.toString();
    }


    /**
     * Logs periodic network statistics to aid in monitoring and diagnostics.
     *
     * <p>
     * This method gathers current network metrics and outputs them to the logging system at
     * regular intervals. It includes information such as peer counts, traffic volumes, latency,
     * bandwidth, routing details, and proof of work status. These logs are instrumental in
     * assessing the network's health and performance over time.
     * </p>
     */
    private void logStats() {
        if (!running) return;
        
        Map<String, Object> stats = getNetworkStats();
        log.info("Network Statistics:");
        log.info("  Peers: {}/{}", stats.get("activePeers"), stats.get("maxPeers"));
        log.info("  Traffic: {} sent, {} received", 
            formatBytes((Long)stats.get("totalBytesSent")),
            formatBytes((Long)stats.get("totalBytesReceived")));
        log.info("  Latency: {}, Bandwidth: {}", 
            stats.get("averageLatency"),
            stats.get("averageBandwidth"));
        log.info("  Routes: {}", stats.get("activeRoutes"));
        log.info("  Proof age: {} minutes", stats.get("proofAge"));
    }
    
    /**
     * Converts a byte count into a human-readable string with appropriate units.
     *
     * <p>
     * This utility method formats large byte values into kilobytes (KB), megabytes (MB),
     * gigabytes (GB), etc., enhancing the readability of traffic statistics and other
     * byte-based metrics.
     * </p>
     *
     * @param bytes The number of bytes to format.
     * @return A {@link String} representing the formatted byte count with units.
     */
    private String formatBytes(long bytes) {
        if (bytes < 1024) return bytes + " B";
        int exp = (int) (Math.log(bytes) / Math.log(1024));
        String pre = "KMGTPE".charAt(exp-1) + "";
        return String.format("%.1f %sB", bytes / Math.pow(1024, exp), pre);
    }
    
    /**
     * Retrieves a list of all active peers in the network in a formatted string representation.
     *
     * <p>
     * This method compiles a list of peer addresses along with their corresponding ports and
     * cumulative traffic statistics. The output is structured for easy display or logging.
     * </p>
     *
     * @return A {@link List} of {@link String} objects, each representing an active peer and its traffic.
     */
    public List<String> getPeerList() {
        List<String> peerList = new ArrayList<>();
        for (Peer peer : peers.values()) {
            peerList.add(String.format("%s:%d (%s)", 
                peer.getAddress(), 
                peer.getPort(),
                formatBytes(bytesSent.getOrDefault(Arrays.toString(peer.getNodeId()), 0L) +
                          bytesReceived.getOrDefault(Arrays.toString(peer.getNodeId()), 0L))));
        }
        return peerList;
    }


    /**
     * Evaluates the overall health of the network node based on various criteria.
     *
     * <p>
     * This method assesses multiple aspects such as the node's running status, peer count,
     * proof of work freshness, active routing paths, and the health metrics of connected peers.
     * It returns {@code true} if the network meets all health criteria, indicating optimal operation.
     * Otherwise, it returns {@code false}, signaling potential issues that may require attention.
     * </p>
     *
     * @return {@code true} if the network is healthy; {@code false} otherwise.
     */
    public boolean isHealthy() {
        if (!running) return false;
        if (peers.size() < MIN_PEERS) return false;
        
        // Check if we have recent proof of work
        long proofAge = System.currentTimeMillis() - pow.getTimestamp();
        if (proofAge > TimeUnit.HOURS.toMillis(24)) return false;
        
        // Check if we have active routes
        if (router.getRoutes().isEmpty()) return false;
        
        // Check peer health
        long healthyPeers = peers.values().stream()
            .filter(p -> !p.isStale())
            .filter(p -> p.getLatency() < 1000)
            .count();
            
        return healthyPeers >= MIN_PEERS;
    }
    
    /**
     * Registers a callback function to receive periodic network statistics updates.
     *
     * <p>
     * This method allows external components or monitoring tools to receive real-time network
     * statistics by providing a {@link Consumer} that processes the statistics map. The callback
     * is invoked at fixed intervals, enabling continuous monitoring and dynamic responses based
     * on network performance.
     * </p>
     *
     * @param callback A {@link Consumer} that accepts a {@link Map} of network statistics.
     */
    public void addStatsCallback(Consumer<Map<String, Object>> callback) {
        scheduler.scheduleAtFixedRate(() -> {
            try {
                callback.accept(getNetworkStats());
            } catch (Exception e) {
                log.error("Error in stats callback: {}", e.getMessage());
            }
        }, 1, 1, TimeUnit.MINUTES);
    }

    /**
     * Gracefully shuts down the P2P network node by notifying peers, terminating threads, and releasing resources.
     *
     * <p>
     * This method performs the following actions to ensure a clean shutdown:
     * <ul>
     *   <li>Sets the running flag to {@code false} to signal all threads to terminate.</li>
     *   <li>Notifies all connected peers of the shutdown by sending a ping message with a specific payload.</li>
     *   <li>Closes the server socket and shuts down scheduled and executor thread pools.</li>
     *   <li>Removes all active peers from the network, ensuring that routing tables and statistics are cleared.</li>
     *   <li>Logs the shutdown process to aid in monitoring and debugging.</li>
     * </ul>
     * </p>
     */
    @Override
    public void close() {
        if (!running) return;
        
        log.info("Shutting down P2P network...");
        running = false;
        
        try {
            // Notify peers of shutdown
            try (serverSocket) {
                // Notify peers of shutdown
                try (networkStack) {
                    // Notify peers of shutdown
                    for (Peer peer : peers.values()) {
                        try {
                            peer.getConnection().sendMessage(VPNConnection.MSG_TYPE_PING, new byte[]{0});
                        } catch (IOException ignored) {}
                    }
                }
                // Shutdown thread pools
                scheduler.shutdown();
                executor.shutdown();
            }
            
            // Wait for thread pools to terminate
            if (!scheduler.awaitTermination(5, TimeUnit.SECONDS)) {
                scheduler.shutdownNow();
            }
            if (!executor.awaitTermination(5, TimeUnit.SECONDS)) {
                executor.shutdownNow();
            }
            
            // Clean up peers
            List<Peer> remainingPeers = new ArrayList<>(peers.values());
            for (Peer peer : remainingPeers) {
                removePeer(peer);
            }
            
            // Clear all collections
            peers.clear();
            bytesSent.clear();
            bytesReceived.clear();
            
            log.info("P2P network shutdown complete");
            
        } catch (IOException | InterruptedException e) {
            log.error("Error during shutdown: {}", e.getMessage());
            // Force shutdown of thread pools
            scheduler.shutdownNow();
            executor.shutdownNow();
        }
    }
    
    /**
     * Serializes and exports the current network state for persistence or transfer purposes.
     *
     * <p>
     * This method gathers essential network information, including node identifiers, IP addresses,
     * ports, proof of work data, known peers, and active routes. The serialized state can be used
     * to restore the network node's configuration or migrate it to a different environment.
     * </p>
     *
     * @return A {@link Map} containing key-value pairs representing the network's serialized state.
     */
    public Map<String, Object> exportState() {
        Map<String, Object> state = new HashMap<>();
        
        // Basic info
        state.put("nodeId", nodeId);
        state.put("ipAddress", ipAddress);
        state.put("port", port);
        
        // Proof of work
        state.put("proofOfWork", pow.getCurrentProof());
        state.put("proofTimestamp", pow.getTimestamp());
        
        // Known peers
        List<Map<String, Object>> peerList = new ArrayList<>();
        for (Peer peer : peers.values()) {
            Map<String, Object> peerInfo = new HashMap<>();
            peerInfo.put("address", peer.getAddress());
            peerInfo.put("port", peer.getPort());
            peerInfo.put("nodeId", peer.getNodeId());
            peerInfo.put("proofOfWork", peer.getProofOfWork());
            peerInfo.put("proofTimestamp", peer.getLastProofTimestamp());
            peerList.add(peerInfo);
        }
        state.put("peers", peerList);
        
        // Routes
        state.put("routes", router.exportState());
        
        return state;
    }
    
    /**
     * Imports and restores the network state from a serialized map.
     *
     * <p>
     * This static method reconstructs a {@link P2PNetwork} instance based on the provided serialized
     * state. It initializes network configurations, reconnects to known peers, and restores routing
     * tables to reestablish the network node's previous operational state.
     * </p>
     *
     * @param state A {@link Map} containing the serialized network state to import.
     * @return A new {@link P2PNetwork} instance initialized with the imported state.
     * @throws IOException If there is an error during the state import process.
     */
    public static P2PNetwork importState(Map<String, Object> state) throws IOException {
        int port = (Integer) state.get("port");
        String ipAddress = (String) state.get("ipAddress");
        boolean isInitiator = ipAddress.equals("10.0.0.1");
        
        P2PNetwork network = new P2PNetwork(port, isInitiator, ipAddress);
        
        // Connect to known peers
        @SuppressWarnings("unchecked")
        List<Map<String, Object>> peerList = (List<Map<String, Object>>) state.get("peers");
        for (Map<String, Object> peerInfo : peerList) {
            String address = (String) peerInfo.get("address");
            int peerPort = (Integer) peerInfo.get("port");
            try {
                network.connectToPeer(address, peerPort);
            } catch (IOException e) {
                log.warn("Failed to reconnect to peer {}:{}", address, peerPort);
            }
        }
        
        return network;
    }
    
    /**
     * Generates a comprehensive diagnostic report of the network node.
     *
     * <p>
     * This method compiles detailed information about the node's current status, including peer health,
     * network metrics, routing tables, security status, and overall network integrity. The diagnostic
     * report is formatted as a human-readable string, making it suitable for logging, monitoring, and
     * troubleshooting purposes.
     * </p>
     *
     * @return A {@link String} containing the formatted diagnostic report of the network node.
     */
    public String runDiagnostics() {
        StringBuilder report = new StringBuilder();
        report.append("P2P Network Diagnostic Report\n");
        report.append("=============================\n\n");
        
        // Basic info
        report.append(String.format("Node ID: %s\n", ByteBuffer.wrap(nodeId).toString()));
        report.append(String.format("IP Address: %s\n", ipAddress));
        report.append(String.format("Port: %d\n", port));
        report.append(String.format("Running: %s\n", running));
        report.append(String.format("Uptime: %s\n", 
            formatDuration(System.currentTimeMillis() - startTime)));
        report.append("\n");
        
        // Peer status
        report.append("Peer Status:\n");
        for (Peer peer : peers.values()) {
            report.append(String.format("  %s:%d\n", peer.getAddress(), peer.getPort()));
            report.append(String.format("    Latency: %.2f ms\n", peer.getLatency()));
            report.append(String.format("    Bandwidth: %s/s\n", 
                formatBytes(peer.getEstimatedBandwidth())));
            report.append(String.format("    Last seen: %s ago\n",
                formatDuration(System.currentTimeMillis() - peer.getLastGossip())));
            report.append(String.format("    Traffic: %s sent, %s received\n",
                formatBytes(bytesSent.getOrDefault(Arrays.toString(peer.getNodeId()), 0L)),
                formatBytes(bytesReceived.getOrDefault(Arrays.toString(peer.getNodeId()), 0L))));
            report.append("\n");
        }
        
        // Network stack status
        report.append("Network Stack Status:\n");
        report.append(String.format("  Active routes: %d\n", router.getRoutes().size()));
        report.append(String.format("  NAT mappings: %d\n", natHandler.getStats().size()));
        report.append("\n");
        
        // Proof of work status
        report.append("Security Status:\n");
        report.append(String.format("  Proof of work age: %s\n",
            formatDuration(System.currentTimeMillis() - pow.getTimestamp())));
        report.append(String.format("  Peers requiring update: %d\n",
            peers.values().stream()
                .filter(p -> p.getLastProofTimestamp() < pow.getTimestamp())
                .count()));
        report.append("\n");
        
        // Health check
        report.append("Health Check:\n");
        report.append(String.format("  Overall status: %s\n", isHealthy() ? "HEALTHY" : "UNHEALTHY"));
        report.append(String.format("  Peer count: %d/%d\n", peers.size(), MAX_PEERS));
        report.append(String.format("  Thread pools: Scheduler=%s, Executor=%s\n",
            !scheduler.isShutdown(), !executor.isShutdown()));
        
        return report.toString();
    }
    
    /**
     * Formats a duration given in milliseconds into a human-readable string.
     *
     * @param millis The duration in milliseconds.
     * @return A {@link String} representing the formatted duration.
     */
    private String formatDuration(long millis) {
        long seconds = millis / 1000;
        long minutes = seconds / 60;
        long hours = minutes / 60;
        long days = hours / 24;
        
        if (days > 0) {
            return String.format("%dd %dh", days, hours % 24);
        } else if (hours > 0) {
            return String.format("%dh %dm", hours, minutes % 60);
        } else if (minutes > 0) {
            return String.format("%dm %ds", minutes, seconds % 60);
        } else {
            return String.format("%ds", seconds);
        }
    }


    /**
     * Tests the local network connectivity by attempting to bind to the node's designated port.
     *
     * <p>
     * This method verifies whether the specified port is available and can be successfully bound,
     * ensuring that the node can listen for incoming peer connections. It is useful for diagnosing
     * network configuration issues and verifying that the node is ready to operate within the network.
     * </p>
     *
     * @return {@code true} if the port is available and the node can bind to it; {@code false} otherwise.
     */
    public boolean testConnectivity() {
        // Test if we can bind to our port
        try (ServerSocket testSocket = new ServerSocket()) {
            testSocket.setReuseAddress(true);
            testSocket.bind(new InetSocketAddress(port));
            return true;
        } catch (IOException e) {
            log.error("Port {} is not available: {}", port, e.getMessage());
            return false;
        }
    }
    
    /**
     * Provides a concise string representation of the P2P network node's current status.
     *
     * <p>
     * This method formats essential information such as the node's identifier, IP address, port,
     * active peer count, and routing table size into a single string. It is useful for logging and
     * quick status checks.
     * </p>
     *
     * @return A {@link String} summarizing the node's ID, address, port, number of peers, and routes.
     */
    @Override
    public String toString() {
        return String.format("P2PNetwork[id=%s, address=%s:%d, peers=%d, routes=%d]",
            ByteBuffer.wrap(nodeId).toString(),
            ipAddress,
            port,
            peers.size(),
            router.getRoutes().size());
    }

    
    /**
     * Processes an incoming gossip message by validating and updating network routing and peer information.
     *
     * <p>
     * This method implements the {@link GossipMessage.GossipHandler} interface, allowing the node to
     * react to gossip messages received from peers. It ensures that only valid gossip messages are
     * processed and integrates new routing information and peer data to maintain an up-to-date network state.
     * </p>
     *
     * @param message The {@link GossipMessage} received from a peer.
     */
    @Override
    public void handleGossip(GossipMessage message) {
        if (!message.isValid()) {
            log.warn("Received invalid gossip message");
            return;
        }
        handleGossipMessage(message, null); // Existing method
    }
    
    /**
     * Handles an incoming proof of work message by updating the peer's proof and timestamp.
     *
     * <p>
     * This method implements the proof handling mechanism to ensure that peers maintain valid and
     * up-to-date proofs of work. It verifies the received proof against the node's criteria and updates
     * the peer's proof information accordingly.
     * </p>
     *
     * @param proof     The byte array containing the proof of work data received from the peer.
     * @param timestamp The timestamp associated with the received proof of work.
     */
    @Override 
    public void handleProof(byte[] proof, long timestamp) {
        // Move proof handling logic here from VPNConnection
        for (Peer peer : peers.values()) {
            if (timestamp > peer.getLastProofTimestamp()) {
                peer.setProofOfWork(proof);
                peer.setLastProofTimestamp(timestamp);
            }
        }
    }
    
    /**
     * Updates the last seen timestamp for a peer based on received peer information.
     *
     * <p>
     * This method implements the peer information handling to track active peers within the network.
     * It updates the last seen timestamp to reflect recent communication, aiding in peer health assessment
     * and routing decisions.
     * </p>
     *
     * @param nodeId The node ID of the peer that sent the information.
     */
    @Override
    public void handlePeerInfo(byte[] nodeId) {
        // Find matching peer
        ByteBuffer peerId = ByteBuffer.wrap(nodeId);
        Peer peer = peers.get(peerId);
        if (peer != null) {
            peer.updateLastSeen();
        }
    }
}


=============================================

/*
 * Copyright (C) 2024 Publius Pseudis
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.publiuspseudis.esadvpn.network;

import org.publiuspseudis.esadvpn.network.IPPacket;
import org.publiuspseudis.esadvpn.core.NetworkStack;
import java.nio.ByteBuffer;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * <p>
 * The {@code UDPHandler} class manages the processing of UDP packets within the peer-to-peer (P2P) VPN network.
 * It operates in user space, handling the parsing, verification, and routing of UDP packets based on port bindings.
 * This class ensures that incoming UDP packets are correctly dispatched to the appropriate handlers and facilitates
 * the sending of UDP packets to designated destinations through the network stack.
 * </p>
 * 
 * <p>
 * <strong>Key Functionalities:</strong></p>
 * <ul>
 *   <li>Binding UDP ports to specific packet handlers, enabling customized processing of UDP traffic.</li>
 *   <li>Parsing and validating UDP packet headers, including source and destination ports, packet length, and checksum.</li>
 *   <li>Verifying the integrity of UDP packets using checksums to ensure data integrity.</li>
 *   <li>Routing incoming UDP packets to the appropriate handlers based on destination ports.</li>
 *   <li>Facilitating the sending of UDP packets to target IP addresses and ports through the network stack.</li>
 *   <li>Managing port bindings and ensuring thread-safe access to shared resources.</li>
 * </ul>
 * 
 * 
 * <p>
 * <strong>Example Usage:</strong>
 * </p>
 * <pre>{@code
 * // Initialize NetworkStack instance
 * NetworkStack networkStack = new NetworkStack();
 * 
 * // Initialize UDPHandler with the network stack
 * UDPHandler udpHandler = new UDPHandler(networkStack);
 * 
 * // Define a packet handler for a specific UDP port
 * UDPHandler.PacketHandler handler = (payload, sourceIP, sourcePort) -> {
 *     // Process the received UDP payload
 *     String message = new String(payload.array(), StandardCharsets.UTF_8);
 *     System.out.println("Received UDP message from " + sourceIP + ":" + sourcePort + " - " + message);
 * };
 * 
 * // Bind the handler to UDP port 8080
 * boolean success = udpHandler.bind(8080, handler);
 * if (success) {
 *     System.out.println("Successfully bound UDP handler to port 8080.");
 * } else {
 *     System.out.println("Failed to bind UDP handler to port 8080.");
 * }
 * 
 * // Sending a UDP packet
 * String message = "Hello, UDP!";
 * ByteBuffer payload = ByteBuffer.wrap(message.getBytes(StandardCharsets.UTF_8));
 * int sourcePort = 8080;
 * int destIP = InetAddress.getByName("192.168.1.100").hashCode(); // Example destination IP
 * int destPort = 9090;
 * udpHandler.sendPacket(sourcePort, destIP, destPort, payload);
 * }</pre>
 * 
 * <p>
 * <strong>Thread Safety:</strong>
 * </p>
 * <p>
 * The {@code UDPHandler} class is designed to be thread-safe. It utilizes concurrent data structures such as
 * {@link ConcurrentHashMap} to manage port bindings, ensuring safe access and modification in multi-threaded
 * environments. Additionally, the class handles synchronization implicitly through the use of thread-safe
 * collections, allowing multiple threads to interact with the handler without risking data inconsistencies.
 * </p>
 * 
 * <p>
 * <strong>Dependencies:</strong>
 * </p>
 * <ul>
 *   <li>{@link NetworkStack}: Facilitates the sending of IP packets, serving as the underlying network interface.</li>
 *   <li>SLF4J Logging Framework: Used for logging informational, debug, and error messages.</li>
 * </ul>
 * 
 * @author
 * Publius Pseudis
 */
public class UDPHandler {
    /**
     * Logger instance for logging informational, debug, and error messages.
     */
    private static final Logger log = LoggerFactory.getLogger(UDPHandler.class);
    
    // UDP header offsets
    /**
     * Offset for the source port field in the UDP header.
     */
    private static final int SRC_PORT_OFFSET = 0;
    
    /**
     * Offset for the destination port field in the UDP header.
     */
    private static final int DST_PORT_OFFSET = 2;
    
    /**
     * Offset for the length field in the UDP header.
     */
    private static final int LENGTH_OFFSET = 4;
    
    /**
     * Offset for the checksum field in the UDP header.
     */
    private static final int CHECKSUM_OFFSET = 6;
    
    /**
     * Total size of the UDP header in bytes.
     */
    private static final int UDP_HEADER_SIZE = 8;
    
    /**
     * Reference to the {@link NetworkStack} instance used for sending UDP packets.
     */
    private final NetworkStack networkStack;
    
    /**
     * A thread-safe map that maintains bindings between UDP ports and their corresponding handlers.
     * The key is the UDP port number, and the value is the associated {@link PortBinding}.
     */
    private final Map<Integer, PortBinding> portBindings;
    
    /**
     * Constructs a new {@code UDPHandler} with the specified network stack.
     *
     * @param networkStack The {@link NetworkStack} instance used for sending UDP packets.
     */
    public UDPHandler(NetworkStack networkStack) {
        this.networkStack = networkStack;
        this.portBindings = new ConcurrentHashMap<>();
    }
    
    /**
     * Represents a binding between a UDP port and its associated packet handler.
     */
    private static class PortBinding {
        /**
         * The UDP port number to which this binding applies.
         */
        final int port;
        
        /**
         * The handler responsible for processing incoming UDP packets on the bound port.
         */
        final PacketHandler handler;
        
        /**
         * Constructs a new {@code PortBinding} with the specified port and handler.
         *
         * @param port    The UDP port number.
         * @param handler The {@link PacketHandler} responsible for processing packets on this port.
         */
        PortBinding(int port, PacketHandler handler) {
            this.port = port;
            this.handler = handler;
        }
    }
    
    /**
     * <p>
     * The {@code PacketHandler} interface defines the contract for handling incoming UDP packets.
     * Implementations of this interface process the payload of UDP packets received on bound ports.
     * </p>
     * 
     * <p>
     * <strong>Example Implementation:</strong>
     * </p>
     * <pre>{@code
     * UDPHandler.PacketHandler handler = (payload, sourceIP, sourcePort) -> {
     *     // Convert payload to string and print
     *     String message = new String(payload.array(), StandardCharsets.UTF_8);
     *     System.out.println("Received from " + sourceIP + ":" + sourcePort + " - " + message);
     * };
     * }</pre>
     */
    public interface PacketHandler {
        /**
         * Handles an incoming UDP packet's payload.
         *
         * @param payload     A {@code ByteBuffer} containing the UDP packet's payload data.
         * @param sourceIP    An {@code int} representing the source IP address of the packet.
         * @param sourcePort  An {@code int} representing the source port number of the packet.
         */
        void handlePacket(ByteBuffer payload, int sourceIP, int sourcePort);
    }
    
    /**
     * Binds a {@link PacketHandler} to a specific UDP port. Once bound, incoming UDP packets on the
     * specified port will be dispatched to the provided handler.
     *
     * @param port     The UDP port number to bind the handler to. Must be in the range 0-65535.
     * @param handler  The {@link PacketHandler} instance responsible for processing packets on this port.
     * @return {@code true} if the binding was successful; {@code false} if the port is already bound.
     * @throws IllegalArgumentException If the specified port number is outside the valid range (0-65535).
     */
    public boolean bind(int port, PacketHandler handler) {
        if (port < 0 || port > 65535) {
            throw new IllegalArgumentException("Invalid port: " + port);
        }
        
        if (portBindings.containsKey(port)) {
            log.warn("Attempted to bind to already bound port {}", port);
            return false;
        }
        
        portBindings.put(port, new PortBinding(port, handler));
        log.debug("Bound UDP handler to port {}", port);
        return true;
    }
    
    /**
     * Unbinds a {@link PacketHandler} from a specific UDP port. After unbinding, incoming UDP packets
     * on the specified port will no longer be dispatched to the handler.
     *
     * @param port The UDP port number to unbind the handler from.
     */
    public void unbind(int port) {
        if (portBindings.remove(port) != null) {
            log.debug("Unbound UDP handler from port {}", port);
        } else {
            log.warn("Attempted to unbind from non-bound port {}", port);
        }
    }
    
    /**
     * Handles an incoming UDP packet by parsing its header, validating its integrity, and dispatching
     * it to the appropriate {@link PacketHandler} based on the destination port.
     *
     * @param ipPacket The {@link IPPacket} representing the received UDP packet.
     */
    public void handlePacket(IPPacket ipPacket) {
        ByteBuffer udpData = ipPacket.getPayload();
        if (udpData.remaining() < UDP_HEADER_SIZE) {
            log.warn("UDP packet too small from {}", IPPacket.formatIP(ipPacket.getSourceIP()));
            return;
        }
        
        // Parse UDP header
        int sourcePort = udpData.getShort(SRC_PORT_OFFSET) & 0xFFFF;
        int destPort = udpData.getShort(DST_PORT_OFFSET) & 0xFFFF;
        int length = udpData.getShort(LENGTH_OFFSET) & 0xFFFF;
        
        // Basic validation
        if (length != udpData.remaining()) {
            log.warn("Invalid UDP length from {}:{}", 
                IPPacket.formatIP(ipPacket.getSourceIP()), sourcePort);
            return;
        }
        
        // Verify checksum if present
        int checksum = udpData.getShort(CHECKSUM_OFFSET) & 0xFFFF;
        if (checksum != 0 && !verifyChecksum(ipPacket)) {
            log.warn("Invalid UDP checksum from {}:{}", 
                IPPacket.formatIP(ipPacket.getSourceIP()), sourcePort);
            return;
        }
        
        // Find port binding
        PortBinding binding = portBindings.get(destPort);
        if (binding != null) {
            // Extract payload
            ByteBuffer payload = udpData.duplicate();
            payload.position(UDP_HEADER_SIZE);
            payload = payload.slice();
            
            // Handle packet
            binding.handler.handlePacket(payload, ipPacket.getSourceIP(), sourcePort);
        } else {
            log.debug("No handler for UDP port {} from {}:{}", 
                destPort, IPPacket.formatIP(ipPacket.getSourceIP()), sourcePort);
        }
    }
    
    /**
     * Sends a UDP packet to a specified destination IP and port. This method constructs the UDP header,
     * appends the payload, and dispatches the packet through the network stack.
     *
     * @param sourcePort The source UDP port number from which the packet is sent.
     * @param destIP     An {@code int} representing the destination IP address.
     * @param destPort   The destination UDP port number to which the packet is sent.
     * @param payload    A {@code ByteBuffer} containing the payload data to be sent.
     */
    public void sendPacket(int sourcePort, int destIP, int destPort, ByteBuffer payload) {
        // Create UDP header
        ByteBuffer udpPacket = ByteBuffer.allocate(UDP_HEADER_SIZE + payload.remaining());
        
        // Source port
        udpPacket.putShort((short) sourcePort);
        
        // Destination port
        udpPacket.putShort((short) destPort);
        
        // Length
        udpPacket.putShort((short) (UDP_HEADER_SIZE + payload.remaining()));
        
        // Checksum (initially 0; checksum calculation can be added if needed)
        udpPacket.putShort((short) 0);
        
        // Payload
        udpPacket.put(payload.duplicate());
        udpPacket.flip();
        
        // Create IP packet and send through network stack
        networkStack.sendPacket(IPPacket.PROTO_UDP, destIP, udpPacket);
        log.debug("Sent UDP packet from port {} to {}:{} with {} bytes of payload", 
            sourcePort, IPPacket.formatIP(destIP), destPort, payload.remaining());
    }
    
    /**
     * Verifies the integrity of a received UDP packet by recalculating its checksum and comparing it
     * to the checksum provided in the packet header.
     *
     * @param packet The {@link IPPacket} representing the received UDP packet.
     * @return {@code true} if the checksum is valid or not present; {@code false} otherwise.
     */
    private boolean verifyChecksum(IPPacket packet) {
        // UDP checksum includes pseudo-header
        ByteBuffer udpData = packet.getPayload();
        int originalChecksum = udpData.getShort(CHECKSUM_OFFSET) & 0xFFFF;
        
        // If checksum is 0, it wasn't calculated (optional in IPv4)
        if (originalChecksum == 0) {
            return true;
        }
        
        // Calculate checksum including pseudo-header
        ByteBuffer extended = ByteBuffer.allocate(udpData.remaining() + 12);
        
        // Pseudo-header
        extended.putInt(packet.getSourceIP());
        extended.putInt(packet.getDestinationIP());
        extended.put((byte) 0);
        extended.put((byte) packet.getProtocol());
        extended.putShort((short) udpData.remaining());
        
        // UDP data with checksum field set to 0
        udpData = udpData.duplicate();
        udpData.putShort(CHECKSUM_OFFSET, (short) 0);
        extended.put(udpData);
        extended.flip();
        
        // Calculate checksum
        int sum = 0;
        while (extended.hasRemaining()) {
            if (extended.remaining() >= 2) {
                sum += extended.getShort() & 0xFFFF;
            } else {
                sum += (extended.get() & 0xFF) << 8;
            }
        }
        
        // Add carry bits
        sum = (sum >> 16) + (sum & 0xFFFF);
        sum += (sum >> 16);
        
        return (short) ~sum == originalChecksum;
    }
}

=============================================

/*
 * Copyright (C) 2024 Publius Pseudis
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.publiuspseudis.esadvpn.network;

import org.publiuspseudis.esadvpn.core.VPNConnection;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * <p>
 * The {@code Peer} class represents a peer within the peer-to-peer (P2P) VPN network.
 * It encapsulates the peer's network address, identity, proof of work, and various routing metrics
 * such as latency and bandwidth. The class also manages the connection to the peer and tracks
 * data transfer statistics.
 * </p>
 * 
 * <p>
 * <strong>Key Functionalities:</strong></p>
 * <ul>
 *   <li>Maintaining connection details with the peer.</li>
 *   <li>Tracking and updating data transfer statistics (bytes sent and received).</li>
 *   <li>Measuring and updating latency and bandwidth estimates.</li>
 *   <li>Determining the staleness of the peer based on activity.</li>
 *   <li>Calculating and updating routing scores based on network metrics.</li>
 * </ul>
 * 
 * 
 * <p>
 * <strong>Example Usage:</strong>
 * </p>
 * <pre>{@code
 * // Create a new peer instance
 * String peerAddress = "192.168.1.100";
 * int peerPort = 8081;
 * byte[] peerNodeId = new byte[32]; // Assume this is initialized appropriately
 * Peer peer = new Peer(peerAddress, peerPort, peerNodeId);
 * 
 * // Set proof of work details
 * byte[] proof = ...; // Obtain proof of work bytes
 * long proofTimestamp = System.currentTimeMillis();
 * peer.setProofOfWork(proof);
 * peer.setLastProofTimestamp(proofTimestamp);
 * 
 * // Update metrics based on network activity
 * peer.recordBytesSent(1024);
 * peer.recordBytesReceived(2048);
 * peer.updateLatency(50.5); // Latency in milliseconds
 * 
 * // Check if the peer is stale
 * if (peer.isStale()) {
 *     // Handle stale peer
 * }
 * }</pre>
 * 
 * <p>
 * <strong>Thread Safety:</strong>
 * </p>
 * <p>
 * The {@code Peer} class utilizes atomic operations and volatile variables to ensure thread-safe
 * updates to metrics such as bytes sent/received, latency, and bandwidth. This design allows
 * concurrent access and modification of peer metrics without risking data inconsistencies.
 * </p>
 * 
 * <p>
 * <strong>Dependencies:</strong>
 * </p>
 * <ul>
 *   <li>{@link VPNConnection}: Manages the VPN connection to the peer.</li>
 *   <li>SLF4J Logging Framework: Used for logging events and debugging.</li>
 * </ul>
 * 
 * @author
 * Publius Pseudis
 */
public class Peer {
    /**
     * Logger instance for logging information, warnings, and errors.
     */
    private static final Logger log = LoggerFactory.getLogger(Peer.class);
    
    /**
     * The IP address of the peer.
     */
    private final String address;
    
    /**
     * The port number on which the peer is listening.
     */
    private final int port;
    
    /**
     * The unique node ID of the peer.
     */
    private final byte[] nodeId;
    
    /**
     * The proof of work associated with the peer.
     */
    private byte[] proofOfWork;
    
    /**
     * The timestamp when the peer last provided a proof of work.
     */
    private long lastProofTimestamp;
    
    /**
     * The timestamp of the last gossip message received from the peer.
     */
    private volatile long lastGossip;
    
    /**
     * The {@link VPNConnection} instance managing the connection to the peer.
     */
    private VPNConnection connection;
    
    // Routing and metrics
    
    /**
     * The score representing the quality of the route through this peer.
     * Higher scores indicate better routes.
     */
    private volatile double routeScore;
    
    /**
     * The total number of bytes sent to the peer.
     */
    private final AtomicLong bytesSent;
    
    /**
     * The total number of bytes received from the peer.
     */
    private final AtomicLong bytesReceived;
    
    /**
     * The current latency measured to the peer in milliseconds.
     */
    private volatile double latency;
    
    /**
     * The timestamp of the last latency update.
     */
    private volatile long lastLatencyUpdate;
    
    /**
     * The estimated bandwidth to the peer in bytes per second.
     */
    private volatile long estimatedBandwidth;
    
    /**
     * The timestamp of the last bandwidth calculation.
     */
    private volatile long lastBandwidthCalculation;
    
    // Timeouts and thresholds
    
    /**
     * The duration after which a peer is considered stale if no activity is detected.
     */
    private static final long STALE_THRESHOLD = TimeUnit.SECONDS.toMillis(30);
    
    /**
     * The interval at which bandwidth estimates are recalculated.
     */
    private static final long BANDWIDTH_CALC_INTERVAL = TimeUnit.SECONDS.toMillis(5);
    
    /**
     * The interval at which latency measurements are updated.
     */
    private static final long LATENCY_UPDATE_INTERVAL = TimeUnit.SECONDS.toMillis(10);
    
    /**
     * The timestamp of the last time the peer was seen.
     */
    private volatile long lastSeen;

    /**
     * Creates a new peer with the specified network address and identity.
     *
     * @param address The IP address of the peer.
     * @param port    The port number on which the peer is listening.
     * @param nodeId  The unique node ID of the peer.
     */
    public Peer(String address, int port, byte[] nodeId) {
        this.address = address;
        this.port = port;
        this.nodeId = nodeId;
        this.lastGossip = System.currentTimeMillis();
        this.lastSeen = System.currentTimeMillis();
        
        // Initialize metrics
        this.routeScore = 0.0;
        this.bytesSent = new AtomicLong(0);
        this.bytesReceived = new AtomicLong(0);
        this.latency = Double.MAX_VALUE;
        this.lastLatencyUpdate = 0;
        this.estimatedBandwidth = 0;
        this.lastBandwidthCalculation = System.currentTimeMillis();
    }

    /**
     * Updates the last seen timestamp to mark the peer as active.
     */
    public void updateLastSeen() {
        this.lastSeen = System.currentTimeMillis();
    }
    
    /**
     * Determines whether the peer connection is considered stale based on inactivity.
     *
     * @return {@code true} if the peer is stale; {@code false} otherwise.
     */
    public boolean isStale() {
        return System.currentTimeMillis() - lastSeen > STALE_THRESHOLD;
    }

    /**
     * Records the number of bytes sent to this peer and updates the bandwidth estimate.
     *
     * @param bytes The number of bytes sent.
     */
    public void recordBytesSent(long bytes) {
        bytesSent.addAndGet(bytes);
        updateBandwidthEstimate();
    }

    /**
     * Records the number of bytes received from this peer and updates the bandwidth estimate.
     *
     * @param bytes The number of bytes received.
     */
    public void recordBytesReceived(long bytes) {
        bytesReceived.addAndGet(bytes);
        updateBandwidthEstimate();
    }

    /**
     * Updates the latency measurement for this peer using an exponential moving average.
     * Only updates if the designated interval has passed since the last update.
     *
     * @param newLatency The newly measured latency in milliseconds.
     */
    public void updateLatency(double newLatency) {
        long now = System.currentTimeMillis();
        if (now - lastLatencyUpdate >= LATENCY_UPDATE_INTERVAL) {
            // Use exponential moving average for latency
            if (this.latency == Double.MAX_VALUE) {
                this.latency = newLatency;
            } else {
                this.latency = (this.latency * 0.7) + (newLatency * 0.3);
            }
            this.lastLatencyUpdate = now;
            updateRouteScore(); // Recalculate route score with new latency
        }
    }

    /**
     * Updates the bandwidth estimate based on recent traffic. Uses an exponential moving average
     * to smooth out fluctuations in bandwidth measurements.
     */
    private void updateBandwidthEstimate() {
        long now = System.currentTimeMillis();
        long interval = now - lastBandwidthCalculation;
        
        if (interval >= BANDWIDTH_CALC_INTERVAL) {
            long totalBytes = bytesSent.get() + bytesReceived.get();
            long bytesPerSecond = (totalBytes * 1000) / interval;
            
            // Update bandwidth estimate with some smoothing
            if (estimatedBandwidth == 0) {
                estimatedBandwidth = bytesPerSecond;
            } else {
                estimatedBandwidth = (estimatedBandwidth * 7 + bytesPerSecond * 3) / 10;
            }
            
            // Reset counters
            bytesSent.set(0);
            bytesReceived.set(0);
            lastBandwidthCalculation = now;
            
            updateRouteScore(); // Recalculate route score with new bandwidth
        }
    }

    /**
     * Updates the overall route score based on current latency and bandwidth metrics.
     * Combines normalized latency and bandwidth scores with equal weighting.
     */
    private void updateRouteScore() {
        // Normalize metrics to 0-1 range
        double latencyScore = 1.0 / (1 + this.latency);
        double bandwidthScore = Math.log1p(this.estimatedBandwidth) / 10.0;
        
        // Calculate weighted score
        this.routeScore = (latencyScore * 0.5) + (bandwidthScore * 0.5);
        
        log.debug("Updated route score for peer {}: score={}, latency={}, bandwidth={}", 
            address, routeScore, latency, estimatedBandwidth);
    }

    // Getters and setters

    /**
     * Retrieves the IP address of the peer.
     *
     * @return The IP address as a {@link String}.
     */
    public String getAddress() { return address; }

    /**
     * Retrieves the port number of the peer.
     *
     * @return The port number as an {@code int}.
     */
    public int getPort() { return port; }

    /**
     * Retrieves the node ID of the peer.
     *
     * @return The node ID as a byte array.
     */
    public byte[] getNodeId() { return nodeId; }

    /**
     * Retrieves the proof of work associated with the peer.
     *
     * @return The proof of work as a byte array.
     */
    public byte[] getProofOfWork() { return proofOfWork; }

    /**
     * Sets the proof of work for the peer.
     *
     * @param pow The proof of work as a byte array.
     */
    public void setProofOfWork(byte[] pow) { this.proofOfWork = pow; }

    /**
     * Retrieves the timestamp of the last proof of work provided by the peer.
     *
     * @return The timestamp in milliseconds since the epoch.
     */
    public long getLastProofTimestamp() { return lastProofTimestamp; }

    /**
     * Sets the timestamp of the last proof of work provided by the peer.
     *
     * @param timestamp The timestamp in milliseconds since the epoch.
     */
    public void setLastProofTimestamp(long timestamp) { this.lastProofTimestamp = timestamp; }

    /**
     * Updates the timestamp of the last gossip message received from the peer.
     */
    public void updateLastGossip() { this.lastGossip = System.currentTimeMillis(); }

    /**
     * Retrieves the timestamp of the last gossip message received from the peer.
     *
     * @return The timestamp in milliseconds since the epoch.
     */
    public long getLastGossip() { return lastGossip; }

    /**
     * Retrieves the VPN connection instance associated with this peer.
     *
     * @return The {@link VPNConnection} instance.
     */
    public VPNConnection getConnection() { return connection; }

    /**
     * Sets the VPN connection instance for this peer.
     *
     * @param conn The {@link VPNConnection} instance to be associated with the peer.
     */
    public void setConnection(VPNConnection conn) { this.connection = conn; }

    /**
     * Retrieves the current route score for this peer.
     *
     * @return The route score as a {@code double}.
     */
    public double getRouteScore() { return routeScore; }

    /**
     * Sets the route score for this peer.
     *
     * @param score The route score as a {@code double}.
     */
    public void setRouteScore(double score) { this.routeScore = score; }

    /**
     * Retrieves the current latency measurement to the peer.
     *
     * @return The latency in milliseconds as a {@code double}.
     */
    public double getLatency() { return latency; }

    /**
     * Retrieves the estimated bandwidth to the peer.
     *
     * @return The estimated bandwidth in bytes per second as a {@code long}.
     */
    public long getEstimatedBandwidth() { return estimatedBandwidth; }

    /**
     * Provides a string representation of the peer, including address, port, route score,
     * latency, and bandwidth.
     *
     * @return A formatted {@link String} representing the peer.
     */
    @Override
    public String toString() {
        return String.format("Peer[address=%s, port=%d, score=%.3f, latency=%.2fms, bandwidth=%d B/s]",
            address, port, routeScore, latency, estimatedBandwidth);
    }
}

=============================================

/*
 * Copyright (C) 2024 Publius Pseudis
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.publiuspseudis.esadvpn.network;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.TimeUnit;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * <p>
 * The {@code NATHandler} class manages Network Address Translation (NAT) for VPN traffic within the VPN framework.
 * It handles the translation of internal (private) IP addresses and ports to external (public) ones,
 * facilitating seamless communication between VPN peers and external networks.
 * </p>
 *
 * <p>
 * This class maintains NAT mapping tables for both TCP and UDP protocols, ensuring that incoming and outgoing
 * packets are correctly translated and routed. It also manages dynamic port allocation, connection tracking
 * for TCP sessions, and cleanup of expired NAT mappings to optimize resource usage.
 * </p>
 *
 * <p>
 * <strong>Key Functionalities:</strong></p>
 * <ul>
 *   <li>Managing NAT mappings for TCP and UDP protocols.</li>
 *   <li>Allocating dynamic ports within a specified range.</li>
 *   <li>Tracking active TCP connections.</li>
 *   <li>Handling packet translation for both outgoing and incoming packets.</li>
 *   <li>Cleaning up expired NAT mappings based on predefined timeouts.</li>
 *   <li>Providing NAT statistics for monitoring purposes.</li>
 * </ul>
 * 
 * 
 * <p>
 * <strong>Example Usage:</strong>
 * </p>
 * <pre>{@code
 * // Initialize NATHandler
 * NATHandler natHandler = new NATHandler();
 * 
 * // Process an outgoing TCP packet
 * byte[] outgoingPacket = {/* TCP packet data *};
 * String srcSubnet = "192.168.1.";
 * byte[] translatedOutgoingPacket = natHandler.processOutgoingPacket(outgoingPacket, srcSubnet);
 * 
 * // Process an incoming UDP packet
 * byte[] incomingPacket = {/* UDP packet data *};
 * byte[] translatedIncomingPacket = natHandler.processIncomingPacket(incomingPacket);
 * 
 * // Periodically clean up expired mappings
 * natHandler.cleanupExpiredMappings();
 * 
 * // Retrieve NAT statistics
 * Map<String, Object> stats = natHandler.getStats();
 * System.out.println("NAT Statistics: " + stats);
 * }</pre>
 * 
 * <p>
 * <strong>Thread Safety:</strong>  
 * The {@code NATHandler} class is designed to be thread-safe, utilizing concurrent data structures like
 * {@code ConcurrentHashMap} and atomic variables to manage NAT mappings and port allocations. This ensures
 * safe concurrent access in multi-threaded environments.
 * </p>
 * 
 * <p>
 * <strong>Dependencies:</strong>
 * </p>
 * <ul>
 *   <li>SLF4J Logging Framework for logging events and debugging.</li>
 * </ul>
 * 
 * @author
 * Publius Pseudis
 * 
 * @version 1.0
 * @since 2024-01-01
 */
public class NATHandler {
    /**
     * Logger instance for logging information, warnings, and errors.
     */
    private static final Logger log = LoggerFactory.getLogger(NATHandler.class);
    
    /**
     * Mapping of external (public) ports to their corresponding NAT mappings.
     * Utilizes {@code ConcurrentHashMap} for thread-safe operations.
     */
    private final Map<Integer, NATMapping> portMappings = new ConcurrentHashMap<>();
    
    /**
     * Mapping of connection keys to their assigned external ports.
     * Utilizes {@code ConcurrentHashMap} for thread-safe operations.
     */
    private final Map<String, Integer> addressMappings = new ConcurrentHashMap<>();
    
    /**
     * Atomic integer to keep track of the next available dynamic port for NAT mapping.
     */
    private final AtomicInteger nextPort = new AtomicInteger(10000);
    
    /**
     * Timeout duration for UDP NAT mappings in milliseconds.
     * {@code 2} minutes by default.
     */
    private static final long UDP_TIMEOUT = TimeUnit.MINUTES.toMillis(2);
    
    /**
     * Timeout duration for TCP NAT mappings in milliseconds.
     * {@code 15} minutes by default.
     */
    private static final long TCP_TIMEOUT = TimeUnit.MINUTES.toMillis(15);
    
    /**
     * Minimum dynamic port number for NAT mappings.
     */
    private static final int MIN_DYNAMIC_PORT = 10000;
    
    /**
     * Maximum dynamic port number for NAT mappings.
     */
    private static final int MAX_DYNAMIC_PORT = 60000;
    
    /**
     * <p>
     * The {@code NATMapping} class represents a single NAT mapping entry.
     * It stores information about the original and translated IP addresses and ports,
     * the protocol used, timestamps for creation and last usage, and connection state
     * for TCP protocols.
     * </p>
     */
    public static class NATMapping {
        /**
         * Original source IP address before NAT translation.
         */
        public final String originalSrcIP;
        
        /**
         * Original source port before NAT translation.
         */
        public final int originalSrcPort;
        
        /**
         * Original destination IP address before NAT translation.
         */
        public final String originalDstIP;
        
        /**
         * Original destination port before NAT translation.
         */
        public final int originalDstPort;
        
        /**
         * Protocol number (6 for TCP, 17 for UDP).
         */
        public final int protocol;          // 6 for TCP, 17 for UDP
        
        /**
         * Timestamp indicating when the NAT mapping was created.
         */
        public final long creationTime;
        
        /**
         * Timestamp indicating the last time the NAT mapping was used.
         */
        public long lastUsed;
        
        /**
         * Flag indicating whether a TCP connection has been established.
         */
        public boolean tcpEstablished;     // For TCP connection tracking
        
        /**
         * Constructs a new {@code NATMapping} instance with the specified parameters.
         *
         * @param srcIP     The original source IP address.
         * @param srcPort   The original source port.
         * @param dstIP     The original destination IP address.
         * @param dstPort   The original destination port.
         * @param protocol  The protocol number (6 for TCP, 17 for UDP).
         */
        public NATMapping(String srcIP, int srcPort, String dstIP, int dstPort, int protocol) {
            this.originalSrcIP = srcIP;
            this.originalSrcPort = srcPort;
            this.originalDstIP = dstIP;
            this.originalDstPort = dstPort;
            this.protocol = protocol;
            this.creationTime = System.currentTimeMillis();
            this.lastUsed = this.creationTime;
            this.tcpEstablished = false;
        }
    }
    
    /**
     * Processes an outgoing packet for NAT translation.
     *
     * <p>
     * This method translates the source IP address and port of outgoing packets from the
     * internal subnet to externally visible ones. It handles both TCP and UDP protocols,
     * ensuring that the necessary NAT mappings are created or reused. For TCP packets, it
     * also tracks the connection state based on TCP flags.
     * </p>
     *
     * @param packet    The raw outgoing packet data as a byte array.
     * @param srcSubnet The source subnet (e.g., "192.168.1.") to identify internal packets.
     * @return The translated packet as a byte array, or the original packet if no translation is performed.
     */
    public byte[] processOutgoingPacket(byte[] packet, String srcSubnet) {
        if (packet.length < 20) return packet; // Too small for IP header
        
        int protocol = packet[9] & 0xFF;
        if (protocol != 6 && protocol != 17) { // Not TCP/UDP
            return packet;
        }
        
        String srcIP = extractIP(packet, 12);
        String dstIP = extractIP(packet, 16);
        int srcPort = extractPort(packet, 20);
        int dstPort = extractPort(packet, 22);
        
        // Skip if source is not from our managed subnet
        if (!srcIP.startsWith(srcSubnet)) {
            return packet;
        }
        
        // Create or get NAT mapping
        String connectionKey = String.format("%s:%d-%s:%d/%d", 
            srcIP, srcPort, dstIP, dstPort, protocol);
        
        int mappedPort = addressMappings.computeIfAbsent(connectionKey, k -> {
            int port = createPortMapping(srcIP, srcPort, dstIP, dstPort, protocol);
            log.debug("Created new NAT mapping: {} -> :{}", connectionKey, port);
            return port;
        });
        
        // Update last used timestamp
        NATMapping mapping = portMappings.get(mappedPort);
        if (mapping != null) {
            mapping.lastUsed = System.currentTimeMillis();
            
            // Track TCP connection state
            if (protocol == 6) { // TCP
                int tcpFlags = packet[33] & 0xFF;
                boolean isSYN = (tcpFlags & 0x02) != 0;
                boolean isFIN = (tcpFlags & 0x01) != 0;
                boolean isRST = (tcpFlags & 0x04) != 0;
                
                if (isSYN && !mapping.tcpEstablished) {
                    mapping.tcpEstablished = true;
                } else if ((isFIN || isRST) && mapping.tcpEstablished) {
                    mapping.tcpEstablished = false;
                }
            }
        }
        
        // Create modified packet with NAT translation
        byte[] modifiedPacket = packet.clone();
        
        // Update source port
        modifiedPacket[20] = (byte) ((mappedPort >> 8) & 0xFF);
        modifiedPacket[21] = (byte) (mappedPort & 0xFF);
        
        // Recalculate checksums
        updateChecksums(modifiedPacket);
        
        return modifiedPacket;
    }
    
    /**
     * Processes an incoming packet for NAT translation.
     *
     * <p>
     * This method translates the destination IP address and port of incoming packets from
     * externally visible ones back to their original internal addresses and ports. It handles
     * both TCP and UDP protocols, ensuring that the NAT mappings are correctly applied.
     * For TCP packets, it also updates the connection state based on TCP flags.
     * </p>
     *
     * @param packet The raw incoming packet data as a byte array.
     * @return The translated packet as a byte array, or {@code null} if no valid NAT mapping is found.
     */
    public byte[] processIncomingPacket(byte[] packet) {
        if (packet.length < 20) return null;
        
        int protocol = packet[9] & 0xFF;
        if (protocol != 6 && protocol != 17) {
            return packet;
        }
        
        int dstPort = extractPort(packet, 22);
        NATMapping mapping = portMappings.get(dstPort);
        
        if (mapping == null) {
            return null; // No NAT mapping found
        }
        
        // Update last used timestamp
        mapping.lastUsed = System.currentTimeMillis();
        
        // Create modified packet with original addresses
        byte[] modifiedPacket = packet.clone();
        
        // Restore original destination IP and port
        writeIP(modifiedPacket, 16, mapping.originalSrcIP);
        writePort(modifiedPacket, 22, mapping.originalSrcPort);
        
        // Handle TCP connection tracking
        if (protocol == 6) {
            int tcpFlags = packet[33] & 0xFF;
            boolean isFIN = (tcpFlags & 0x01) != 0;
            boolean isRST = (tcpFlags & 0x04) != 0;
            
            if ((isFIN || isRST) && mapping.tcpEstablished) {
                mapping.tcpEstablished = false;
            }
        }
        
        // Recalculate checksums
        updateChecksums(modifiedPacket);
        
        return modifiedPacket;
    }
    
    /**
     * Creates a new NAT mapping for a given connection.
     *
     * <p>
     * This method attempts to reuse an existing NAT mapping if one exists for the specified
     * connection. If no such mapping exists, it allocates a new external port and creates a
     * new {@code NATMapping} entry.
     * </p>
     *
     * @param srcIP     The original source IP address.
     * @param srcPort   The original source port.
     * @param dstIP     The original destination IP address.
     * @param dstPort   The original destination port.
     * @param protocol  The protocol number (6 for TCP, 17 for UDP).
     * @return The allocated external port number for NAT mapping.
     */
    private int createPortMapping(String srcIP, int srcPort, String dstIP, int dstPort, int protocol) {
        // Try to reuse existing mapping if possible
        for (Map.Entry<Integer, NATMapping> entry : portMappings.entrySet()) {
            NATMapping mapping = entry.getValue();
            if (mapping.originalSrcIP.equals(srcIP) && 
                mapping.originalSrcPort == srcPort &&
                mapping.originalDstIP.equals(dstIP) &&
                mapping.originalDstPort == dstPort &&
                mapping.protocol == protocol) {
                return entry.getKey();
            }
        }
        
        // Create new mapping
        int mappedPort = allocatePort();
        portMappings.put(mappedPort, new NATMapping(srcIP, srcPort, dstIP, dstPort, protocol));
        return mappedPort;
    }
    
    /**
     * Allocates a new external port for NAT mapping within the dynamic port range.
     *
     * <p>
     * This method increments the {@code nextPort} atomic integer to obtain the next available
     * port. If the port exceeds the maximum dynamic port, it wraps around to the minimum dynamic port.
     * It ensures that the allocated port is not already in use within the {@code portMappings}.
     * </p>
     *
     * @return An available external port number for NAT mapping.
     */
    private int allocatePort() {
        while (true) {
            int port = nextPort.incrementAndGet();
            if (port > MAX_DYNAMIC_PORT) {
                nextPort.set(MIN_DYNAMIC_PORT);
                port = nextPort.incrementAndGet();
            }
            if (!portMappings.containsKey(port)) {
                return port;
            }
        }
    }
    
    /**
     * Cleans up expired NAT mappings based on predefined timeout durations.
     *
     * <p>
     * This method iterates through the existing NAT mappings and removes those that have
     * not been used within their respective timeout periods. For UDP mappings, the timeout
     * is {@code UDP_TIMEOUT}, and for TCP mappings, it is {@code TCP_TIMEOUT}. Additionally,
     * TCP mappings with established connections are not expired.
     * </p>
     */
    public void cleanupExpiredMappings() {
        long now = System.currentTimeMillis();
        
        portMappings.entrySet().removeIf(entry -> {
            NATMapping mapping = entry.getValue();
            long timeout = mapping.protocol == 17 ? UDP_TIMEOUT : TCP_TIMEOUT;
            
            boolean expired = now - mapping.lastUsed > timeout;
            
            // For TCP, also check connection state
            if (mapping.protocol == 6 && mapping.tcpEstablished) {
                expired = false; // Don't expire established TCP connections
            }
            
            if (expired) {
                String key = String.format("%s:%d-%s:%d/%d",
                    mapping.originalSrcIP, mapping.originalSrcPort,
                    mapping.originalDstIP, mapping.originalDstPort,
                    mapping.protocol);
                addressMappings.remove(key);
                
                log.debug("Removed expired NAT mapping: {} -> :{}", 
                    key, entry.getKey());
            }
            
            return expired;
        });
    }
    
    /**
     * Extracts an IP address from the packet data starting at the specified offset.
     *
     * @param packet The raw packet data as a byte array.
     * @param offset The byte offset where the IP address starts.
     * @return A {@code String} representing the extracted IP address in dotted-decimal notation.
     */
    private String extractIP(byte[] packet, int offset) {
        return String.format("%d.%d.%d.%d",
            packet[offset] & 0xFF,
            packet[offset + 1] & 0xFF,
            packet[offset + 2] & 0xFF,
            packet[offset + 3] & 0xFF);
    }
    
    /**
     * Extracts a port number from the packet data starting at the specified offset.
     *
     * @param packet The raw packet data as a byte array.
     * @param offset The byte offset where the port number starts.
     * @return An integer representing the extracted port number.
     */
    private int extractPort(byte[] packet, int offset) {
        return ((packet[offset] & 0xFF) << 8) | (packet[offset + 1] & 0xFF);
    }
    
    /**
     * Writes an IP address into the packet data at the specified offset.
     *
     * @param packet The raw packet data as a byte array.
     * @param offset The byte offset where the IP address should be written.
     * @param ip     The IP address as a {@code String} in dotted-decimal notation.
     */
    private void writeIP(byte[] packet, int offset, String ip) {
        String[] parts = ip.split("\\.");
        for (int i = 0; i < 4; i++) {
            packet[offset + i] = (byte) Integer.parseInt(parts[i]);
        }
    }
    
    /**
     * Writes a port number into the packet data at the specified offset.
     *
     * @param packet The raw packet data as a byte array.
     * @param offset The byte offset where the port number should be written.
     * @param port   The port number to write.
     */
    private void writePort(byte[] packet, int offset, int port) {
        packet[offset] = (byte) ((port >> 8) & 0xFF);
        packet[offset + 1] = (byte) (port & 0xFF);
    }
    
    /**
     * Updates the checksums of the modified packet to ensure data integrity.
     *
     * <p>
     * This method recalculates the IP header checksum after any modifications to the packet.
     * It sets the checksum field to zero, calculates the new checksum by summing all 16-bit words,
     * adding any carry-over bits, and then taking the one's complement of the sum. The calculated
     * checksum is then written back into the packet.
     * </p>
     *
     * @param packet The modified packet data as a byte array.
     */
    private void updateChecksums(byte[] packet) {
        // Clear existing checksums
        packet[10] = packet[11] = 0; // IP header checksum
        
        // Calculate IP header checksum
        int ipLength = (packet[0] & 0x0F) * 4;
        int sum = 0;
        
        for (int i = 0; i < ipLength; i += 2) {
            sum += ((packet[i] & 0xFF) << 8) | (packet[i + 1] & 0xFF);
        }
        
        // Add carry bits
        sum = (sum >> 16) + (sum & 0xFFFF);
        sum += (sum >> 16);
        
        int ipChecksum = ~sum & 0xFFFF;
        packet[10] = (byte) ((ipChecksum >> 8) & 0xFF);
        packet[11] = (byte) (ipChecksum & 0xFF);
        
        // Let the kernel handle TCP/UDP checksums as they require pseudo-header
        // Most modern NICs also support checksum offloading
    }
    
    /**
     * Retrieves the current NAT statistics, including total mappings,
     * active TCP and UDP connections, and port usage statistics.
     *
     * @return A {@code Map<String, Object>} containing various NAT statistics.
     */
    public Map<String, Object> getStats() {
        Map<String, Object> stats = new HashMap<>();
        stats.put("totalMappings", portMappings.size());
        
        // Count active TCP/UDP connections
        long tcpCount = portMappings.values().stream()
            .filter(m -> m.protocol == 6).count();
        long udpCount = portMappings.values().stream()
            .filter(m -> m.protocol == 17).count();
            
        stats.put("activeTCP", tcpCount);
        stats.put("activeUDP", udpCount);
        
        // Get port usage statistics
        stats.put("nextAvailablePort", nextPort.get());
        stats.put("portPoolSize", MAX_DYNAMIC_PORT - MIN_DYNAMIC_PORT);
        stats.put("portPoolUsage", 
            String.format("%.2f%%", 
                (double)portMappings.size() / (MAX_DYNAMIC_PORT - MIN_DYNAMIC_PORT) * 100));
                
        return stats;
    }

    
    /**
     * Constructs a new {@code NATHandler} instance.
     *
     * <p>
     * Initializes the NAT handler, setting up necessary configurations and resources
     * required for managing NAT operations within the P2P VPN network.
     * </p>
     */
    public NATHandler() {}
}
